1: %{
2: /* Prologue */
3: /*
4: Copyright (C) 2019 Dennis Earl Smiley
5: 
6: This file is part of pnfhra.
7: 
8:     pnfhra is free software: you can redistribute it and/or modify
9:     it under the terms of the GNU General Public License as published by
10:     the Free Software Foundation, either version 3 of the License, or
11:     (at your option) any later version.
12: 
13:     pnfhra is distributed in the hope that it will be useful,
14:     but WITHOUT ANY WARRANTY; without even the implied warranty of
15:     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
16:     GNU General Public License for more details.
17: 
18:     You should have received a copy of the GNU General Public License
19:     along with pnfhra.  If not, see <https://www.gnu.org/licenses/>. 
20: */
21: /*
22: CHANGELOG
23: =========
24: 
25: 5/3/19 Origional a-a-a - 1. The first version.
26: 			 2. Added structs.
27: */
28: #include <deslib/deslib.hpp>
29: #include <cmath>
30: #include <sstream>
31: #include <typeinfo>
32: 
33: #include "..\pnf.hpp"
34: 
35: 
36: #define YYSTYPE PNF_Variable
37: #define YYDEBUG 1
38: 
39: 
40: int main(int argc, char ** argv);
41: void yyerror(char const * c);
42: String get_extension(String fileName);
43: String strip_extension(String fileName);
44: void preprocess(String arg);
45: int conprint(const char * format, ...);
46: void movelineno(unsigned long index, unsigned long line);
47: void sort(Array<unsigned long> & array);
48: void sort_lines(Array<String> & array);
49: int yylex();
50: String strip_quotes(String str);
51: FILE * output;
52: 
53: PNF_Type_Enum exptype;
54: 
55: 
56: class Var
57: {
58:  private:
59:   String itsname;
60:   PNF_Variable itsvalue;
61:   unsigned long itsaddress;
62: 
63:  public:
64:   Var();
65:   Var(int v);
66: 
67: 
68:   void name(String name);
69:   String name();
70: 
71:   void value(PNF_Variable value);
72:   PNF_Variable value();
73: 
74:   void address(unsigned long a);
75:   unsigned long address();
76: 
77:   Var operator=(const Var & v);
78: };
79: 
80: Var::Var()
81: {
82:  itsname = "";
83:  itsvalue.to_number().put(0);
84:  itsaddress = 0;
85: }
86: 
87: Var::Var(int v)
88: {
89:  itsname = "";
90:  PNF_Number n(v);
91:  PNF_Variable p(n);
92:  itsvalue = p;
93:  itsaddress = 0;
94: }
95: 
96: void Var::name(String name)
97: {
98:  itsname = name;
99: }
100: 
101: String Var::name()
102: {
103:  return itsname;
104: }
105: 
106: void Var::value(PNF_Variable value)
107: {
108:  itsvalue = value;
109: }
110: 
111: PNF_Variable Var::value()
112: {
113:  return itsvalue;
114: }
115: 
116: void Var::address(unsigned long a)
117: {
118:  itsaddress = a;
119: }
120: 
121: unsigned long Var::address()
122: {
123:  return itsaddress;
124: }
125: 
126: Var Var::operator=(const Var & v)
127: {
128:  if (this == &v)
129:   return *this;
130: 
131:  itsname = v.itsname;
132:  itsvalue = v.itsvalue;
133:  itsaddress = v.itsaddress;
134:   
135:   
136:  return (*this);
137: }
138: 
139: 
140: class CLabel
141: {
142:  private:
143:   String itsname;
144:   unsigned long itsaddress;
145:   bool itsdeclared;
146: 
147:  public:
148:   CLabel();
149:   CLabel(int i);
150: 
151: 
152:   void name(String name);
153:   String name();
154: 
155:   void address(unsigned long a);
156:   unsigned long address();
157: 
158:   void declared(bool d);
159:   bool declared();
160: };
161: 
162: CLabel::CLabel()
163: {
164:  itsname = "";
165:  itsaddress = 0;
166: }
167: 
168: CLabel::CLabel(int i)
169: {
170:  itsname = "";
171:  itsaddress = i;
172:  itsdeclared = false;
173: }
174: 
175: void CLabel::name(String name)
176: {
177:  itsname = name;
178: }
179: 
180: String CLabel::name()
181: {
182:  return itsname;
183: }
184: 
185: void CLabel::address(unsigned long a)
186: {
187:  itsaddress = a;
188: }
189: 
190: unsigned long CLabel::address()
191: {
192:  return itsaddress;
193: }
194: 
195: void CLabel::declared(bool d)
196: {
197:  itsdeclared = d;
198: }
199: 
200: bool CLabel::declared()
201: {
202:  return itsdeclared;
203: }
204: 
205: class CELabel : public CLabel
206: {
207:  protected:
208:   static unsigned long itshevents;
209:   static unsigned long itsshevents;
210:   static unsigned long itsevents;
211:   static unsigned long itsexceptions;
212:   static unsigned long itsints;
213: 
214:  
215:  public:
216:   CELabel();
217:   CELabel(int i);
218: 
219:   static void inchevents();
220:   static void dechevents();
221:   static unsigned long hevents();
222: 
223:   static void incshevents();
224:   static void decshevents();
225:   static unsigned long shevents();
226: 
227:   static void incevents();
228:   static void decevents();
229:   static unsigned long events();
230: 
231:   static void incexceptions();
232:   static void decexceptions();
233:   static unsigned long exceptions();
234: 
235:   static void incints();
236:   static void decints();
237:   static unsigned long ints();
238: };
239: 
240: 
241: unsigned long CELabel::itshevents = 0;
242: unsigned long CELabel::itsshevents = 0;
243: unsigned long CELabel::itsevents = 0;
244: unsigned long CELabel::itsexceptions = 0;
245: unsigned long CELabel::itsints = 0;
246: 
247: CELabel::CELabel() : CLabel()
248: {
249: 
250: }
251: 
252: CELabel::CELabel(int i) : CLabel(i)
253: {
254: 
255: }
256: 
257: void CELabel::inchevents()
258: {
259:  ++itshevents;
260: }
261: 
262: void CELabel::dechevents()
263: {
264:  --itshevents;
265: }
266: 
267: unsigned long CELabel::hevents()
268: {
269:  return itshevents;
270: }
271: 
272: void CELabel::incshevents()
273: {
274:  ++itsshevents;
275: }
276: 
277: void CELabel::decshevents()
278: {
279:  --itsshevents;
280: }
281: 
282: unsigned long CELabel::shevents()
283: {
284:  return itsshevents;
285: }
286: 
287: void CELabel::incevents()
288: {
289:  ++itsevents;
290: }
291: 
292: void CELabel::decevents()
293: {
294:  --itsevents;
295: }
296: 
297: unsigned long CELabel::events()
298: {
299:  return itsevents;
300: }
301: 
302: void CELabel::incexceptions()
303: {
304:  ++itsexceptions;
305: }
306: 
307: void CELabel::decexceptions()
308: {
309:  --itsexceptions;
310: }
311: 
312: unsigned long CELabel::exceptions()
313: {
314:  return itsexceptions;
315: }
316: 
317: void CELabel::incints()
318: {
319:  ++itsints;
320: }
321: 
322: void CELabel::decints()
323: {
324:  --itsints;
325: }
326: 
327: unsigned long CELabel::ints()
328: {
329:  return itsints;
330: }
331: 
332: class Param
333: {
334:  protected:
335:   String itsname;
336:   PNF_Variable itsparam;
337: 
338: 
339:  public:
340:   Param(int i = 0);
341: 
342:   String name();
343:   void name(String n);
344: 
345:   PNF_Variable param();
346:   void param(PNF_Variable v);
347: };
348: 
349: Param::Param(int i)
350: {
351:  itsname = "";
352:  PNF_Void v;
353:  itsparam.put(v);
354: }
355: 
356: String Param::name()
357: {
358:  return itsname;
359: }
360: 
361: void Param::name(String n)
362: {
363:  itsname = n;
364: }
365: 
366: PNF_Variable Param::param()
367: {
368:  return itsparam;
369: }
370: 
371: void Param::param(PNF_Variable v)
372: {
373:  itsparam = v;
374: }
375: 
376: class Function
377: {
378:  protected:
379:   PNF_Variable itsret;
380:   String itsname;
381:   Array<Param> itsparam;
382: 
383:  public:
384:   Function();
385:   Function(int i);
386: 
387:   Function(const Function & f);
388: 
389: 
390:   ~Function();
391: 
392: 
393:  PNF_Variable ret();
394:  String name();
395:  Array<Param> params();
396:  PNF_Variable param(unsigned long i);
397:  String pname(unsigned long i);
398: 
399:  void ret(PNF_Variable r);
400:  void name(String n);
401:  void params(Array<Param> p);
402:  void param(unsigned long i, PNF_Variable v);
403:  void pname(unsigned long i, String n);
404: };
405: 
406: Function::Function()
407: {
408:  PNF_Void v;
409:  PNF_Variable v2(v);
410:  itsret = v2;
411: 
412:  itsname = "";
413: }
414: 
415: Function::Function(int i)
416: {
417:  Function();
418: }
419: 
420: Function::Function(const Function & f)
421: {
422:  itsret = f.itsret;
423:  itsname = f.itsname;
424:  itsparam = f.itsparam;
425: }
426: 
427: Function::~Function()
428: {
429: 
430: }
431: 
432: PNF_Variable Function::ret()
433: {
434:  return itsret;
435: }
436: 
437: String Function::name()
438: {
439:  return itsname;
440: }
441: 
442: Array<Param> Function::params()
443: {
444:  return itsparam;
445: }
446: 
447: PNF_Variable Function::param(unsigned long i)
448: {
449:  return itsparam[i].param();
450: }
451: 
452: String Function::pname(unsigned long i)
453: {
454:  return itsparam[i].name();
455: }
456: 
457: void Function::ret(PNF_Variable r)
458: {
459:  itsret = r;
460: }
461: 
462: void Function::name(String n)
463: {
464:  itsname = n;
465: }
466: 
467: void Function::params(Array<Param> p)
468: {
469:  itsparam = p;
470: }
471: 
472: void Function::param(unsigned long i, PNF_Variable v)
473: {
474:  itsparam[i].param(v);
475: }
476: 
477: void Function::pname(unsigned long i, String n)
478: {
479:  itsparam[i].name(n);
480: }
481: 
482: class Function_Stack
483: {
484:  protected:
485:   Array<Function> itsstk;
486: 
487:  
488:  public:
489:   Function_Stack(int i = 0);
490: 
491:   Array<Function> get();
492:   
493:   void set(Array<Function> f);
494: 
495:   void add_function(Function f);
496:   Function get_function(unsigned long i);
497:   Function get_function(String n, bool & f);
498:   void mod_function(unsigned long i, Function f);
499: 
500:  unsigned long find_duplicate(Function f, bool & b);
501: };
502: 
503: Function_Stack::Function_Stack(int i)
504: {
505: 
506: }
507: 
508: Array<Function> Function_Stack::get()
509: {
510:  return itsstk;
511: }
512:   
513: void Function_Stack::set(Array<Function> f)
514: {
515:  itsstk = f;
516: }
517: 
518: void Function_Stack::add_function(Function f)
519: {
520:  bool b = false;
521:  unsigned long index = find_duplicate(f, b);
522:  if (!b)
523:  {
524:   if (itsstk.length() != 1)
525:    itsstk.insert();
526: 
527:   itsstk[itsstk.length() - 1] = f;
528:  }
529: }
530: 
531: Function Function_Stack::get_function(unsigned long i)
532: {
533:  return itsstk[i];
534: }
535: 
536: Function Function_Stack::get_function(String n, bool & f)
537: {
538:  Function itsnull;
539:  bool found = false;
540:  unsigned long i;
541:  for (i = 0; i < itsstk.length(); ++i)
542:  {
543:   String name = itsstk[i].name();
544:   if (name == n)
545:   {
546:    found = true;
547:    break;
548:   }
549:  }
550: 
551:  if (found == false)
552:  {
553:   f = false;
554:   return itsnull;
555:  }
556:  else
557:  {
558:   f = true;
559:   return itsstk[i];
560:  }
561: }
562: 
563: void Function_Stack::mod_function(unsigned long i, Function f)
564: {
565:  itsstk[i] = f;
566: }
567: 
568: unsigned long Function_Stack::find_duplicate(Function f, bool & b)
569: {
570:  unsigned long ret;
571:  b = false;
572:  unsigned long i;
573:  for (i = 0; i < itsstk.length(); ++i)
574:  {
575:   if (itsstk[i].name() == f.name())
576:   {
577:    b = false;
578:    if (itsstk[i].ret().getm() == f.ret().getm())
579:    {
580:     for (unsigned j = 0; j < itsstk[i].params().length(); ++j)
581:     {
582:      if (itsstk[i].param(j).getm() != f.param(j).getm())
583:       b = true;
584:     }
585:    }
586:   }
587:  }
588: 
589:  ret = i;
590:  return ret;
591: }
592: 
593: class Struct
594: {
595:  protected:
596:   String itsname;
597:   Array<Var> itsvars;
598: 
599:  public:
600:   Struct(int i = 0);
601: 
602:   String name();
603:   void name(String n);
604: 
605:   Array<Var> vars();
606:   
607:   Var var(unsigned long i);
608:   void var(unsigned long i, Var v);
609: 
610:   unsigned long vnumber();
611: };
612: 
613: Struct::Struct(int i)
614: {
615: 
616: }
617: 
618: String Struct::name()
619: {
620:  return itsname;
621: }
622: 
623: void Struct::name(String n)
624: {
625:  itsname = n;
626: }
627: 
628: Array<Var> Struct::vars()
629: {
630:  return itsvars;
631: }
632:   
633: Var Struct::var(unsigned long i)
634: {
635:  return itsvars[i];
636: }
637: 
638: void Struct::var(unsigned long i, Var v)
639: {
640:  itsvars[i] = v;
641: }
642: 
643: unsigned long Struct::vnumber()
644: {
645:  return itsvars.length();
646: }
647: 
648: 
649: class ASTNode
650: {
651:  protected:
652:   String name;
653:   Array<String> value;
654:   unsigned long valuecount;
655: 
656: 
657:  public:
658:   ASTNode(const String n = "");
659:   ASTNode(char * n);
660:   ASTNode(const Array<String> v, const String n = "");
661: 	
662:   ASTNode(ASTNode & n);
663: 
664:   ~ASTNode();
665: 
666:   
667:   String getName();
668:   Array<String> getValue();
669: 
670:   void setName(const String n);
671:   void setValue(const Array<String> v);
672: 
673:   void setNode(const ASTNode n);
674: 
675: 
676:   int conprint(const char * format, ...);
677: 
678: 
679:   ASTNode operator=(ASTNode & n);
680: };
681: 
682: ASTNode::ASTNode(const String n)
683: {
684:  name = n;
685:  valuecount = 0;
686: }
687: 
688: ASTNode::ASTNode(char * n)
689: {
690:  name = n;
691:  valuecount = 0;
692: }
693: 
694: ASTNode::ASTNode(const Array<String> v, const String n)
695: {
696:  name = n;
697:  value = v;
698:  valuecount = value.length();
699: }
700: 
701: ASTNode::ASTNode(ASTNode & n)
702: {
703:  name = n.getName();
704:  
705:  for (unsigned long i = 0; i < n.value.length(); ++i)
706:  {
707:   if (i != 0)
708:    value.insert();
709: 
710:   value[i] = n.value[i];
711:  }
712: }
713: 
714: ASTNode::~ASTNode()
715: {
716:  
717: }
718: 
719: String ASTNode::getName()
720: {
721:  return name;
722: }
723: 
724: Array<String> ASTNode::getValue()
725: {
726:  return value;
727: }
728: 
729: void ASTNode::setName(String n)
730: {
731:  name = n;
732: }
733: 
734: void ASTNode::setValue(Array<String> v)
735: {
736:  for (unsigned long i = 0; i < v.length(); ++i)
737:  {
738:   if (i != 0)
739:    value.insert();
740: 
741:   value[i] = v[i];
742:  }
743: }
744: 
745: void ASTNode::setNode(ASTNode n)
746: {
747:  name = n.getName();
748:  
749:  for (unsigned long i = 0; i < n.value.length(); ++i)
750:  {
751:   if (i != 0)
752:    value.insert();
753: 
754:   value[i] = n.value[i];
755:  }
756: }
757: 
758: int ASTNode::conprint(const char * format, ...)
759: {
760:  char outbuffer[256];
761: 
762: 
763:  va_list arg;
764:  int done = 0;
765: 
766:  va_start(arg, format);
767: 
768:  value.insert();
769:  done = vsnprintf(outbuffer, 256, format, arg);
770:  String str = "";
771:  if (outbuffer != NULL)
772:   str += outbuffer;
773:  value[valuecount] = str;
774:  ++valuecount;
775: 
776:  va_end(arg);
777: 
778: 
779:  return done;
780: }
781: 
782: ASTNode ASTNode::operator=(ASTNode & n)
783: {
784:  if (this == &n)
785:   return *this;
786: 
787:  name = n.name;
788:  value = n.value;
789: 
790:  return *this; 
791: }
792: 
793: class ASTTree
794: {
795:  protected:
796:   Array<ASTNode *> nodes;
797: 
798: 
799:  public:
800:   ASTTree();
801:   ASTTree(ASTTree & t);
802:   ~ASTTree();
803: 
804: 
805:   void add_node(ASTNode & node);
806:   void remove_node();
807:   void remove_node(String n);
808: 
809:   ASTNode & getNode(String n);
810:   ASTNode & getNode(unsigned long offset);
811:   void setNode(String n, ASTNode & node);
812:   void setNode(unsigned long offset, ASTNode & node);
813: 
814:   unsigned long nodenumber();
815: };
816: 
817: ASTTree::ASTTree()
818: {
819:  nodes[0] = 0;
820: }
821: 
822: ASTTree::ASTTree(ASTTree & t)
823: {
824:  nodes = t.nodes;
825: }
826: 
827: ASTTree::~ASTTree()
828: {
829:  for (unsigned long i = 1; i < nodenumber(); ++i)
830:   remove_node();
831: }
832: 
833: void ASTTree::add_node(ASTNode & node)
834: {
835:  if (nodes.length() == 1 && nodes[0] == NULL)
836:   nodes[0] = new ASTNode (node);
837:  else
838:  {
839:   nodes.insert();
840:   nodes[nodes.length() - 1] = new ASTNode(node);
841:  }
842: }
843: 
844: void ASTTree::remove_node()
845: {
846:  if (nodes.length() > 1)
847:  {
848:   delete nodes[nodes.length() - 1];
849:   nodes[nodes.length() - 1] = NULL;
850:   nodes.remove();
851:  }
852:  else if (nodes.length() == 1 && nodes[0] != NULL)
853:  {
854:   delete nodes[0];
855:   nodes[0] = NULL;
856:  }
857:  else
858:  {
859:   cout << "* ERROR: Called ASTTree::remove_node(), but nothing to do." << endl;
860:   exit(-1);
861:  }
862: }
863: 
864: void ASTTree::remove_node(String n)
865: {
866:  for (unsigned long i = 0; i < nodes.length(); ++i)
867:  {
868:   if (nodes[i]->getName().getString() == n.getString())
869:   {
870:    nodes.remove(i);
871:   }
872:  }
873: }
874: 
875: ASTNode & ASTTree::getNode(String n)
876: {
877:  for (unsigned long i = 0; i < nodes.length(); ++i)
878:  {
879:   if (nodes[i]->getName().getString() == n.getString())
880:    return *nodes[i];
881:  }
882: }
883:  
884: ASTNode & ASTTree::getNode(unsigned long offset)
885: {
886:  if (offset < nodes.length())
887:  {
888:   return *nodes[offset];
889:  }
890:  else if (offset < 0 || offset > nodes.length())
891:  {
892:   String errormsg = "Index out of bounds. node = ";
893:   String temp;
894:   char temp2[33];
895:   itoa(offset, temp2, 10);
896:   temp = temp2;
897:   errormsg += temp;
898:   cout << "* ERROR: " << errormsg.getString().c_str() << endl;
899:   exit(-1);
900:  }
901: }
902: 
903: void ASTTree::setNode(String n, ASTNode & node)
904: {
905:  for (unsigned long i = 0; i < nodes.length(); ++i)
906:  {
907:   if (nodes[i]->getName().getString() == n.getString())
908:   {
909:    nodes[i] = NULL;
910:    nodes[i] = new ASTNode(node);
911:   }
912:  }
913: }
914: 
915: void ASTTree::setNode(unsigned long offset, ASTNode & node)
916: {
917:  if (offset < nodes.length())
918:  {
919:   nodes[offset] = NULL;
920:   nodes[offset] = new ASTNode(node);
921:  }
922:  else
923:  {
924:   String errormsg = "Index out of bounds. node = ";
925:   String temp;
926:   char temp2[33];
927:   itoa(offset, temp2, 10);
928:   temp = temp2;
929:   errormsg += temp;
930:   cout << "* ERROR: " << errormsg.getString().c_str() << endl;
931:   exit(-1);
932:  }
933: }
934: 
935: unsigned long ASTTree::nodenumber()
936: {
937:  return nodes.length();
938: }
939: 
940: 
941: unsigned long scope = 0;
942: Array< Array<Var> > varTable;
943: Array<CLabel> labelTable;
944: Array<CELabel> eventLabelTable;
945: Array<CLabel> parameterTable;
946: 
947: Array<String> out;
948: char outbuffer[256];
949: unsigned long outcount;
950: 
951: Function_Stack funcs;
952: unsigned long paramcount;
953: unsigned long paramcount2;
954: Function * current_func;
955: unsigned long current_param = 0;
956: 
957: Array<Struct> structs;
958: unsigned long struct_counter = 0;
959: 
960: 
961: ASTTree tree;
962: %}
963: /* Bison Declarations */
964: %debug
965: 
966: 
967: %expect 44
968: %error-verbose
969: 
970: 
971: %left OPINC OPDEC
972: %left NEG
973: %left OPNOT OPBTNOT
974: %left OPAMP
975: %right OPPOWER OPROOT
976: %left OPTIMES OPDIV OPMODULUS
977: %left OPMINUS OPPLUS
978: %left OPBTSL OPBTSR
979: %left OPLSS OPLEQU OPGTR OPGEQU
980: %left OPEQU OPNEQU
981: %left OPBTXOR OPBTOR
982: %left OPAND
983: %left OPOR
984: %right OPEQUAL
985: 
986: %token LEFTP
987: %token RIGHTP
988: %token LEFTB
989: %token RIGHTB
990: 
991: %token VOIDV
992: %token BOOLEANV
993: %token NUMBERV
994: %token CHARACTERV
995: %token STRINGV
996: 
997: %token SEND
998: %token COMMA
999: 
1000: %token OPEQUAL
1001: %token OPPLUS
1002: %token OPMINUS
1003: %token OPTIMES
1004: %token OPDIV
1005: %token OPMODULUS
1006: %token OPPOWER
1007: %token OPROOT
1008: %token OPINC
1009: %token OPDEC
1010: %token OPAND
1011: %token OPAMP
1012: %token OPOR
1013: %token OPNOT
1014: %token OPQUES
1015: %token OPCOLON
1016: %token OPSUB
1017: %token OPEQU
1018: %token OPNEQU
1019: %token OPGTR
1020: %token OPLSS
1021: %token OPLEQU
1022: %token OPGEQU
1023: %token OPBTOR
1024: %token OPBTXOR
1025: %token OPBTNOT
1026: %token OPBTSL
1027: %token OPBTSR
1028: %token OPSTR
1029: 
1030: %token ID
1031: 
1032: %token VAR
1033: %token PRINT
1034: %token PRINTLN
1035: %token EPRINT
1036: %token EPRINTLN
1037: %token END
1038: %token ASM
1039: %token TYPE
1040: %token READ
1041: %token LOAD
1042: %token LTYPE
1043: %token GOTO
1044: %token GTYPE
1045: %token ST
1046: %token PUSH
1047: %token POP
1048: %token TYPEOF
1049: %token RTYPE
1050: %token ATOC
1051: %token SWITCH
1052: %token CSWITCH
1053: %token CRASH
1054: %token VERSION
1055: %token VTYPE
1056: %token HALT
1057: %token MODT
1058: %token RETURN
1059: %token GOSUB
1060: %token SUB
1061: %token EVENT
1062: %token STYPE
1063: %token ATYPE
1064: %token CTYPE
1065: %token CMTYPE
1066: %token BFMODEC
1067: %token FMODEC
1068: %token UNREGISTER
1069: %token REGISTER
1070: %token REREGISTER
1071: %token STORE
1072: %token IF
1073: %token ELSE
1074: %token CASE
1075: %token CCASE
1076: %token DEFAULT
1077: %token CDEFAULT
1078: %token BREAK
1079: %token LABEL
1080: %token WHILE
1081: %token ADDRESSOF
1082: %token ADD2V
1083: %token STOREA
1084: %token DOWHILE
1085: %token DOFOR
1086: %token FOR
1087: %token FVAR
1088: %token FOREVER
1089: %token CONTINUE
1090: %token CHECK
1091: %token HCMNT
1092: %token FMODE
1093: %token FOPEN
1094: %token FCLOSE
1095: %token FEOF
1096: %token FPRINT
1097: %token FPRINTLN
1098: %token FREAD
1099: %token MEML
1100: %token ENUM
1101: %token ENUMV
1102: %token VTYPE2
1103: %token RANGE
1104: %token RTYPE2
1105: %token OPDOT
1106: %token RANGEV
1107: %token OPLSQ
1108: %token OPRSQ
1109: %token ARRAY
1110: %token BLANK
1111: %token PNFASM
1112: %token LENGTH
1113: %token DUP
1114: %token THEN
1115: %token ENDIF
1116: %token DONEIF
1117: %token ATOSP
1118: %token SPTOA
1119: %token FUNCTION
1120: %token STRUCT
1121: %token STRUCTB
1122: %token STRUCTE
1123: 
1124: 
1125: %token PBIN
1126: %token PPBIN
1127: %token PLIB
1128: 
1129: %token PINCLUDE
1130: %token PIMPORT
1131: %token PDEFINE
1132: %token PMACRO
1133: %token PENDM
1134: %token PUNDEF
1135: %token PIFDEF
1136: %token PIFNDEF
1137: %token PELSE
1138: %token PENDIF
1139: %token PPDATE
1140: %token PPTIME
1141: %token PPLINE
1142: %token PPFILE
1143: %token PPCDATE
1144: %token PPCTIME
1145: 
1146: %token PPINCLUDE
1147: %token PPIMPORT
1148: %token PPDEFINE
1149: %token PPMACRO
1150: %token PPENDM
1151: %token PPUNDEF
1152: %token PPIFDEF
1153: %token PPIFNDEF
1154: %token PPELSE
1155: %token PPENDIF
1156: %token PPPDATE
1157: %token PPPTIME
1158: %token PPPLINE
1159: %token PPPFILE
1160: %token PPPCDATE
1161: %token PPPCTIME
1162: 
1163: %%
1164: /* Grammar Rules */
1165: 
1166: input:	// Empty
1167: 	| input line {  }
1168: 	;
1169: 
1170: line:	{
1171: 	}
1172: 	"\n"
1173: 	| statement
1174: 	| error		{ yyerrok; }
1175: 	;
1176: 
1177: statement:	{
1178: 		}
1179: 		stmt
1180: 		| statement COMMA stmt
1181: 		;
1182: 
1183: stmt:		control_statement { }
1184: 		| SEND { conprint("VOID TVOID 0V\n"); }
1185: 		| expression_statement  { }
1186: 		| declaration_statement  { }
1187: 		| label_statement  { }
1188: 		| command_statement  { }
1189: 		| statement_block  {
1190: 				   }
1191: 		| pp_directive
1192: 		| pp_statement
1193: 		;
1194: 
1195: expression_statement:	expression SEND
1196: 			{
1197: 			}
1198: 			;
1199: 
1200: declaration_statement:	declaration SEND
1201: 			{
1202: 			}
1203: 			;
1204: 
1205: command_statement:	command SEND
1206: 			{
1207: 			}
1208: 			;
1209: 
1210: label_statement:	ID OPCOLON 
1211: 			{
1212: 			 conprint("%s:\n", $1.to_string().get().getString().c_str());
1213: 			}
1214: 			| SUB ID OPCOLON
1215: 			{
1216: 			 conprint("sub %s:\n", $1.to_string().get().getString().c_str());
1217: 			}
1218: 			| EVENT ID OPCOLON
1219: 			{
1220: 			 conprint("event %s:\n", $1.to_string().get().getString().c_str());
1221: 			}
1222: 			;
1223: 
1224: control_statement:	if_statement
1225: 			{
1226: 			}
1227: 			| switch_statement
1228: 			{
1229: 			}
1230: 			| loop_statement
1231: 			{
1232: 			}
1233: 			;
1234: 
1235: if_statement:		IF LEFTP
1236: 			{
1237: 			 conprint("if ({\n");
1238: 			} 
1239: 			stmt 
1240: 			RIGHTP
1241: 			{
1242: 			 conprint ("\n})");
1243: 			}
1244: 			THEN			
1245: 			{
1246: 			 conprint(" then\n");			 
1247: 			}
1248: 			stmt
1249: 			{
1250: 			}
1251: 			ENDIF
1252: 			{
1253: 			 conprint("\nendif\n");
1254: 			}
1255: 			opt_else
1256: 			{
1257: 			}
1258: 			eif			
1259: 			{
1260: 			 conprint("\ndoneif\n");
1261: 			}
1262: 			;
1263: 
1264: opt_else:		| ELSE
1265: 			{
1266: 			 conprint("\nelse\n");
1267: 			}
1268: 			stmt
1269: 			ENDIF
1270: 			{
1271: 			 conprint("\nendif\n");
1272: 			}
1273: 			;
1274: 
1275: eif:			DONEIF
1276: 			;
1277: 			
1278: switch_statement:	SWITCH LEFTP expression RIGHTP LEFTB
1279: 			{
1280: 			 conprint("switch (%s)\n{", $3.to_string().get().getString().c_str());
1281: 			}
1282: 			case_statements
1283: 			{
1284: 
1285: 			}
1286: 			opt_default_statement
1287: 			{
1288: 			}
1289: 			{
1290: 
1291: 			}
1292: 			RIGHTB
1293: 			{
1294: 			}
1295: 			| CSWITCH LEFTP
1296: 			{
1297: 			 conprint("cswitch (");
1298: 			}
1299: 			stmt 
1300: 			RIGHTP
1301: 			{
1302: 			 conprint(")\n");
1303: 			}
1304: 			LEFTB
1305: 			{
1306: 			 conprint("{\n");
1307: 			}
1308: 			case_statements2
1309: 			{
1310: 			}
1311: 			RIGHTB
1312: 			{
1313: 			 conprint("}\n");
1314: 			}
1315: 			;
1316: 
1317: case_statements:	{
1318: 			}
1319: 			case_statement
1320: 			| case_statements case_statement
1321: 			;
1322: 
1323: case_statement:		CASE expression
1324: 			{
1325: 			 conprint("case %s:\n", $2.to_string().get().getString().c_str());
1326: 			}
1327: 			OPCOLON stmt
1328: 			{
1329: 			}
1330: 			;
1331: 
1332: opt_default_statement:	| DEFAULT OPCOLON
1333: 			{
1334: 			 conprint("default:\n");
1335: 			}
1336: 			stmt
1337: 			{
1338: 
1339: 			}
1340: 			;
1341: 
1342: case_statements2:	{
1343: 			}
1344: 			case_statement2
1345: 			| case_statements2 case_statement2
1346: 			;
1347: 
1348: case_statement2:	CCASE expression
1349: 			{
1350: 			 conprint("ccase %s:\n", $2.to_string().get().getString().c_str());
1351: 			}
1352: 			OPCOLON
1353: 			{
1354: 			}
1355: 			stmt
1356: 			{
1357: 			}
1358: 			;
1359: 
1360: opt_default_statement2:	| CDEFAULT OPCOLON
1361: 			{
1362: 			 conprint("cdefault:\n");
1363: 			}
1364: 			stmt
1365: 			{
1366: 
1367: 			}
1368: 			;
1369: 
1370: loop_statement:		{
1371: 			}
1372: 			while_loop
1373: 			{
1374: 			}
1375: 			| whileb_loop
1376: 			{
1377: 			}
1378: 			| for_loop
1379: 			{
1380: 			}
1381: 			| forb_loop
1382: 			{
1383: 			}
1384: 			| forever_loop
1385: 			{
1386: 			}
1387: 			{
1388: 			}
1389: 			;
1390: 
1391: while_loop:		WHILE LEFTP
1392: 			{
1393: 			 conprint("while (");
1394: 			}
1395: 			stmt
1396: 			{
1397: 			}
1398: 			RIGHTP
1399: 			{
1400: 			 conprint(")\n");
1401: 			}
1402: 			stmt
1403: 			{
1404: 			}
1405: 			;
1406: 
1407: whileb_loop:		{
1408: 			}
1409: 			DOWHILE
1410: 			{
1411: 			 conprint("dowhile\n");
1412: 			}
1413: 			stmt
1414: 			WHILE 
1415: 			{
1416: 			 conprint("while");
1417: 			}
1418: 			LEFTP
1419: 			{
1420: 			 conprint("(");
1421: 			}
1422: 			stmt
1423: 			{
1424: 			}
1425: 			RIGHTP
1426: 			{
1427: 			 conprint(")");
1428: 			}
1429: 			;
1430: 
1431: for_loop:		{
1432: 			}
1433: 			FOR LEFTP
1434: 			{
1435: 			 conprint("for (");
1436: 			}
1437: 			stmt 
1438: 			SEND	// Initialization
1439: 			{
1440: 			 conprint ("; ");
1441: 			}
1442: 			stmt
1443: 			SEND	// Condition
1444: 			{
1445: 			 conprint("; ");
1446: 			}
1447: 			stmt		// Increment Statement
1448: 			{
1449: 			}
1450: 			RIGHTP
1451: 			{
1452: 			 conprint(")\n");
1453: 			}
1454: 			stmt
1455: 			{
1456: 			}
1457: 			;
1458: 
1459: forb_loop:		DOFOR
1460: 			{
1461: 			 conprint("dofor\n");
1462: 			}
1463: 			stmt
1464: 			{
1465: 			}
1466: 			FOR LEFTP
1467: 			{
1468: 			 conprint("for (");
1469: 			}
1470: 			stmt
1471: 			SEND	// Initialization
1472: 			{
1473: 			 conprint("; ");
1474: 			}
1475: 			stmt
1476: 			SEND	// Condition
1477: 			{
1478: 			 conprint("; ");
1479: 			}
1480: 			stmt		// Increment Statement
1481: 			{
1482: 			}
1483: 			RIGHTP
1484: 			{
1485: 			 conprint(")");
1486: 			}
1487: 			;
1488: 
1489: forever_loop:		FOREVER 
1490: 			{
1491: 			 conprint("forever\n");
1492: 			}
1493: 			stmt
1494: 			{
1495: 			}
1496: 
1497: statement_block:	LEFTB
1498: 			{
1499: 			 conprint("{\n");
1500: 			}
1501: 			statements
1502: 			RIGHTB
1503: 			{
1504: 			 conprint("}\n");
1505: 			}
1506: 			;
1507: 
1508: statements:		statement
1509: 			{
1510: 			}
1511: 			| statement statements
1512: 			{
1513: 			}
1514: 			;
1515: 
1516: expression:	void_expression { exptype = TVOID; }
1517: 		| boolean_expression
1518: 		{
1519: 		 exptype = TBOOLEAN;		 
1520: 		}
1521: 		| number_expression { exptype = TNUMBER; }
1522: 		| character_expression { exptype = TCHARACTER; }
1523: 		| string_expression { exptype = TSTRING; }
1524: 		| id_expression
1525: 		{		 
1526: 		 exptype = (PNF_Type_Enum)$$.getType();
1527: 		}
1528: 		| relational_expression { exptype = TBOOLEAN; }
1529: 		| mixed_expression { exptype = (PNF_Type_Enum)$$.getType(); }
1530: 		| function_expression { exptype = (PNF_Type_Enum)$$.getType(); }
1531: 		;
1532: 
1533: void_expression:
1534: 			VOIDV
1535: 			{
1536: 		 	 PNF_String s("0V");
1537: 			 $$.put(s);
1538: 			}
1539: 			| LEFTP void_expression RIGHTP
1540: 			{
1541: 			 $$ = $2;
1542: 			}
1543: 			;
1544: 
1545: boolean_expression:	BOOLEANV 
1546: 			{ 
1547: 			 $$ = $1;
1548: 			}
1549: 			| OPNOT boolean_expression 
1550: 			{
1551: 			 bool b;
1552: 			 String str = $2.to_boolean().get();
1553: 
1554: 			 if (str.getString() == "true")
1555: 			  b = true;
1556: 			 else
1557: 			  b = false;
1558: 
1559: 			 PNF_Boolean b2(b);
1560: 			 b2.opnot();
1561: 			 $$.put(b2);
1562: 			}
1563: 			| boolean_expression OPAND boolean_expression
1564: 			{
1565: 			 String bl = $3.to_boolean().get();
1566: 			 bool b;
1567: 			
1568: 			 if (bl.getString() == "true")
1569: 			  b = true;
1570: 			 else if (bl.getString() == "false")
1571: 			  b = false;
1572: 			 else
1573: 			  b = false;
1574: 
1575: 			 PNF_Boolean b2($1.to_boolean());
1576: 			 b2.opand(b);
1577: 			 $$.put(b2);
1578: 			}
1579: 			| boolean_expression OPOR boolean_expression
1580: 			{
1581: 			 String bl = $3.to_boolean().get();
1582: 			 bool b;
1583: 			
1584: 			 if (bl.getString() == "true")
1585: 			  b = true;
1586: 			 else if (bl.getString() == "false")
1587: 			  b = false;
1588: 			 else
1589: 			  b = false;
1590: 
1591: 			 PNF_Boolean b2($1.to_boolean());
1592: 			 b2.opor(b);
1593: 			 $$.put(b2);
1594: 			}
1595: 			| LEFTP boolean_expression RIGHTP
1596: 			{
1597: 			 $$ = $2;
1598: 			}
1599: 			;
1600: 
1601: number_expression:	NUMBERV
1602: 			{
1603: 			 PNF_Number n(yylval.to_number().get());
1604: 			 $$.put(n);
1605: 			}
1606: 			| number_expression OPPLUS number_expression	
1607: 			{
1608: 			 double d2 = $2.to_number().get();
1609: 			 double d1 = $1.to_number().get();
1610: 			 double d3 = d1 + d2;
1611: 			 PNF_Number n(d3);
1612: 			 $$.put(n);
1613: 			}
1614: 			| number_expression OPMINUS number_expression
1615: 			{
1616: 			 double d = $2.to_number().get();
1617: 			 $1.to_number().sub(d);
1618: 			 $$ = $1;
1619: 			}
1620: 			| number_expression OPTIMES number_expression
1621: 			{
1622: 			 double d = $2.to_number().get();
1623: 			 $1.to_number().mul(d);
1624: 			 $$ = $1;
1625: 			}
1626: 			| number_expression OPDIV number_expression
1627: 			{
1628: 			 double d = $2.to_number().get();
1629: 			 $1.to_number().div(d);
1630: 			 $$ = $1;
1631: 			}
1632: 			| number_expression OPMODULUS number_expression
1633: 			{
1634: 			 double d = $2.to_number().get();
1635: 			 $1.to_number().mod(d);
1636: 			 $$ = $1;
1637: 			}
1638: 			| OPMINUS number_expression	%prec NEG	
1639: 			{
1640: 			 char * str = "-";
1641: 			 strcat(str, $2.to_string().get().getString().c_str());
1642: 			 PNF_String s(str);
1643: 			 PNF_Variable v(s);
1644: 			 $$ = v;
1645: 			}
1646: 			| number_expression OPPOWER number_expression	
1647: 			{
1648: 			 double d = $2.to_number().get();
1649: 			 $1.to_number().pow(d);
1650: 			 $$ = $1;
1651: 			}
1652: 			| number_expression OPROOT number_expression
1653: 			{
1654: 			 double d = $2.to_number().get();
1655: 			 $1.to_number().root(d);
1656: 			 $$ = $1;
1657: 			}
1658: 			| OPINC number_expression
1659: 			{
1660: 			 PNF_Number n($2.to_number().get());
1661: 			 n.inc(1);
1662: 			 $$.put(n);
1663: 			}
1664: 			| number_expression OPINC
1665: 			{
1666: 			 PNF_Number n($1.to_number().get());
1667: 			 $$.put(n);
1668: 			 n.inc(1);
1669: 			}
1670: 			| OPDEC number_expression
1671: 			{
1672: 			 PNF_Number n($2.to_number().get());
1673: 			 n.dec(1);
1674: 			 $$.put(n);
1675: 			}
1676: 			| number_expression OPDEC
1677: 			{
1678: 			 PNF_Number n($1.to_number().get());
1679: 			 $$.put(n);
1680: 			 n.dec(1);
1681: 			}
1682: 			| number_expression OPAMP number_expression
1683: 			{
1684: 			 int d1 = (int)$1.to_number().get();
1685: 			 int d2 = (int)$3.to_number().get();
1686: 			 int d3 = d1 & d2;
1687: 			 PNF_Number n(d3);
1688: 			 $$.put(n);
1689: 			}
1690: 			| number_expression OPBTOR number_expression
1691: 			{
1692: 			 int d1 = (int)$1.to_number().get();
1693: 			 int d2 = (int)$3.to_number().get();
1694: 			 int d3 = d1 | d2;
1695: 			 PNF_Number n(d3);
1696: 			 $$.put(n);
1697: 			}
1698: 			| number_expression OPBTXOR number_expression
1699: 			{
1700: 			 int d1 = (int)$1.to_number().get();
1701: 			 int d2 = (int)$3.to_number().get();
1702: 			 int d3 = d1 ^ d2;
1703: 			 PNF_Number n(d3);
1704: 			 $$.put(n);
1705: 			}
1706: 			| OPBTNOT number_expression
1707: 			{
1708: 			 int d = (int)$2.to_number().get();
1709: 			 d = ~d;
1710: 			 PNF_Number n(d);
1711: 			 $$.put(n);
1712: 			}
1713: 			| number_expression OPBTSL number_expression
1714: 			{
1715: 			 int d1 = (int)$1.to_number().get();
1716: 			 int d2 = (int)$3.to_number().get();
1717: 			 int d3 = d1 << d2;
1718: 			 PNF_Number n(d3);
1719: 			 $$.put(n);
1720: 			}
1721: 			| number_expression OPBTSR number_expression
1722: 			{
1723: 			 int d1 = (int)$1.to_number().get();
1724: 			 int d2 = (int)$3.to_number().get();
1725: 			 int d3 = d1 >> d2;
1726: 			 PNF_Number n(d3);
1727: 			 $$.put(n);
1728: 			}
1729: 			| LEFTP number_expression RIGHTP
1730: 			{
1731: 			 $$ = $2;
1732: 			}
1733: 			;
1734: 
1735: character_expression:	CHARACTERV
1736: 			{
1737: 			 $$ = $1;
1738: 			}
1739: 			| character_expression OPPLUS character_expression	
1740: 			{
1741: 			 char d = $1.to_character().get();
1742: 			 PNF_Character c(d);
1743: 			 c.add($3.to_character().get());
1744: 			 $$.put(c);
1745: 			}
1746: 			| character_expression OPMINUS character_expression
1747: 			{
1748: 			 char d = $1.to_character().get();
1749: 			 PNF_Character c(d);
1750: 			 c.sub($3.to_character().get());
1751: 			 $$.put(c);
1752: 			}
1753: 			| character_expression OPTIMES character_expression
1754: 			{
1755: 			 char d = $1.to_character().get();
1756: 			 PNF_Character c(d);
1757: 			 c.mul($3.to_character().get());
1758: 			 $$.put(c);
1759: 			}
1760: 			| character_expression OPDIV character_expression
1761: 			{
1762: 			 char d = $1.to_character().get();
1763: 			 PNF_Character c(d);
1764: 			 c.div($3.to_character().get());
1765: 			 $$.put(c);
1766: 			}
1767: 			| character_expression OPMODULUS character_expression
1768: 			{
1769: 			 char d = $1.to_character().get();
1770: 			 PNF_Character c(d);
1771: 			 c.mod($3.to_character().get());
1772: 			 $$.put(c);
1773: 			}
1774: 			| character_expression OPPOWER character_expression	
1775: 			{
1776: 			 char d = $3.to_character().get();
1777: 			 PNF_Character c($1.to_character());
1778: 			 c.pow(d);
1779: 			 $$.put(c);
1780: 			}
1781: 			| character_expression OPROOT character_expression
1782: 			{
1783: 			 char d = $1.to_character().get();
1784: 			 PNF_Character c($3.to_character());
1785: 			 c.root(d);
1786: 			 $$.put(c);
1787: 			}
1788: 			| OPINC character_expression
1789: 			{
1790: 			 PNF_Character n($2.to_character().get());
1791: 			 n.inc(1);
1792: 			 $$.put(n);
1793: 			}
1794: 			| character_expression OPINC
1795: 			{
1796:  			 PNF_Character n($1.to_character().get());
1797: 			 $$.put(n);
1798: 			 n.inc(1);
1799: 			}
1800: 			| OPDEC character_expression
1801: 			{
1802:  			 PNF_Character n($2.to_character().get());
1803: 			 n.dec(1);
1804: 			 $$.put(n);
1805: 			}
1806: 			| character_expression OPDEC
1807: 			{
1808: 			 PNF_Character n($1.to_character().get());
1809: 			 $$.put(n);
1810: 			 n.dec(1);
1811: 			}
1812: 			| LEFTP character_expression RIGHTP
1813: 			{
1814: 			 $$ = $2;
1815: 			}
1816: 			;
1817: 
1818: string_expression:	STRINGV
1819: 			{
1820: 			 $$ = $1;
1821: 			}
1822: 			| string_expression OPPLUS string_expression
1823: 			{
1824: 			 String d = $1.to_string().get();
1825: 			 PNF_String s(d);
1826: 			 s.add($3.to_string().get());
1827: 
1828: 			 String str = s.get();
1829: 			 String str2 = "";
1830: 	   	         for (unsigned long i = 0, j = 0; i < str.length(); ++i)
1831: 			 {
1832: 			  if (str[i] == '\"')
1833: 			   continue;
1834: 			  else
1835: 			  {
1836: 			   str2 += str[i];
1837: 			   ++j;
1838: 			  }
1839: 			 }
1840: 
1841: 			 String str3 = '\"';
1842: 			 str3 += str2;
1843: 			 str3 += '\"';
1844: 			 s.put(str3);
1845: 			 $$.put(s);
1846: 			}
1847: 			| OPSTR string_expression
1848: 			{
1849: 			 String str = $2.to_string().get();
1850: 			 String str2 = "\"" + str + "\"";
1851: 			 PNF_String s(str2);
1852: 			 $$.put(s);
1853: 			}
1854: 			| LEFTP string_expression RIGHTP
1855: 			{
1856: 			 $$ = $2;
1857: 			}
1858: 			;
1859: 
1860: id_expression:		ID
1861: 			{
1862: 			 bool declared = false;
1863: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
1864: 			 {
1865: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
1866: 			  {
1867: 			   declared = true;
1868: 			   $$ = varTable[scope][i].value();			   			  }
1869: 			 }
1870: 
1871: 			 if (!declared)
1872: 			 {
1873: 			  String str = $1.to_string().get();
1874: 			  str += " was not declared.";
1875: 			  yyerror(str.getString().c_str());
1876: 			 }
1877: 			}			
1878: 			| OPAMP id_expression
1879: 			{
1880: 			 bool declared = false;
1881: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
1882: 			 {
1883: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
1884: 			  {
1885: 			   declared = true;
1886: 			   PNF_Number n(varTable[scope][i].address());
1887: 			   $$.put(n);
1888: 			  }
1889: 			 }
1890: 
1891: 			 if (!declared)
1892: 			 {
1893: 			  for (unsigned long i = 0; i < labelTable.length(); ++i)
1894: 			  {
1895: 			   if (strcmp(labelTable[i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
1896: 			   {
1897: 			    declared = true;
1898: 			    PNF_Number n(labelTable[i].address());
1899: 			    $$.put(n);
1900: 			   }
1901:  			  }
1902: 
1903: 
1904: 			  if (!declared)
1905: 			  {
1906: 			   for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
1907: 			   {
1908: 			    if (strcmp(eventLabelTable[i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
1909: 			    {
1910: 			     declared = true;
1911: 			     PNF_Number n(eventLabelTable[i].address());
1912: 			     $$.put(n);
1913: 			    }
1914:   			   }
1915: 			  }
1916: 			 }
1917: 			}
1918: 			| OPNOT id_expression
1919: 			{
1920: 			 bool declared = false;
1921: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
1922: 			 {
1923: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
1924: 			  {
1925: 			   declared = true;
1926: 			   PNF_Boolean b;
1927: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
1928:              		    b.put(true);
1929: 			   else
1930: 			   {
1931: 			    bool b2;
1932: 			    String str = varTable[scope][i].value().to_boolean().get();
1933: 			    if (str.getString() == "true")
1934: 			     b2 = true;
1935: 			    else if (str.getString() == "false")
1936: 			     b2 = false;
1937: 			    else
1938: 			     b2 = true;
1939: 
1940: 			    b.put(b2);
1941: 			   }
1942: 
1943: 			   b.opnot();
1944: 			   $$.put(b);
1945: 			   varTable[scope][i].value(b);			  }
1946: 			 }
1947: 
1948: 			 if (!declared)
1949: 			 {
1950: 			  String str = $2.to_string().get();
1951: 			  str += " was not declared.";
1952: 			  yyerror(str.getString().c_str());
1953: 			 }
1954: 			}
1955: 			| id_expression OPAND id_expression
1956: 			{
1957: 			 bool declared1 = false;
1958: 			 bool declared2 = false;
1959:   		   	 PNF_Boolean b1;
1960: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
1961: 			 {
1962: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
1963: 			  {
1964: 			   declared1 = true;
1965: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
1966:              		    b1.put(true);
1967: 			   else
1968: 			   {
1969: 			    bool b2;
1970: 			    String str = varTable[scope][i].value().to_boolean().get();
1971: 			    if (str.getString() == "true")
1972: 			     b2 = true;
1973: 			    else if (str.getString() == "false")
1974: 			     b2 = false;
1975: 			    else
1976: 			     b2 = true;
1977: 
1978: 			    b1.put(b2);
1979: 			   }
1980: 			  }
1981: 			 }
1982: 
1983: 			 if (!declared1)
1984: 			 {
1985: 			  String str = $3.to_string().get();
1986: 			  str += " was not declared.";
1987: 			  yyerror(str.getString().c_str());
1988: 			 }
1989: 
1990: 			 PNF_Boolean b3;
1991: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
1992: 			 {
1993: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
1994: 			  {
1995: 			   declared2 = true;
1996: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
1997:              		    b3.put(true);
1998: 			   else
1999: 			   {
2000: 			    bool b4;
2001: 			    String str = varTable[scope][i].value().to_boolean().get();
2002: 			    if (str.getString() == "true")
2003: 			     b4 = true;
2004: 			    else if (str.getString() == "false")
2005: 			     b4 = false;
2006: 			    else
2007: 			     b4 = true;
2008: 			    b3.put(b4);
2009: 			   }
2010: 			  }
2011: 			 }
2012: 
2013: 			 if (!declared2)
2014: 			 {
2015: 			  String str = $3.to_string().get();
2016: 			  str += " was not declared.";
2017: 			  yyerror(str.getString().c_str());
2018: 			 }
2019: 
2020: 			 bool b5;
2021: 			 String str = b3.get();
2022: 			 if (str.getString() == "true")
2023: 			  b5 = true;
2024: 			 else if (str.getString() == "false")
2025: 			  b5 = false;
2026: 			 else
2027: 			  b5 = true;
2028: 
2029: 			 b1.opand(b5);
2030: 			 $$.put(b1);
2031: 			}
2032: 			| id_expression OPOR id_expression
2033: 			{
2034: 			 bool declared1 = false;
2035: 			 bool declared2 = false;
2036: 			 PNF_Boolean b1;
2037: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2038: 			 {
2039: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2040: 			  {
2041: 			   declared1 = true;
2042: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
2043:              		    b1.put(true);
2044: 			   else
2045: 			   {
2046: 			    String str = varTable[scope][i].value().to_boolean().get();
2047: 			    bool b2;
2048: 			    if (str.getString() == "true")
2049: 			     b2 = true;
2050: 			    else if (str.getString() == "false")
2051: 			     b2 = false;
2052: 			    else
2053: 			     b2 = true;
2054: 
2055: 			    b1.put(b2);
2056: 			   }
2057: 			  }
2058: 			 }
2059: 
2060: 			 if (!declared1)
2061: 			 {
2062: 			  String str = $3.to_string().get();
2063: 			  str += " was not declared.";
2064: 			  yyerror(str.getString().c_str());
2065: 			 }
2066: 
2067: 
2068:    		         PNF_Boolean b3;
2069: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2070: 			 {
2071: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
2072: 			  {
2073: 			   declared2 = true;
2074: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
2075:              		    b3.put(true);
2076: 			   else
2077: 			   {
2078: 			    String str = varTable[scope][i].value().to_boolean().get();
2079: 			    bool b4;
2080: 			    if (str.getString() == "true")
2081: 			     b4 = true;
2082: 			    else if (str.getString() == "false")
2083: 			     b4 = false;
2084: 			    else
2085: 			     b4 = true;
2086: 
2087: 			    b3.put(b4);
2088: 			   }
2089: 			  }
2090: 			 }
2091: 
2092: 			 if (!declared2)
2093: 			 {
2094: 			  String str = $3.to_string().get();
2095: 			  str += " was not declared.";
2096: 			  yyerror(str.getString().c_str());
2097: 			 }
2098: 
2099: 			 bool b5;
2100: 			 String str = b3.get();
2101: 			 if (str.getString() == "true")
2102: 			  b5 = true;
2103: 			 else if (str.getString() == "false")
2104: 			  b5 = false;
2105: 			 else
2106: 			  b5 = true;
2107: 
2108: 			 b1.opor(b5);
2109: 			 $$.put(b1);
2110: 			}
2111: 			| id_expression OPPLUS id_expression	
2112: 			{
2113: 			 switch ($1.getType())
2114: 			 {
2115: 			  case TNUMBER:
2116: 			  {
2117: 			   if ($3.getType() != TNUMBER)
2118: 			   {
2119: 			    PNF_Number n(0);
2120: 			    $$.put(n);
2121: 			   }
2122: 			   double d = $3.to_number().get();
2123: 			   PNF_Number n($1.to_number());
2124: 			   n.add(d);
2125: 			   $$.put(n);
2126: 			  }
2127: 			  break;
2128: 
2129: 		          case TCHARACTER:
2130: 			  {
2131: 			   if ($3.getType() != TCHARACTER)
2132: 			   {
2133: 			    PNF_Number n(0);
2134: 			    $$.put(n);
2135: 			   }
2136: 			   char d = $3.to_character().get();
2137: 			   PNF_Character n($1.to_character());
2138: 			   n.add(d);
2139: 			   $$.put(n);
2140: 			  }
2141: 			  break;
2142: 
2143: 			  case TSTRING:
2144: 			  {
2145: 			   if ($3.getType() != TSTRING)
2146: 			   {
2147: 			    PNF_Number n(0);
2148: 			    $$.put(n);
2149: 			   }
2150: 
2151: 			   String str = $3.to_string().get();
2152: 			   String str2 = "";
2153: 			   for (unsigned long i = 0; i < str.length(); ++i)
2154:  			   {
2155: 			    if (str[i] == '\"')
2156: 			     continue;
2157: 			    str2 += str[i];
2158: 			   }
2159: 
2160: 			   str = $1.to_string().get();
2161: 			   String str3 = "";
2162: 			   for (unsigned long i = 0; i < str.length(); ++i)
2163:  			   {
2164: 			    if (str[i] == '\"')
2165: 			     continue;
2166: 			    str3 += str[i];
2167: 			   }
2168: 
2169: 			   PNF_String s(str3);
2170: 			   s.add(str2);
2171: 
2172: 			   str = s.get();
2173: 			   String str4 = "\"";
2174: 			   for (unsigned long i = 0; i < str.length(); ++i)
2175:  			   {			    
2176: 			    str4 += str[i];
2177: 			   }
2178: 			   str4 += "\"";
2179: 			   s.put(str4);
2180: 
2181: 			   $$.put(s);
2182: 			  }
2183: 			  break;
2184: 
2185: 			  default:
2186: 			   PNF_Number n(0);
2187: 			   $$.put(n);
2188: 			   break;
2189: 			 }
2190: 			}
2191: 			| id_expression OPMINUS id_expression
2192: 			{
2193: 			 switch ($1.getType())
2194: 			 {
2195: 			  case TNUMBER:
2196: 			  {
2197: 			   if ($3.getType() != TNUMBER)
2198: 			   {
2199: 			    PNF_Number n(0);
2200: 			    $$.put(n);
2201: 			   }
2202: 			   double d = $3.to_number().get();
2203: 			   PNF_Number n($1.to_number());
2204: 			   n.sub(d);
2205: 			   $$.put(n);
2206: 			  }
2207: 			  break;
2208: 
2209: 		          case TCHARACTER:
2210: 			  {
2211: 			   if ($3.getType() != TCHARACTER)
2212: 			   {
2213: 			    PNF_Number n(0);
2214: 			    $$.put(n);
2215: 			   }
2216: 			   char d = $3.to_character().get();
2217: 			   PNF_Character n($1.to_character());
2218: 			   n.sub(d);
2219: 			   $$.put(n);
2220: 			  }
2221: 			  break;			
2222: 
2223: 			  default:
2224: 			   PNF_Number n(0);
2225: 			   $$.put(n);
2226: 			   break;
2227: 			 }
2228: 			}
2229: 			| id_expression OPTIMES id_expression
2230: 			{
2231: 			 switch ($1.getType())
2232: 			 {
2233: 			  case TNUMBER:
2234: 			  {
2235: 			   if ($3.getType() != TNUMBER)
2236: 			   {
2237: 			    PNF_Number n(0);
2238: 			    $$.put(n);
2239: 			   }
2240: 			   double d = $3.to_number().get();
2241: 			   PNF_Number n($1.to_number());
2242: 			   n.mul(d);
2243: 			   $$.put(n);
2244: 			  }
2245: 			  break;
2246: 
2247: 		          case TCHARACTER:
2248: 			  {
2249: 			   if ($3.getType() != TCHARACTER)
2250: 			   {
2251: 			    PNF_Number n(0);
2252: 			    $$.put(n);
2253: 			   }
2254: 			   char d = $3.to_character().get();
2255: 			   PNF_Character n($1.to_character());
2256: 			   n.mul(d);
2257: 			   $$.put(n);
2258: 			  }
2259: 			  break;				
2260: 
2261: 			  default:
2262: 			   PNF_Number n(0);
2263: 			   $$.put(n);
2264: 			   break;
2265: 			 }
2266: 			}
2267: 			| id_expression OPDIV id_expression
2268: 			{
2269: 			 switch ($1.getType())
2270: 			 {
2271: 			  case TNUMBER:
2272: 			  {
2273: 			   if ($3.getType() != TNUMBER)
2274: 			   {
2275: 			    PNF_Number n(0);
2276: 			    $$.put(n);
2277: 			   }
2278: 			   double d = $3.to_number().get();
2279: 			   PNF_Number n($1.to_number());
2280: 			   n.div(d);
2281: 			   $$.put(n);
2282: 			  }
2283: 			  break;
2284: 
2285: 		          case TCHARACTER:
2286: 			  {
2287: 			   if ($3.getType() != TCHARACTER)
2288: 			   {
2289: 			    PNF_Number n(0);
2290: 			    $$.put(n);
2291: 			   }
2292: 			   char d = $3.to_character().get();
2293: 			   PNF_Character n($1.to_character());
2294: 			   n.div(d);
2295: 			   $$.put(n);
2296: 			  }
2297: 			  break;			
2298: 
2299: 			  default:
2300: 			   PNF_Number n(0);
2301: 			   $$.put(n);
2302: 			   break;
2303: 			 }
2304: 			}
2305: 			| id_expression OPMODULUS id_expression
2306: 			{
2307: 			 switch ($1.getType())
2308: 			 {
2309: 			  case TNUMBER:
2310: 			  {
2311: 			   if ($3.getType() != TNUMBER)
2312: 			   {
2313: 			    PNF_Number n(0);
2314: 			    $$.put(n);
2315: 			   }
2316: 			   double d = $3.to_number().get();
2317: 			   PNF_Number n($1.to_number());
2318: 			   n.mod(d);
2319: 			   $$.put(n);
2320: 			  }
2321: 			  break;
2322: 
2323: 		          case TCHARACTER:
2324: 			  {
2325: 			   if ($3.getType() != TCHARACTER)
2326: 			   {
2327: 			    PNF_Number n(0);
2328: 			    $$.put(n);
2329: 			   }
2330: 			   char d = $3.to_character().get();
2331: 			   PNF_Character n($1.to_character());
2332: 			   n.mod(d);
2333: 			   $$.put(n);
2334: 			  }
2335: 			  break;	
2336: 
2337: 			  default:
2338: 			   PNF_Number n(0);
2339: 			   $$.put(n);
2340: 			   break;
2341: 			 }
2342: 			}
2343: 			| OPMINUS id_expression %prec NEG
2344: 			{
2345: 			 if ($2.getType() != TNUMBER)
2346: 			 {
2347: 			  PNF_Number n(0);
2348:                           $$.put(n);
2349: 			 }
2350: 			 double d = $2.to_number().get();
2351: 			 d = -d;
2352: 			 PNF_Number n(d);
2353: 			 PNF_Variable v(n);
2354: 			 $$ = v;
2355: 			}
2356: 			| id_expression OPPOWER id_expression
2357: 			{
2358: 			 switch ($1.getType())
2359: 			 {
2360: 			  case TNUMBER:
2361: 			  {
2362: 			   if ($3.getType() != TNUMBER)
2363: 			   {
2364: 			    PNF_Number n(0);
2365: 			    $$.put(n);
2366: 			   }
2367: 			   double d = $3.to_number().get();
2368: 			   PNF_Number n($1.to_number());
2369: 			   n.pow(d);
2370: 			   $$.put(n);
2371: 			  }
2372: 			  break;
2373: 
2374: 		          case TCHARACTER:
2375: 			  {
2376: 			   if ($3.getType() != TCHARACTER)
2377: 			   {
2378: 			    PNF_Number n(0);
2379: 			    $$.put(n);
2380: 			   }
2381: 			   char d = $3.to_character().get();
2382: 			   PNF_Character n($1.to_character());
2383: 			   n.pow(d);
2384: 			   $$.put(n);
2385: 			  }
2386: 			  break;	
2387: 
2388: 			  default:
2389: 			   PNF_Number n(0);
2390: 			   $$.put(n);
2391: 			   break;
2392: 			 }
2393: 			}
2394: 			| id_expression OPROOT id_expression
2395: 			{
2396: 			 switch ($1.getType())
2397: 			 {
2398: 			  case TNUMBER:
2399: 			  {
2400: 			   if ($3.getType() != TNUMBER)
2401: 			   {
2402: 			    PNF_Number n(0);
2403: 			    $$.put(n);
2404: 			   }
2405: 			   double d = $1.to_number().get();
2406: 			   PNF_Number n($3.to_number());
2407: 			   n.root(d);
2408: 			   $$.put(n);
2409: 			  }
2410: 			  break;
2411: 
2412: 		          case TCHARACTER:
2413: 			  {
2414: 			   if ($3.getType() != TCHARACTER)
2415: 			   {
2416: 			    PNF_Number n(0);
2417: 			    $$.put(n);
2418: 			   }
2419: 			   char d = $1.to_character().get();
2420: 			   PNF_Character n($3.to_character());
2421: 			   n.root(d);
2422: 			   $$.put(n);
2423: 			  }
2424: 			  break;	
2425: 
2426: 			  default:
2427: 			   PNF_Number n(0);
2428: 			   $$.put(n);
2429: 			   break;
2430: 			 }
2431: 			}
2432: 			| OPINC id_expression
2433: 			{
2434: 			 switch ($2.getType())
2435: 			 {
2436: 			  case TNUMBER:
2437: 			  {
2438: 			   PNF_Number n($2.to_number().get());
2439: 			   n.inc(1);
2440: 			   $$.put(n);
2441: 			  }
2442: 			  break;
2443: 
2444: 			  case TCHARACTER:
2445: 			  {
2446: 			   PNF_Character c($2.to_character().get());
2447: 			   c.inc(1);
2448: 			   $$.put(c);
2449: 			  }
2450: 	                  break;
2451: 			  
2452: 			  default:
2453: 			  {
2454: 			   PNF_Number n(0);
2455:                            $$.put(n);
2456: 			  }
2457: 			  break;
2458: 			 }
2459: 			}
2460: 			| id_expression OPINC
2461: 			{
2462: 			 switch ($2.getType())
2463: 			 {
2464: 			  case TNUMBER:
2465: 			  {
2466: 			   PNF_Number n($2.to_number().get());
2467: 			   $$.put(n);
2468: 			   n.inc(1);
2469: 			  }
2470: 			  break;
2471: 
2472: 			  case TCHARACTER:
2473: 			  {
2474: 			   PNF_Character c($2.to_character().get());
2475: 			   $$.put(c);
2476: 			   c.inc(1);
2477: 			  }
2478: 	                  break;
2479: 			  
2480: 			  default:
2481: 			  {
2482: 			   PNF_Number n(0);
2483:                            $$.put(n);
2484: 			  }
2485: 			  break;
2486: 			 }
2487: 			}
2488: 			| OPDEC id_expression
2489: 			{
2490: 			 switch ($2.getType())
2491: 			 {
2492: 			  case TNUMBER:
2493: 			  {
2494: 			   PNF_Number n($2.to_number().get());
2495: 			   n.dec(1);
2496: 			   $$.put(n);
2497: 			  }
2498: 			  break;
2499: 
2500: 			  case TCHARACTER:
2501: 			  {
2502: 			   PNF_Character c($2.to_character().get());
2503: 			   c.dec(1);
2504: 			   $$.put(c);
2505: 			  }
2506: 	                  break;
2507: 			  
2508: 			  default:
2509: 			  {
2510: 			   PNF_Number n(0);
2511:                            $$.put(n);
2512: 			  }
2513: 			  break;
2514: 			 }
2515: 			}
2516: 			| id_expression OPDEC
2517: 			{
2518: 			 switch ($2.getType())
2519: 			 {
2520: 			  case TNUMBER:
2521: 			  {
2522: 			   PNF_Number n($2.to_number().get());
2523: 			   $$.put(n);
2524: 			   n.dec(1);
2525: 			  }
2526: 			  break;
2527: 
2528: 			  case TCHARACTER:
2529: 			  {
2530: 			   PNF_Character c($2.to_character().get());
2531: 			   $$.put(c);
2532: 			   c.dec(1);
2533: 			  }
2534: 	                  break;
2535: 			  
2536: 			  default:
2537: 			  {
2538: 			   PNF_Number n(0);
2539:                            $$.put(n);
2540: 			  }
2541: 			  break;
2542: 			 }
2543: 			}
2544: 			| LEFTP id_expression RIGHTP
2545: 			{
2546: 			 $$ = $2;
2547: 			}
2548: 			;
2549: 
2550: relational_expression:	number_expression OPEQU number_expression
2551: 			{
2552: 			 double d1 = $1.to_number().get();
2553: 			 double d2 = $3.to_number().get();
2554: 			 bool b = d1 == d2;
2555: 			 PNF_Boolean b2(b);
2556: 			 $$.put(b2);
2557: 			}
2558: 			| number_expression OPNEQU number_expression
2559: 			{
2560: 			 double d1 = $1.to_number().get();
2561: 			 double d2 = $3.to_number().get();
2562: 			 bool b = d1 != d2;
2563: 			 PNF_Boolean b2(b);
2564: 			 $$.put(b2);
2565: 			}
2566: 			| number_expression OPLSS number_expression
2567: 			{
2568: 			 double d1 = $1.to_number().get();
2569: 			 double d2 = $3.to_number().get();
2570: 			 bool b = d1 < d2;
2571: 			 PNF_Boolean b2(b);
2572: 			 $$.put(b2);
2573: 			}
2574: 			| number_expression OPGTR number_expression
2575: 			{
2576: 			 double d1 = $1.to_number().get();
2577: 			 double d2 = $3.to_number().get();
2578: 			 bool b = d1 > d2;
2579: 			 PNF_Boolean b2(b);
2580: 			 $$.put(b2);
2581: 			}
2582: 			| number_expression OPLEQU number_expression
2583: 			{
2584: 			 double d1 = $1.to_number().get();
2585: 			 double d2 = $3.to_number().get();
2586: 			 bool b = d1 <= d2;
2587: 			 PNF_Boolean b2(b);
2588: 			 $$.put(b2);
2589: 			}
2590: 			| number_expression OPGEQU number_expression
2591: 			{
2592: 			 double d1 = $1.to_number().get();
2593: 			 double d2 = $3.to_number().get();
2594: 			 bool b = d1 >= d2;
2595: 			 PNF_Boolean b2(b);
2596: 			 $$.put(b2);
2597: 			}
2598: 			;
2599: 
2600: mixed_expression:	
2601: 			LEFTP mixed_expression RIGHTP 
2602: 			{
2603: 			 $$ = $2;
2604: 			}
2605: 			| ID OPAND boolean_expression
2606: 			{
2607: 			 bool declared = false;
2608: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2609: 			 {
2610: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2611: 			  {
2612: 			   declared = true;
2613: 			   PNF_Boolean b1;
2614: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
2615:              		    b1.put(true);
2616: 			   else
2617: 			   {
2618: 			    bool b2;
2619: 			    String str = varTable[scope][i].value().to_boolean().get();
2620: 			    if (str.getString() == "true")
2621: 			     b2 = true;
2622: 			    else if (str.getString() == "false")
2623: 			     b2 = false;
2624: 			    else
2625: 			     b2 = true;
2626: 
2627: 			    b1.put(b2);
2628: 			   }
2629: 
2630: 			   bool b2;
2631: 			   String str = $3.to_boolean().get();
2632: 			   if (str.getString() == "true")
2633: 			    b2 = true;
2634: 			   else if (str.getString() == "false")
2635: 			    b2 = false;
2636: 			   else
2637: 			    b2 = true;
2638: 
2639: 			   b1.opand(b2);
2640: 
2641: 			   $$.put(b1);
2642: 			  }
2643: 			 }
2644: 
2645: 			 if (!declared)
2646: 			 {
2647: 			  String str = $3.to_string().get();
2648: 			  str += " was not declared.";
2649: 			  yyerror(str.getString().c_str());
2650: 			 }
2651: 			}
2652: 			| boolean_expression OPAND ID
2653: 			{
2654: 			 bool declared = false;
2655: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2656: 			 {
2657: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
2658: 			  {
2659: 			   declared = true;
2660: 			   PNF_Boolean b1;
2661: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
2662:              		    b1.put(true);
2663: 			   else
2664: 			   {
2665: 			    bool b2;
2666: 			    String str = varTable[scope][i].value().to_boolean().get();
2667: 			    if (str.getString() == "true")
2668: 			     b2 = true;
2669: 			    else if (str.getString() == "false")
2670: 			     b2 = false;
2671: 			    else
2672: 			     b2 = true;
2673: 
2674: 			    b1.put(b2);
2675: 			   }
2676: 
2677: 			   bool b2;
2678: 			   String str = $1.to_boolean().get();
2679: 			   if (str.getString() == "true")
2680: 			    b2 = true;
2681: 			   else if (str.getString() == "false")
2682: 			    b2 = false;
2683: 			   else
2684: 			    b2 = true;
2685: 
2686: 			   b1.opand(b2);
2687: 
2688: 			   $$.put(b1);
2689: 			  }
2690: 			 }
2691: 
2692: 			 if (!declared)
2693: 			 {
2694: 			  String str = $3.to_string().get();
2695: 			  str += " was not declared.";
2696: 			  yyerror(str.getString().c_str());
2697: 			 }
2698: 			}
2699: 			| ID OPOR boolean_expression
2700: 			{
2701: 			 bool declared = false;
2702: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2703: 			 {
2704: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2705: 			  {
2706: 			   declared = true;
2707: 			   PNF_Boolean b1;
2708: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
2709:              		    b1.put(true);
2710: 			   else
2711: 			   {
2712: 			    bool b2;
2713: 			    String str = varTable[scope][i].value().to_boolean().get();
2714: 			    if (str.getString() == "true")
2715:                              b2 = true;
2716: 			    else if (str.getString() == "false")
2717: 			     b2 = false;
2718: 			    else
2719: 			     b2 = true;
2720: 
2721: 			    b1.put(b2);
2722: 			   }
2723: 
2724: 			   bool b2;
2725: 			   String str = $3.to_boolean().get();
2726: 			   if (str.getString() == "true")
2727: 			    b2 = true;
2728: 			   else if (str.getString() == "false")
2729: 			    b2 = false;
2730: 			   else
2731: 			    b2 = true;
2732: 
2733: 			   b1.opor(b2);
2734: 
2735: 			   $$.put(b1);
2736: 			  }
2737: 			 }
2738: 
2739: 			 if (!declared)
2740: 			 {
2741: 			  String str = $3.to_string().get();
2742: 			  str += " was not declared.";
2743: 			  yyerror(str.getString().c_str());
2744: 			 }
2745: 			}
2746: 			| boolean_expression OPOR ID
2747: 			{
2748: 			 bool declared = false;
2749: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2750: 			 {
2751: 			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
2752: 			  {
2753: 			   declared = true;
2754: 			   PNF_Boolean b1;
2755: 			   if (varTable[scope][i].value().getType() != TBOOLEAN)
2756:              		    b1.put(true);
2757: 			   else
2758: 			   {
2759: 			    bool b2;
2760: 			    String str = varTable[scope][i].value().to_boolean().get();
2761: 			    if (str.getString() == "true")
2762: 			     b2 = true;
2763: 			    else if (str.getString() == "false")
2764: 			     b2 = false;
2765: 			    else
2766: 			     b2 = true;
2767: 
2768: 			    b1.put(b2);
2769: 			   }
2770: 
2771: 			   bool b2;
2772: 			   String str = $1.to_boolean().get();
2773: 			   if (str.getString() == "true")
2774: 			    b2 = true;
2775: 			   else if (str.getString() == "false")
2776: 			    b2 = false;
2777: 			   else
2778: 			    b2 = true;
2779: 
2780: 			   b1.opor(b2);
2781: 
2782: 			   $$.put(b1);
2783: 			  }
2784: 			 }
2785: 
2786: 			 if (!declared)
2787: 			 {
2788: 			  String str = $3.to_string().get();
2789: 			  str += " was not declared.";
2790: 			  yyerror(str.getString().c_str());
2791: 			 }
2792: 			}
2793: 			| ID OPPLUS number_expression
2794: 			{
2795: 			 bool declared = false;
2796: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2797: 			 {
2798:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2799: 			  {
2800: 			   declared = true;
2801: 			   	
2802: 			   switch (varTable[scope][i].value().getType())
2803: 			   {
2804:   			    case TNUMBER:
2805: 			    {
2806: 			     if ($3.getType() != TNUMBER)
2807: 			     {
2808: 			      PNF_Number n(0);
2809: 			      $$.put(n);
2810: 			     }
2811: 			     double d = $3.to_number().get();
2812: 			     PNF_Number n(varTable[scope][i].value().to_number());
2813: 			     n.add(d);
2814: 			     $$.put(n);
2815: 			    }
2816: 			    break;
2817: 
2818:     		            default:
2819: 			     PNF_Number n(0);
2820: 			     $$.put(n);
2821: 			     break;
2822: 			   }
2823: 			  }
2824: 			 }
2825: 
2826: 			 if (!declared)
2827: 			 {
2828: 			  String str = $3.to_string().get();
2829: 			  str += " was not declared.";
2830: 			  yyerror(str.getString().c_str());
2831: 			 }
2832: 			}
2833: 			| ID OPMINUS number_expression
2834: 			{
2835: 			 bool declared = false;
2836: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2837: 			 {
2838:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2839: 			  {
2840: 			   declared = true;
2841: 			   	
2842: 			   switch (varTable[scope][i].value().getType())
2843: 			   {
2844:   			    case TNUMBER:
2845: 			    {
2846: 			     if ($3.getType() != TNUMBER)
2847: 			     {
2848: 			      PNF_Number n(0);
2849: 			      $$.put(n);
2850: 			     }
2851: 			     double d = $3.to_number().get();
2852: 			     PNF_Number n(varTable[scope][i].value().to_number());
2853: 			     n.sub(d);
2854: 			     $$.put(n);
2855: 			    }
2856: 			    break;
2857: 
2858:     		            default:
2859: 			     PNF_Number n(0);
2860: 			     $$.put(n);
2861: 			     break;
2862: 			   }
2863: 			  }
2864: 			 }
2865: 
2866: 			 if (!declared)
2867: 			 {
2868: 			  String str = $3.to_string().get();
2869: 			  str += " was not declared.";
2870: 			  yyerror(str.getString().c_str());
2871: 			 }
2872: 			}
2873: 			| ID OPTIMES number_expression
2874: 			{
2875: 			 bool declared = false;
2876: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2877: 			 {
2878:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2879: 			  {
2880: 			   declared = true;
2881: 			   	
2882: 			   switch (varTable[scope][i].value().getType())
2883: 			   {
2884:   			    case TNUMBER:
2885: 			    {
2886: 			     if ($3.getType() != TNUMBER)
2887: 			     {
2888: 			      PNF_Number n(0);
2889: 			      $$.put(n);
2890: 			     }
2891: 			     double d = $3.to_number().get();
2892: 			     PNF_Number n(varTable[scope][i].value().to_number());
2893: 			     n.mul(d);
2894: 			     $$.put(n);
2895: 			    }
2896: 			    break;
2897: 
2898:     		            default:
2899: 			     PNF_Number n(0);
2900: 			     $$.put(n);
2901: 			     break;
2902: 			   }
2903: 			  }
2904: 			 }
2905: 
2906: 			 if (!declared)
2907: 			 {
2908: 			  String str = $3.to_string().get();
2909: 			  str += " was not declared.";
2910: 			  yyerror(str.getString().c_str());
2911: 			 }
2912:                 	}
2913: 			| ID OPDIV number_expression
2914: 			{
2915: 			 bool declared = false;
2916: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2917: 			 {
2918:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2919: 			  {
2920: 			   declared = true;
2921: 			   	
2922: 			   switch (varTable[scope][i].value().getType())
2923: 			   {
2924:   			    case TNUMBER:
2925: 			    {
2926: 			     if ($3.getType() != TNUMBER)
2927: 			     {
2928: 			      PNF_Number n(0);
2929: 			      $$.put(n);
2930: 			     }
2931: 			     double d = $3.to_number().get();
2932: 			     PNF_Number n(varTable[scope][i].value().to_number());
2933: 			     n.div(d);
2934: 			     $$.put(n);
2935: 			    }
2936: 			    break;
2937: 
2938:     		            default:
2939: 			     PNF_Number n(0);
2940: 			     $$.put(n);
2941: 			     break;
2942: 			   }
2943: 			  }
2944: 			 }
2945: 
2946: 			 if (!declared)
2947: 			 {
2948: 			  String str = $3.to_string().get();
2949: 			  str += " was not declared.";
2950: 			  yyerror(str.getString().c_str());
2951: 			 }
2952:                 	}
2953: 			| ID OPPOWER number_expression	
2954: 			{
2955: 			 bool declared = false;
2956: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2957: 			 {
2958:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2959: 			  {
2960: 			   declared = true;
2961: 			   	
2962: 			   switch (varTable[scope][i].value().getType())
2963: 			   {
2964:   			    case TNUMBER:
2965: 			    {
2966: 			     if ($3.getType() != TNUMBER)
2967: 			     {
2968: 			      PNF_Number n(0);
2969: 			      $$.put(n);
2970: 			     }
2971: 			     double d = $3.to_number().get();
2972: 			     PNF_Number n(varTable[scope][i].value().to_number());
2973: 			     n.pow(d);
2974: 			     $$.put(n);
2975: 			    }
2976: 			    break;
2977: 
2978:     		            default:
2979: 			     PNF_Number n(0);
2980: 			     $$.put(n);
2981: 			     break;
2982: 			   }
2983: 			  }
2984: 			 }
2985: 
2986: 			 if (!declared)
2987: 			 {
2988: 			  String str = $3.to_string().get();
2989: 			  str += " was not declared.";
2990: 			  yyerror(str.getString().c_str());
2991: 			 }
2992:                 	}
2993: 			| ID OPROOT number_expression
2994: 			{
2995: 			 bool declared = false;
2996: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
2997: 			 {
2998:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
2999: 			  {
3000: 			   declared = true;
3001: 			   	
3002: 			   switch (varTable[scope][i].value().getType())
3003: 			   {
3004:   			    case TNUMBER:
3005: 			    {
3006: 			     if ($3.getType() != TNUMBER)
3007: 			     {
3008: 			      PNF_Number n(0);
3009: 			      $$.put(n);
3010: 			     }
3011: 			     double d = varTable[scope][i].value().to_number().get();
3012: 			     PNF_Number n($3.to_number());
3013: 			     n.root(d);
3014: 			     $$.put(n);
3015: 			    }
3016: 			    break;
3017: 
3018:     		            default:
3019: 			     PNF_Number n(0);
3020: 			     $$.put(n);
3021: 			     break;
3022: 			   }
3023: 			  }
3024: 			 }
3025: 
3026: 			 if (!declared)
3027: 			 {
3028: 			  String str = $3.to_string().get();
3029: 			  str += " was not declared.";
3030: 			  yyerror(str.getString().c_str());
3031: 			 }
3032:                 	}
3033: 			| number_expression OPPLUS ID
3034: 			{
3035: 			 bool declared = false;
3036: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3037: 			 {
3038:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3039: 			  {
3040: 			   declared = true;
3041: 			   	
3042: 			   switch (varTable[scope][i].value().getType())
3043: 			   {
3044:   			    case TNUMBER:
3045: 			    {
3046: 			     if ($1.getType() != TNUMBER)
3047: 			     {
3048: 			      PNF_Number n(0);
3049: 			      $$.put(n);
3050: 			     }
3051: 			     double d = $1.to_number().get();
3052: 			     PNF_Number n(varTable[scope][i].value().to_number());
3053: 			     n.add(d);
3054: 			     $$.put(n);
3055: 			    }
3056: 			    break;
3057: 
3058:     		            default:
3059: 			     PNF_Number n(0);
3060: 			     $$.put(n);
3061: 			     break;
3062: 			   }
3063: 			  }
3064: 			 }
3065: 
3066: 			 if (!declared)
3067: 			 {
3068: 			  String str = $3.to_string().get();
3069: 			  str += " was not declared.";
3070: 			  yyerror(str.getString().c_str());
3071: 			 }
3072: 			}
3073: 			| number_expression OPMINUS ID
3074: 			{
3075: 			 bool declared = false;
3076: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3077: 			 {
3078:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3079: 			  {
3080: 			   declared = true;
3081: 			   	
3082: 			   switch (varTable[scope][i].value().getType())
3083: 			   {
3084:   			    case TNUMBER:
3085: 			    {
3086: 			     if ($1.getType() != TNUMBER)
3087: 			     {
3088: 			      PNF_Number n(0);
3089: 			      $$.put(n);
3090: 			     }
3091: 			     double d = $1.to_number().get();
3092: 			     PNF_Number n(varTable[scope][i].value().to_number());
3093: 			     n.sub(d);
3094: 			     $$.put(n);
3095: 			    }
3096: 			    break;
3097: 
3098:     		            default:
3099: 			     PNF_Number n(0);
3100: 			     $$.put(n);
3101: 			     break;
3102: 			   }
3103: 			  }
3104: 			 }
3105: 
3106: 			 if (!declared)
3107: 			 {
3108: 			  String str = $3.to_string().get();
3109: 			  str += " was not declared.";
3110: 			  yyerror(str.getString().c_str());
3111: 			 }
3112:                 	}
3113: 			| number_expression OPTIMES ID
3114: 			{
3115: 			 bool declared = false;
3116: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3117: 			 {
3118:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3119: 			  {
3120: 			   declared = true;
3121: 			   	
3122: 			   switch (varTable[scope][i].value().getType())
3123: 			   {
3124:   			    case TNUMBER:
3125: 			    {
3126: 			     if ($1.getType() != TNUMBER)
3127: 			     {
3128: 			      PNF_Number n(0);
3129: 			      $$.put(n);
3130: 			     }
3131: 			     double d = $1.to_number().get();
3132: 			     PNF_Number n(varTable[scope][i].value().to_number());
3133: 			     n.mul(d);
3134: 			     $$.put(n);
3135: 			    }
3136: 			    break;
3137: 
3138:     		            default:
3139: 			     PNF_Number n(0);
3140: 			     $$.put(n);
3141: 			     break;
3142: 			   }
3143: 			  }
3144: 			 }
3145: 
3146: 			 if (!declared)
3147: 			 {
3148: 			  String str = $3.to_string().get();
3149: 			  str += " was not declared.";
3150: 			  yyerror(str.getString().c_str());
3151: 			 }
3152:                 	}
3153: 			| number_expression OPDIV ID
3154: 			{
3155: 			 bool declared = false;
3156: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3157: 			 {
3158:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3159: 			  {
3160: 			   declared = true;
3161: 			   	
3162: 			   switch (varTable[scope][i].value().getType())
3163: 			   {
3164:   			    case TNUMBER:
3165: 			    {
3166: 			     if ($1.getType() != TNUMBER)
3167: 			     {
3168: 			      PNF_Number n(0);
3169: 			      $$.put(n);
3170: 			     }
3171: 			     double d = $1.to_number().get();
3172: 			     PNF_Number n(varTable[scope][i].value().to_number());
3173: 			     n.div(d);
3174: 			     $$.put(n);
3175: 			    }
3176: 			    break;
3177: 
3178:     		            default:
3179: 			     PNF_Number n(0);
3180: 			     $$.put(n);
3181: 			     break;
3182: 			   }
3183: 			  }
3184: 			 }
3185: 
3186: 			 if (!declared)
3187: 			 {
3188: 			  String str = $3.to_string().get();
3189: 			  str += " was not declared.";
3190: 			  yyerror(str.getString().c_str());
3191: 			 }
3192:                 	}
3193: 			| number_expression OPPOWER ID
3194: 			{
3195: 			 bool declared = false;
3196: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3197: 			 {
3198:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3199: 			  {
3200: 			   declared = true;
3201: 			   	
3202: 			   switch (varTable[scope][i].value().getType())
3203: 			   {
3204:   			    case TNUMBER:
3205: 			    {
3206: 			     if ($1.getType() != TNUMBER)
3207: 			     {
3208: 			      PNF_Number n(0);
3209: 			      $$.put(n);
3210: 			     }
3211: 			     double d = $1.to_number().get();
3212: 			     PNF_Number n(varTable[scope][i].value().to_number());
3213: 			     n.pow(d);
3214: 			     $$.put(n);
3215: 			    }
3216: 			    break;
3217: 
3218:     		            default:
3219: 			     PNF_Number n(0);
3220: 			     $$.put(n);
3221: 			     break;
3222: 			   }
3223: 			  }
3224: 			 }
3225: 
3226: 			 if (!declared)
3227: 			 {
3228: 			  String str = $3.to_string().get();
3229: 			  str += " was not declared.";
3230: 			  yyerror(str.getString().c_str());
3231: 			 }
3232:                 	}
3233: 			| number_expression OPROOT ID
3234: 			{
3235: 			 bool declared = false;
3236: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3237: 			 {
3238:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3239: 			  {
3240: 			   declared = true;
3241: 			   	
3242: 			   switch (varTable[scope][i].value().getType())
3243: 			   {
3244:   			    case TNUMBER:
3245: 			    {
3246: 			     if ($1.getType() != TNUMBER)
3247: 			     {
3248: 			      PNF_Number n(0);
3249: 			      $$.put(n);
3250: 			     }
3251: 			     double d = varTable[scope][i].value().to_number().get();
3252: 			     PNF_Number n($1.to_number());
3253: 			     n.root(d);
3254: 			     $$.put(n);
3255: 			    }
3256: 			    break;
3257: 
3258:     		            default:
3259: 			     PNF_Number n(0);
3260: 			     $$.put(n);
3261: 			     break;
3262: 			   }
3263: 			  }
3264: 			 }
3265: 
3266: 			 if (!declared)
3267: 			 {
3268: 			  String str = $3.to_string().get();
3269: 			  str += " was not declared.";
3270: 			  yyerror(str.getString().c_str());
3271: 			 }
3272:                 	}
3273: 			| ID OPPLUS character_expression
3274: 			{
3275: 			 bool declared = false;
3276: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3277: 			 {
3278:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
3279: 			  {
3280: 			   declared = true;
3281: 			   	
3282: 			   switch (varTable[scope][i].value().getType())
3283: 			   {
3284:   			    case TCHARACTER:
3285: 			    {
3286: 			     if ($3.getType() != TCHARACTER)
3287: 			     {
3288: 			      PNF_Number n(0);
3289: 			      $$.put(n);
3290: 			     }
3291: 			     char d = $3.to_character().get();
3292: 			     PNF_Character n(varTable[scope][i].value().to_character());
3293: 			     n.add(d);
3294: 			     $$.put(n);
3295: 			    }
3296: 			    break;
3297: 
3298:     		            default:
3299: 			     PNF_Number n(0);
3300: 			     $$.put(n);
3301: 			     break;
3302: 			   }
3303: 			  }
3304: 			 }
3305: 
3306: 			 if (!declared)
3307: 			 {
3308: 			  String str = $3.to_string().get();
3309: 			  str += " was not declared.";
3310: 			  yyerror(str.getString().c_str());
3311: 			 }
3312:                 	}
3313: 			| ID OPMINUS character_expression
3314: 			{
3315: 			 bool declared = false;
3316: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3317: 			 {
3318:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
3319: 			  {
3320: 			   declared = true;
3321: 			   	
3322: 			   switch (varTable[scope][i].value().getType())
3323: 			   {
3324:   			    case TCHARACTER:
3325: 			    {
3326: 			     if ($3.getType() != TCHARACTER)
3327: 			     {
3328: 			      PNF_Number n(0);
3329: 			      $$.put(n);
3330: 			     }
3331: 			     char d = $3.to_character().get();
3332: 			     PNF_Character n(varTable[scope][i].value().to_character());
3333: 			     n.sub(d);
3334: 			     $$.put(n);
3335: 			    }
3336: 			    break;
3337: 
3338:     		            default:
3339: 			     PNF_Number n(0);
3340: 			     $$.put(n);
3341: 			     break;
3342: 			   }
3343: 			  }
3344: 			 }
3345: 
3346: 			 if (!declared)
3347: 			 {
3348: 			  String str = $3.to_string().get();
3349: 			  str += " was not declared.";
3350: 			  yyerror(str.getString().c_str());
3351: 			 }
3352:                 	}
3353: 			| ID OPTIMES character_expression
3354: 			{
3355: 			 bool declared = false;
3356: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3357: 			 {
3358:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
3359: 			  {
3360: 			   declared = true;
3361: 			   	
3362: 			   switch (varTable[scope][i].value().getType())
3363: 			   {
3364:   			    case TCHARACTER:
3365: 			    {
3366: 			     if ($3.getType() != TCHARACTER)
3367: 			     {
3368: 			      PNF_Number n(0);
3369: 			      $$.put(n);
3370: 			     }
3371: 			     char d = $3.to_character().get();
3372: 			     PNF_Character n(varTable[scope][i].value().to_character());
3373: 			     n.mul(d);
3374: 			     $$.put(n);
3375: 			    }
3376: 			    break;
3377: 
3378:     		            default:
3379: 			     PNF_Number n(0);
3380: 			     $$.put(n);
3381: 			     break;
3382: 			   }
3383: 			  }
3384: 			 }
3385: 
3386: 			 if (!declared)
3387: 			 {
3388: 			  String str = $3.to_string().get();
3389: 			  str += " was not declared.";
3390: 			  yyerror(str.getString().c_str());
3391: 			 }
3392:                 	}
3393: 			| ID OPDIV character_expression
3394: 			{
3395: 			 bool declared = false;
3396: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3397: 			 {
3398:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
3399: 			  {
3400: 			   declared = true;
3401: 			   	
3402: 			   switch (varTable[scope][i].value().getType())
3403: 			   {
3404:   			    case TCHARACTER:
3405: 			    {
3406: 			     if ($3.getType() != TCHARACTER)
3407: 			     {
3408: 			      PNF_Number n(0);
3409: 			      $$.put(n);
3410: 			     }
3411: 			     char d = $3.to_character().get();
3412: 			     PNF_Character n(varTable[scope][i].value().to_character());
3413: 			     n.div(d);
3414: 			     $$.put(n);
3415: 			    }
3416: 			    break;
3417: 
3418:     		            default:
3419: 			     PNF_Number n(0);
3420: 			     $$.put(n);
3421: 			     break;
3422: 			   }
3423: 			  }
3424: 			 }
3425: 
3426: 			 if (!declared)
3427: 			 {
3428: 			  String str = $3.to_string().get();
3429: 			  str += " was not declared.";
3430: 			  yyerror(str.getString().c_str());
3431: 			 }
3432:                 	}
3433: 			| ID OPPOWER character_expression	
3434: 			{
3435: 			 bool declared = false;
3436: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3437: 			 {
3438:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
3439: 			  {
3440: 			   declared = true;
3441: 			   	
3442: 			   switch (varTable[scope][i].value().getType())
3443: 			   {
3444:   			    case TCHARACTER:
3445: 			    {
3446: 			     if ($3.getType() != TCHARACTER)
3447: 			     {
3448: 			      PNF_Number n(0);
3449: 			      $$.put(n);
3450: 			     }
3451: 			     char d = $3.to_character().get();
3452: 			     PNF_Character n(varTable[scope][i].value().to_character());
3453: 			     n.pow(d);
3454: 			     $$.put(n);
3455: 			    }
3456: 			    break;
3457: 
3458:     		            default:
3459: 			     PNF_Number n(0);
3460: 			     $$.put(n);
3461: 			     break;
3462: 			   }
3463: 			  }
3464: 			 }
3465: 
3466: 			 if (!declared)
3467: 			 {
3468: 			  String str = $3.to_string().get();
3469: 			  str += " was not declared.";
3470: 			  yyerror(str.getString().c_str());
3471: 			 }
3472:                 	}
3473: 			| ID OPROOT character_expression
3474: 			{
3475: 			 bool declared = false;
3476: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3477: 			 {
3478:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
3479: 			  {
3480: 			   declared = true;
3481: 			   	
3482: 			   switch (varTable[scope][i].value().getType())
3483: 			   {
3484:   			    case TCHARACTER:
3485: 			    {
3486: 			     if ($3.getType() != TCHARACTER)
3487: 			     {
3488: 			      PNF_Number n(0);
3489: 			      $$.put(n);
3490: 			     }
3491: 			     char d = varTable[scope][i].value().to_character().get();
3492: 			     PNF_Character n($3.to_character());
3493: 			     n.root(d);
3494: 			     $$.put(n);
3495: 			    }
3496: 			    break;
3497: 
3498:     		            default:
3499: 			     PNF_Number n(0);
3500: 			     $$.put(n);
3501: 			     break;
3502: 			   }
3503: 			  }
3504: 			 }
3505: 
3506: 			 if (!declared)
3507: 			 {
3508: 			  String str = $3.to_string().get();
3509: 			  str += " was not declared.";
3510: 			  yyerror(str.getString().c_str());
3511: 			 }
3512:                 	}
3513: 			| character_expression OPPLUS ID
3514: 			{
3515: 			 bool declared = false;
3516: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3517: 			 {
3518:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3519: 			  {
3520: 			   declared = true;
3521: 			   	
3522: 			   switch (varTable[scope][i].value().getType())
3523: 			   {
3524:   			    case TCHARACTER:
3525: 			    {
3526: 			     if ($1.getType() != TCHARACTER)
3527: 			     {
3528: 			      PNF_Number n(0);
3529: 			      $$.put(n);
3530: 			     }
3531: 			     char d = $1.to_character().get();
3532: 			     PNF_Character n(varTable[scope][i].value().to_character());
3533: 			     n.add(d);
3534: 			     $$.put(n);
3535: 			    }
3536: 			    break;
3537: 
3538:     		            default:
3539: 			     PNF_Number n(0);
3540: 			     $$.put(n);
3541: 			     break;
3542: 			   }
3543: 			  }
3544: 			 }
3545: 
3546: 			 if (!declared)
3547: 			 {
3548: 			  String str = $3.to_string().get();
3549: 			  str += " was not declared.";
3550: 			  yyerror(str.getString().c_str());
3551: 			 }
3552:                 	}
3553: 			| character_expression OPMINUS ID
3554: 			{
3555: 			 bool declared = false;
3556: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3557: 			 {
3558:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3559: 			  {
3560: 			   declared = true;
3561: 			   	
3562: 			   switch (varTable[scope][i].value().getType())
3563: 			   {
3564:   			    case TCHARACTER:
3565: 			    {
3566: 			     if ($1.getType() != TCHARACTER)
3567: 			     {
3568: 			      PNF_Number n(0);
3569: 			      $$.put(n);
3570: 			     }
3571: 			     char d = $1.to_character().get();
3572: 			     PNF_Character n(varTable[scope][i].value().to_character());
3573: 			     n.sub(d);
3574: 			     $$.put(n);
3575: 			    }
3576: 			    break;
3577: 
3578:     		            default:
3579: 			     PNF_Number n(0);
3580: 			     $$.put(n);
3581: 			     break;
3582: 			   }
3583: 			  }
3584: 			 }
3585: 
3586: 			 if (!declared)
3587: 			 {
3588: 			  String str = $3.to_string().get();
3589: 			  str += " was not declared.";
3590: 			  yyerror(str.getString().c_str());
3591: 			 }
3592:                 	}
3593: 			| character_expression OPTIMES ID
3594: 			{
3595: 			 bool declared = false;
3596: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3597: 			 {
3598:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3599: 			  {
3600: 			   declared = true;
3601: 			   	
3602: 			   switch (varTable[scope][i].value().getType())
3603: 			   {
3604:   			    case TCHARACTER:
3605: 			    {
3606: 			     if ($1.getType() != TCHARACTER)
3607: 			     {
3608: 			      PNF_Number n(0);
3609: 			      $$.put(n);
3610: 			     }
3611: 			     char d = $1.to_character().get();
3612: 			     PNF_Character n(varTable[scope][i].value().to_character());
3613: 			     n.mul(d);
3614: 			     $$.put(n);
3615: 			    }
3616: 			    break;
3617: 
3618:     		            default:
3619: 			     PNF_Number n(0);
3620: 			     $$.put(n);
3621: 			     break;
3622: 			   }
3623: 			  }
3624: 			 }
3625: 
3626: 			 if (!declared)
3627: 			 {
3628: 			  String str = $3.to_string().get();
3629: 			  str += " was not declared.";
3630: 			  yyerror(str.getString().c_str());
3631: 			 }
3632:                 	}
3633: 			| character_expression OPDIV ID
3634: 			{
3635: 			 bool declared = false;
3636: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3637: 			 {
3638:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3639: 			  {
3640: 			   declared = true;
3641: 			   	
3642: 			   switch (varTable[scope][i].value().getType())
3643: 			   {
3644:   			    case TCHARACTER:
3645: 			    {
3646: 			     if ($1.getType() != TCHARACTER)
3647: 			     {
3648: 			      PNF_Number n(0);
3649: 			      $$.put(n);
3650: 			     }
3651: 			     char d = $1.to_character().get();
3652: 			     PNF_Character n(varTable[scope][i].value().to_character());
3653: 			     n.div(d);
3654: 			     $$.put(n);
3655: 			    }
3656: 			    break;
3657: 
3658:     		            default:
3659: 			     PNF_Number n(0);
3660: 			     $$.put(n);
3661: 			     break;
3662: 			   }
3663: 			  }
3664: 			 }
3665: 
3666: 			 if (!declared)
3667: 			 {
3668: 			  String str = $3.to_string().get();
3669: 			  str += " was not declared.";
3670: 			  yyerror(str.getString().c_str());
3671: 			 }
3672:                 	}
3673: 			| character_expression OPPOWER ID
3674: 			{
3675: 			 bool declared = false;
3676: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3677: 			 {
3678:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3679: 			  {
3680: 			   declared = true;
3681: 			   	
3682: 			   switch (varTable[scope][i].value().getType())
3683: 			   {
3684:   			    case TCHARACTER:
3685: 			    {
3686: 			     if ($1.getType() != TCHARACTER)
3687: 			     {
3688: 			      PNF_Number n(0);
3689: 			      $$.put(n);
3690: 			     }
3691: 			     char d = $1.to_character().get();
3692: 			     PNF_Character n(varTable[scope][i].value().to_character());
3693: 			     n.pow(d);
3694: 			     $$.put(n);
3695: 			    }
3696: 			    break;
3697: 
3698:     		            default:
3699: 			     PNF_Number n(0);
3700: 			     $$.put(n);
3701: 			     break;
3702: 			   }
3703: 			  }
3704: 			 }
3705: 
3706: 			 if (!declared)
3707: 			 {
3708: 			  String str = $3.to_string().get();
3709: 			  str += " was not declared.";
3710: 			  yyerror(str.getString().c_str());
3711: 			 }
3712:                 	}
3713: 			| character_expression OPROOT ID
3714: 			{
3715: 			 bool declared = false;
3716: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3717: 			 {
3718:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3719: 			  {
3720: 			   declared = true;
3721: 			   	
3722: 			   switch (varTable[scope][i].value().getType())
3723: 			   {
3724:   			    case TCHARACTER:
3725: 			    {
3726: 			     if ($1.getType() != TCHARACTER)
3727: 			     {
3728: 			      PNF_Number n(0);
3729: 			      $$.put(n);
3730: 			     }
3731: 			     char d = varTable[scope][i].value().to_character().get();
3732: 			     PNF_Character n($1.to_character());
3733: 			     n.root(d);
3734: 			     $$.put(n);
3735: 			    }
3736: 			    break;
3737: 
3738:     		            default:
3739: 			     PNF_Number n(0);
3740: 			     $$.put(n);
3741: 			     break;
3742: 			   }
3743: 			  }
3744: 			 }
3745: 
3746: 			 if (!declared)
3747: 			 {
3748: 			  String str = $3.to_string().get();
3749: 			  str += " was not declared.";
3750: 			  yyerror(str.getString().c_str());
3751: 			 }
3752:                 	}
3753: 			| ID OPPLUS string_expression
3754: 			{
3755: 			 bool declared = false;
3756: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3757: 			 {
3758:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
3759: 			  {
3760: 			   declared = true;
3761: 			   	
3762: 			   switch (varTable[scope][i].value().getType())
3763: 			   {
3764:   			    case TSTRING:
3765: 			    {
3766: 			     if ($3.getType() != TSTRING)
3767: 			     {
3768: 			      PNF_Number n(0);
3769: 			      $$.put(n);
3770: 			     }
3771: 
3772: 
3773: 			     String d = $3.to_string().get();
3774: 			     String str = "";
3775: 			     for (unsigned is = 0; is < d.length(); ++is)
3776: 			     {
3777: 			      if (d[is] == '\"')
3778: 			       continue;
3779: 			      str += d[is];
3780: 			     }
3781: 			     String str2 = varTable[scope][i].value().to_string().get();
3782: 			     String str3 = "";
3783: 			     for (unsigned is = 0; is < str2.length(); ++is)
3784: 			     {
3785: 			      if (str2[is] == '\"')
3786: 			       continue;
3787: 			      str3 += str2[is];
3788: 			     }
3789: 
3790: 			     PNF_String n(str3);
3791: 			     n.add(str);
3792: 	  		     String str4 = "\"";
3793: 			     str4 += n.get();
3794: 			     str4 += "\"";
3795: 			     PNF_String n2(str4);
3796: 			     $$.put(n2);
3797: 			    }
3798: 			    break;
3799: 
3800:     		            default:
3801: 			     PNF_Number n(0);
3802: 			     $$.put(n);
3803: 			     break;
3804: 			   }
3805: 			  }
3806: 			 }
3807: 
3808: 			 if (!declared)
3809: 			 {
3810: 			  String str = $3.to_string().get();
3811: 			  str += " was not declared.";
3812: 			  yyerror(str.getString().c_str());
3813: 			 }
3814:                 	}
3815: 			| string_expression OPPLUS ID
3816: 			{
3817: 			 bool declared = false;
3818: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3819: 			 {
3820:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3821: 			  {
3822: 			   declared = true;
3823: 			   	
3824: 			   switch (varTable[scope][i].value().getType())
3825: 			   {
3826:   			    case TSTRING:
3827: 			    {
3828: 			     if ($1.getType() != TSTRING)
3829: 			     {
3830: 			      PNF_Number n(0);
3831: 			      $$.put(n);
3832: 			     }
3833: 
3834: 
3835: 			     String d = $1.to_string().get();
3836: 			     String str = "";
3837: 			     for (unsigned is = 0; is < d.length(); ++is)
3838: 			     {
3839: 			      if (d[is] == '\"')
3840: 			       continue;
3841: 			      str += d[is];
3842: 			     }
3843: 			     String str2 = varTable[scope][i].value().to_string().get();
3844: 			     String str3 = "";
3845: 			     for (unsigned is = 0; is < str2.length(); ++is)
3846: 			     {
3847: 			      if (str2[is] == '\"')
3848: 			       continue;
3849: 			      str3 += str2[is];
3850: 			     }
3851: 
3852: 			     PNF_String n(str3);
3853: 			     n.add(str);
3854: 	  		     String str4 = "\"";
3855: 			     str4 += n.get();
3856: 			     str4 += "\"";
3857: 			     PNF_String n2(str4);
3858: 			     $$.put(n2);
3859: 			    }
3860: 			    break;
3861: 
3862:     		            default:
3863: 			     PNF_Number n(0);
3864: 			     $$.put(n);
3865: 			     break;
3866: 			   }
3867: 			  }
3868: 			 }
3869: 
3870: 			 if (!declared)
3871: 			 {
3872: 			  String str = $3.to_string().get();
3873: 			  str += " was not declared.";
3874: 			  yyerror(str.getString().c_str());
3875: 			 }
3876:                 	}
3877: 			| number_expression OPEQU ID
3878: 			{
3879: 			 bool declared = false;
3880: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3881: 			 {
3882:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3883: 			  {
3884: 			   declared = true;
3885: 			   	
3886: 			   switch (varTable[scope][i].value().getType())
3887: 			   {
3888:   			    case TNUMBER:
3889: 			    {
3890: 			     if ($1.getType() != TNUMBER)
3891: 			     {
3892: 			      PNF_Number n(0);
3893: 			      $$.put(n);
3894: 			     }
3895: 
3896: 
3897: 			     double d1 = $1.to_number().get();
3898: 			     double d2 = varTable[scope][i].value().to_number().get();
3899: 			     bool b = d1 == d2;
3900: 			     PNF_Boolean b2(b);
3901: 			     $$.put(b2);
3902: 			    }
3903: 			    break;
3904: 
3905:     		            default:
3906: 			     PNF_Number n(0);
3907: 			     $$.put(n);
3908: 			     break;
3909: 			   }
3910: 			  }
3911: 			 }
3912: 
3913: 			 if (!declared)
3914: 			 {
3915: 			  String str = $3.to_string().get();
3916: 			  str += " was not declared.";
3917: 			  yyerror(str.getString().c_str());
3918: 			 }
3919: 			}
3920: 			| number_expression OPNEQU ID
3921: 			{
3922: 			 bool declared = false;
3923: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3924: 			 {
3925:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3926: 			  {
3927: 			   declared = true;
3928: 			   	
3929: 			   switch (varTable[scope][i].value().getType())
3930: 			   {
3931:   			    case TNUMBER:
3932: 			    {
3933: 			     if ($1.getType() != TNUMBER)
3934: 			     {
3935: 			      PNF_Number n(0);
3936: 			      $$.put(n);
3937: 			     }
3938: 
3939: 
3940: 			     double d1 = $1.to_number().get();
3941: 			     double d2 = varTable[scope][i].value().to_number().get();
3942: 			     bool b = d1 != d2;
3943: 			     PNF_Boolean b2(b);
3944: 			     $$.put(b2);
3945: 			    }
3946: 			    break;
3947: 
3948:     		            default:
3949: 			     PNF_Number n(0);
3950: 			     $$.put(n);
3951: 			     break;
3952: 			   }
3953: 			  }
3954: 			 }
3955: 
3956: 			 if (!declared)
3957: 			 {
3958: 			  String str = $3.to_string().get();
3959: 			  str += " was not declared.";
3960: 			  yyerror(str.getString().c_str());
3961: 			 }
3962: 			}
3963: 			| number_expression OPLSS ID
3964: 			{
3965: 			 bool declared = false;
3966: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
3967: 			 {
3968:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
3969: 			  {
3970: 			   declared = true;
3971: 			   	
3972: 			   switch (varTable[scope][i].value().getType())
3973: 			   {
3974:   			    case TNUMBER:
3975: 			    {
3976: 			     if ($1.getType() != TNUMBER)
3977: 			     {
3978: 			      PNF_Number n(0);
3979: 			      $$.put(n);
3980: 			     }
3981: 
3982: 
3983: 			     double d1 = $1.to_number().get();
3984: 			     double d2 = varTable[scope][i].value().to_number().get();
3985: 			     bool b = d1 < d2;
3986: 			     PNF_Boolean b2(b);
3987: 			     $$.put(b2);
3988: 			    }
3989: 			    break;
3990: 
3991:     		            default:
3992: 			     PNF_Number n(0);
3993: 			     $$.put(n);
3994: 			     break;
3995: 			   }
3996: 			  }
3997: 			 }
3998: 
3999: 			 if (!declared)
4000: 			 {
4001: 			  String str = $3.to_string().get();
4002: 			  str += " was not declared.";
4003: 			  yyerror(str.getString().c_str());
4004: 			 }
4005: 			}
4006: 			| number_expression OPGTR ID
4007: 			{
4008: 			 bool declared = false;
4009: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4010: 			 {
4011:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
4012: 			  {
4013: 			   declared = true;
4014: 			   	
4015: 			   switch (varTable[scope][i].value().getType())
4016: 			   {
4017:   			    case TNUMBER:
4018: 			    {
4019: 			     if ($1.getType() != TNUMBER)
4020: 			     {
4021: 			      PNF_Number n(0);
4022: 			      $$.put(n);
4023: 			     }
4024: 
4025: 
4026: 			     double d1 = $1.to_number().get();
4027: 			     double d2 = varTable[scope][i].value().to_number().get();
4028: 			     bool b = d1 > d2;
4029: 			     PNF_Boolean b2(b);
4030: 			     $$.put(b2);
4031: 			    }
4032: 			    break;
4033: 
4034:     		            default:
4035: 			     PNF_Number n(0);
4036: 			     $$.put(n);
4037: 			     break;
4038: 			   }
4039: 			  }
4040: 			 }
4041: 
4042: 			 if (!declared)
4043: 			 {
4044: 			  String str = $3.to_string().get();
4045: 			  str += " was not declared.";
4046: 			  yyerror(str.getString().c_str());
4047: 			 }
4048: 			}
4049: 			| number_expression OPLEQU ID
4050: 			{
4051: 			 bool declared = false;
4052: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4053: 			 {
4054:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
4055: 			  {
4056: 			   declared = true;
4057: 			   	
4058: 			   switch (varTable[scope][i].value().getType())
4059: 			   {
4060:   			    case TNUMBER:
4061: 			    {
4062: 			     if ($1.getType() != TNUMBER)
4063: 			     {
4064: 			      PNF_Number n(0);
4065: 			      $$.put(n);
4066: 			     }
4067: 
4068: 
4069: 			     double d1 = $1.to_number().get();
4070: 			     double d2 = varTable[scope][i].value().to_number().get();
4071: 			     bool b = d1 <= d2;
4072: 			     PNF_Boolean b2(b);
4073: 			     $$.put(b2);
4074: 			    }
4075: 			    break;
4076: 
4077:     		            default:
4078: 			     PNF_Number n(0);
4079: 			     $$.put(n);
4080: 			     break;
4081: 			   }
4082: 			  }
4083: 			 }
4084: 
4085: 			 if (!declared)
4086: 			 {
4087: 			  String str = $3.to_string().get();
4088: 			  str += " was not declared.";
4089: 			  yyerror(str.getString().c_str());
4090: 			 }
4091: 			}
4092: 			| number_expression OPGEQU ID
4093: 			{
4094: 			 bool declared = false;
4095: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4096: 			 {
4097:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
4098: 			  {
4099: 			   declared = true;
4100: 			   	
4101: 			   switch (varTable[scope][i].value().getType())
4102: 			   {
4103:   			    case TNUMBER:
4104: 			    {
4105: 			     if ($1.getType() != TNUMBER)
4106: 			     {
4107: 			      PNF_Number n(0);
4108: 			      $$.put(n);
4109: 			     }
4110: 
4111: 
4112: 			     double d1 = $1.to_number().get();
4113: 			     double d2 = varTable[scope][i].value().to_number().get();
4114: 			     bool b = d1 >= d2;
4115: 			     PNF_Boolean b2(b);
4116: 			     $$.put(b2);
4117: 			    }
4118: 			    break;
4119: 
4120:     		            default:
4121: 			     PNF_Number n(0);
4122: 			     $$.put(n);
4123: 			     break;
4124: 			   }
4125: 			  }
4126: 			 }
4127: 
4128: 			 if (!declared)
4129: 			 {
4130: 			  String str = $3.to_string().get();
4131: 			  str += " was not declared.";
4132: 			  yyerror(str.getString().c_str());
4133: 			 }
4134: 			}
4135: 			| ID OPEQU number_expression
4136: 			{
4137: 			 bool declared = false;
4138: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4139: 			 {
4140:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4141: 			  {
4142: 			   declared = true;
4143: 			   	
4144: 			   switch (varTable[scope][i].value().getType())
4145: 			   {
4146:   			    case TNUMBER:
4147: 			    {
4148: 			     if ($3.getType() != TNUMBER)
4149: 			     {
4150: 			      PNF_Number n(0);
4151: 			      $$.put(n);
4152: 			     }
4153: 
4154: 
4155: 			     double d1 = $3.to_number().get();
4156: 			     double d2 = varTable[scope][i].value().to_number().get();
4157: 			     bool b = d1 == d2;
4158: 			     PNF_Boolean b2(b);
4159: 			     $$.put(b2);
4160: 			    }
4161: 			    break;
4162: 
4163:     		            default:
4164: 			     PNF_Number n(0);
4165: 			     $$.put(n);
4166: 			     break;
4167: 			   }
4168: 			  }
4169: 			 }
4170: 
4171: 			 if (!declared)
4172: 			 {
4173: 			  String str = $3.to_string().get();
4174: 			  str += " was not declared.";
4175: 			  yyerror(str.getString().c_str());
4176: 			 }
4177: 			}
4178: 			| ID OPNEQU number_expression
4179: 			{
4180: 			 bool declared = false;
4181: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4182: 			 {
4183:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4184: 			  {
4185: 			   declared = true;
4186: 			   	
4187: 			   switch (varTable[scope][i].value().getType())
4188: 			   {
4189:   			    case TNUMBER:
4190: 			    {
4191: 			     if ($3.getType() != TNUMBER)
4192: 			     {
4193: 			      PNF_Number n(0);
4194: 			      $$.put(n);
4195: 			     }
4196: 
4197: 
4198: 			     double d1 = $3.to_number().get();
4199: 			     double d2 = varTable[scope][i].value().to_number().get();
4200: 			     bool b = d1 != d2;
4201: 			     PNF_Boolean b2(b);
4202: 			     $$.put(b2);
4203: 			    }
4204: 			    break;
4205: 
4206:     		            default:
4207: 			     PNF_Number n(0);
4208: 			     $$.put(n);
4209: 			     break;
4210: 			   }
4211: 			  }
4212: 			 }
4213: 
4214: 			 if (!declared)
4215: 			 {
4216: 			  String str = $3.to_string().get();
4217: 			  str += " was not declared.";
4218: 			  yyerror(str.getString().c_str());
4219: 			 }
4220: 			}
4221: 			| ID OPLSS number_expression
4222: 			{
4223: 			 bool declared = false;
4224: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4225: 			 {
4226:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4227: 			  {
4228: 			   declared = true;
4229: 			   	
4230: 			   switch (varTable[scope][i].value().getType())
4231: 			   {
4232:   			    case TNUMBER:
4233: 			    {
4234: 			     if ($3.getType() != TNUMBER)
4235: 			     {
4236: 			      PNF_Number n(0);
4237: 			      $$.put(n);
4238: 			     }
4239: 
4240: 
4241: 			     double d1 = $3.to_number().get();
4242: 			     double d2 = varTable[scope][i].value().to_number().get();
4243: 			     bool b = d1 < d2;
4244: 			     PNF_Boolean b2(b);
4245: 			     $$.put(b2);
4246: 			    }
4247: 			    break;
4248: 
4249:     		            default:
4250: 			     PNF_Number n(0);
4251: 			     $$.put(n);
4252: 			     break;
4253: 			   }
4254: 			  }
4255: 			 }
4256: 
4257: 			 if (!declared)
4258: 			 {
4259: 			  String str = $3.to_string().get();
4260: 			  str += " was not declared.";
4261: 			  yyerror(str.getString().c_str());
4262: 			 }
4263: 			}
4264: 			| ID OPGTR number_expression
4265: 			{
4266: 			 bool declared = false;
4267: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4268: 			 {
4269:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4270: 			  {
4271: 			   declared = true;
4272: 			   	
4273: 			   switch (varTable[scope][i].value().getType())
4274: 			   {
4275:   			    case TNUMBER:
4276: 			    {
4277: 			     if ($3.getType() != TNUMBER)
4278: 			     {
4279: 			      PNF_Number n(0);
4280: 			      $$.put(n);
4281: 			     }
4282: 
4283: 
4284: 			     double d1 = $3.to_number().get();
4285: 			     double d2 = varTable[scope][i].value().to_number().get();
4286: 			     bool b = d1 > d2;
4287: 			     PNF_Boolean b2(b);
4288: 			     $$.put(b2);
4289: 			    }
4290: 			    break;
4291: 
4292:     		            default:
4293: 			     PNF_Number n(0);
4294: 			     $$.put(n);
4295: 			     break;
4296: 			   }
4297: 			  }
4298: 			 }
4299: 
4300: 			 if (!declared)
4301: 			 {
4302: 			  String str = $3.to_string().get();
4303: 			  str += " was not declared.";
4304: 			  yyerror(str.getString().c_str());
4305: 			 }
4306: 			}
4307: 			| ID OPLEQU number_expression
4308: 			{
4309: 			 bool declared = false;
4310: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4311: 			 {
4312:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4313: 			  {
4314: 			   declared = true;
4315: 			   	
4316: 			   switch (varTable[scope][i].value().getType())
4317: 			   {
4318:   			    case TNUMBER:
4319: 			    {
4320: 			     if ($3.getType() != TNUMBER)
4321: 			     {
4322: 			      PNF_Number n(0);
4323: 			      $$.put(n);
4324: 			     }
4325: 
4326: 
4327: 			     double d1 = $3.to_number().get();
4328: 			     double d2 = varTable[scope][i].value().to_number().get();
4329: 			     bool b = d1 <= d2;
4330: 			     PNF_Boolean b2(b);
4331: 			     $$.put(b2);
4332: 			    }
4333: 			    break;
4334: 
4335:     		            default:
4336: 			     PNF_Number n(0);
4337: 			     $$.put(n);
4338: 			     break;
4339: 			   }
4340: 			  }
4341: 			 }
4342: 
4343: 			 if (!declared)
4344: 			 {
4345: 			  String str = $3.to_string().get();
4346: 			  str += " was not declared.";
4347: 			  yyerror(str.getString().c_str());
4348: 			 }
4349: 			}
4350: 			| ID OPGEQU number_expression
4351: 			{
4352: 			 bool declared = false;
4353: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4354: 			 {
4355:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4356: 			  {
4357: 			   declared = true;
4358: 			   	
4359: 			   switch (varTable[scope][i].value().getType())
4360: 			   {
4361:   			    case TNUMBER:
4362: 			    {
4363: 			     if ($3.getType() != TNUMBER)
4364: 			     {
4365: 			      PNF_Number n(0);
4366: 			      $$.put(n);
4367: 			     }
4368: 
4369: 
4370: 			     double d1 = $3.to_number().get();
4371: 			     double d2 = varTable[scope][i].value().to_number().get();
4372: 			     bool b = d1 >= d2;
4373: 			     PNF_Boolean b2(b);
4374: 			     $$.put(b2);
4375: 			    }
4376: 			    break;
4377: 
4378:     		            default:
4379: 			     PNF_Number n(0);
4380: 			     $$.put(n);
4381: 			     break;
4382: 			   }
4383: 			  }
4384: 			 }
4385: 
4386: 			 if (!declared)
4387: 			 {
4388: 			  String str = $3.to_string().get();
4389: 			  str += " was not declared.";
4390: 			  yyerror(str.getString().c_str());
4391: 			 }
4392: 			}
4393: 			| ID OPAMP number_expression
4394: 			{
4395: 			 bool declared = false;
4396: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4397: 			 {
4398:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4399: 			  {
4400: 			   declared = true;
4401: 			   	
4402: 			   switch (varTable[scope][i].value().getType())
4403: 			   {
4404:   			    case TNUMBER:
4405: 			    {
4406: 			     if ($3.getType() != TNUMBER)
4407: 			     {
4408: 			      PNF_Number n(0);
4409: 			      $$.put(n);
4410: 			     }
4411: 
4412: 
4413: 			     int d1 = (int)$3.to_number().get();
4414: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4415: 			     int d3 = d1 & d2;
4416: 			     PNF_Number n(d3);
4417: 			     $$.put(n);
4418: 			    }
4419: 			    break;
4420: 
4421:     		            default:
4422: 			     PNF_Number n(0);
4423: 			     $$.put(n);
4424: 			     break;
4425: 			   }
4426: 			  }
4427: 			 }
4428: 
4429: 			 if (!declared)
4430: 			 {
4431: 			  String str = $3.to_string().get();
4432: 			  str += " was not declared.";
4433: 			  yyerror(str.getString().c_str());
4434: 			 }
4435: 			}
4436: 			| ID OPBTOR number_expression
4437: 			{
4438: 			 bool declared = false;
4439: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4440: 			 {
4441:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4442: 			  {
4443: 			   declared = true;
4444: 			   	
4445: 			   switch (varTable[scope][i].value().getType())
4446: 			   {
4447:   			    case TNUMBER:
4448: 			    {
4449: 			     if ($3.getType() != TNUMBER)
4450: 			     {
4451: 			      PNF_Number n(0);
4452: 			      $$.put(n);
4453: 			     }
4454: 
4455: 
4456: 			     int d1 = (int)$3.to_number().get();
4457: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4458: 			     int d3 = d1 | d2;
4459: 			     PNF_Number n(d3);
4460: 			     $$.put(n);
4461: 			    }
4462: 			    break;
4463: 
4464:     		            default:
4465: 			     PNF_Number n(0);
4466: 			     $$.put(n);
4467: 			     break;
4468: 			   }
4469: 			  }
4470: 			 }
4471: 
4472: 			 if (!declared)
4473: 			 {
4474: 			  String str = $3.to_string().get();
4475: 			  str += " was not declared.";
4476: 			  yyerror(str.getString().c_str());
4477: 			 }
4478: 			}
4479: 			| ID OPBTXOR number_expression
4480: 			{
4481: 			 bool declared = false;
4482: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4483: 			 {
4484:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4485: 			  {
4486: 			   declared = true;
4487: 			   	
4488: 			   switch (varTable[scope][i].value().getType())
4489: 			   {
4490:   			    case TNUMBER:
4491: 			    {
4492: 			     if ($3.getType() != TNUMBER)
4493: 			     {
4494: 			      PNF_Number n(0);
4495: 			      $$.put(n);
4496: 			     }
4497: 
4498: 
4499: 			     int d1 = (int)$3.to_number().get();
4500: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4501: 			     int d3 = d1 ^ d2;
4502: 			     PNF_Number n(d3);
4503: 			     $$.put(n);
4504: 			    }
4505: 			    break;
4506: 
4507:     		            default:
4508: 			     PNF_Number n(0);
4509: 			     $$.put(n);
4510: 			     break;
4511: 			   }
4512: 			  }
4513: 			 }
4514: 
4515: 			 if (!declared)
4516: 			 {
4517: 			  String str = $3.to_string().get();
4518: 			  str += " was not declared.";
4519: 			  yyerror(str.getString().c_str());
4520: 			 }
4521: 			}
4522: 			| number_expression OPAMP ID
4523: 			{
4524: 			 bool declared = false;
4525: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4526: 			 {
4527:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
4528: 			  {
4529: 			   declared = true;
4530: 			   	
4531: 			   switch (varTable[scope][i].value().getType())
4532: 			   {
4533:   			    case TNUMBER:
4534: 			    {
4535: 			     if ($1.getType() != TNUMBER)
4536: 			     {
4537: 			      PNF_Number n(0);
4538: 			      $$.put(n);
4539: 			     }
4540: 
4541: 
4542: 			     int d1 = (int)$1.to_number().get();
4543: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4544: 			     int d3 = d1 & d2;
4545: 			     PNF_Number n(d3);
4546: 			     $$.put(n);
4547: 			    }
4548: 			    break;
4549: 
4550:     		            default:
4551: 			     PNF_Number n(0);
4552: 			     $$.put(n);
4553: 			     break;
4554: 			   }
4555: 			  }
4556: 			 }
4557: 
4558: 			 if (!declared)
4559: 			 {
4560: 			  String str = $3.to_string().get();
4561: 			  str += " was not declared.";
4562: 			  yyerror(str.getString().c_str());
4563: 			 }
4564: 			}
4565: 			| number_expression OPBTOR ID
4566: 			{
4567: 			 bool declared = false;
4568: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4569: 			 {
4570:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
4571: 			  {
4572: 			   declared = true;
4573: 			   	
4574: 			   switch (varTable[scope][i].value().getType())
4575: 			   {
4576:   			    case TNUMBER:
4577: 			    {
4578: 			     if ($1.getType() != TNUMBER)
4579: 			     {
4580: 			      PNF_Number n(0);
4581: 			      $$.put(n);
4582: 			     }
4583: 
4584: 
4585: 			     int d1 = (int)$1.to_number().get();
4586: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4587: 			     int d3 = d1 | d2;
4588: 			     PNF_Number n(d3);
4589: 			     $$.put(n);
4590: 			    }
4591: 			    break;
4592: 
4593:     		            default:
4594: 			     PNF_Number n(0);
4595: 			     $$.put(n);
4596: 			     break;
4597: 			   }
4598: 			  }
4599: 			 }
4600: 
4601: 			 if (!declared)
4602: 			 {
4603: 			  String str = $3.to_string().get();
4604: 			  str += " was not declared.";
4605: 			  yyerror(str.getString().c_str());
4606: 			 }
4607: 			}
4608: 			| number_expression OPBTXOR ID
4609: 			{
4610: 			 bool declared = false;
4611: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4612: 			 {
4613:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
4614: 			  {
4615: 			   declared = true;
4616: 			   	
4617: 			   switch (varTable[scope][i].value().getType())
4618: 			   {
4619:   			    case TNUMBER:
4620: 			    {
4621: 			     if ($1.getType() != TNUMBER)
4622: 			     {
4623: 			      PNF_Number n(0);
4624: 			      $$.put(n);
4625: 			     }
4626: 
4627: 
4628: 			     int d1 = (int)$1.to_number().get();
4629: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4630: 			     int d3 = d1 ^ d2;
4631: 			     PNF_Number n(d3);
4632: 			     $$.put(n);
4633: 			    }
4634: 			    break;
4635: 
4636:     		            default:
4637: 			     PNF_Number n(0);
4638: 			     $$.put(n);
4639: 			     break;
4640: 			   }
4641: 			  }
4642: 			 }
4643: 
4644: 			 if (!declared)
4645: 			 {
4646: 			  String str = $3.to_string().get();
4647: 			  str += " was not declared.";
4648: 			  yyerror(str.getString().c_str());
4649: 			 }	
4650: 			}
4651: 			| OPBTNOT ID
4652: 			{
4653: 			 bool declared = false;
4654: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4655: 			 {
4656:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
4657: 			  {
4658: 			   declared = true;
4659: 			   	
4660: 			   switch (varTable[scope][i].value().getType())
4661: 			   {
4662:   			    case TNUMBER:
4663: 			    {
4664: 			     int d1 = (int)varTable[scope][i].value().to_number().get();
4665: 			     int d2 = ~d1;
4666: 			     PNF_Number n(d1);
4667: 			     $$.put(n);
4668: 			    }
4669: 			    break;
4670: 
4671:     		            default:
4672: 			     PNF_Number n(0);
4673: 			     $$.put(n);
4674: 			     break;
4675: 			   }
4676: 			  }
4677: 			 }
4678: 
4679: 			 if (!declared)
4680: 			 {
4681: 			  String str = $2.to_string().get();
4682: 			  str += " was not declared.";
4683: 			  yyerror(str.getString().c_str());
4684: 			 }
4685: 			}
4686: 			| ID OPBTSL number_expression
4687: 			{
4688: 			 bool declared = false;
4689: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4690: 			 {
4691:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4692: 			  {
4693: 			   declared = true;
4694: 			   	
4695: 			   switch (varTable[scope][i].value().getType())
4696: 			   {
4697:   			    case TNUMBER:
4698: 			    {
4699: 			     if ($3.getType() != TNUMBER)
4700: 			     {
4701: 			      PNF_Number n(0);
4702: 			      $$.put(n);
4703: 			     }
4704: 
4705: 
4706: 			     int d1 = (int)$3.to_number().get();
4707: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4708: 			     int d3 = d1 << d2;
4709: 			     PNF_Number n(d3);
4710: 			     $$.put(n);
4711: 			    }
4712: 			    break;
4713: 
4714:     		            default:
4715: 			     PNF_Number n(0);
4716: 			     $$.put(n);
4717: 			     break;
4718: 			   }
4719: 			  }
4720: 			 }
4721: 
4722: 			 if (!declared)
4723: 			 {
4724: 			  String str = $3.to_string().get();
4725: 			  str += " was not declared.";
4726: 			  yyerror(str.getString().c_str());
4727: 			 }
4728: 			}
4729: 			| ID OPBTSR number_expression
4730: 			{
4731: 			 bool declared = false;
4732: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4733: 			 {
4734:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
4735: 			  {
4736: 			   declared = true;
4737: 			   	
4738: 			   switch (varTable[scope][i].value().getType())
4739: 			   {
4740:   			    case TNUMBER:
4741: 			    {
4742: 			     if ($3.getType() != TNUMBER)
4743: 			     {
4744: 			      PNF_Number n(0);
4745: 			      $$.put(n);
4746: 			     }
4747: 
4748: 
4749: 			     int d1 = (int)$3.to_number().get();
4750: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4751: 			     int d3 = d1 >> d2;
4752: 			     PNF_Number n(d3);
4753: 			     $$.put(n);
4754: 			    }
4755: 			    break;
4756: 
4757:     		            default:
4758: 			     PNF_Number n(0);
4759: 			     $$.put(n);
4760: 			     break;
4761: 			   }
4762: 			  }
4763: 			 }
4764: 
4765: 			 if (!declared)
4766: 			 {
4767: 			  String str = $3.to_string().get();
4768: 			  str += " was not declared.";
4769: 			  yyerror(str.getString().c_str());
4770: 			 }
4771: 			}
4772: 			| number_expression OPBTSL ID
4773: 			{
4774: 			 bool declared = false;
4775: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4776: 			 {
4777:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
4778: 			  {
4779: 			   declared = true;
4780: 			   	
4781: 			   switch (varTable[scope][i].value().getType())
4782: 			   {
4783:   			    case TNUMBER:
4784: 			    {
4785: 			     if ($1.getType() != TNUMBER)
4786: 			     {
4787: 			      PNF_Number n(0);
4788: 			      $$.put(n);
4789: 			     }
4790: 
4791: 
4792: 			     int d1 = (int)$1.to_number().get();
4793: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4794: 			     int d3 = d1 << d2;
4795: 			     PNF_Number n(d3);
4796: 			     $$.put(n);
4797: 			    }
4798: 			    break;
4799: 
4800:     		            default:
4801: 			     PNF_Number n(0);
4802: 			     $$.put(n);
4803: 			     break;
4804: 			   }
4805: 			  }
4806: 			 }
4807: 
4808: 			 if (!declared)
4809: 			 {
4810: 			  String str = $3.to_string().get();
4811: 			  str += " was not declared.";
4812: 			  yyerror(str.getString().c_str());
4813: 			 }
4814: 			}
4815: 			| number_expression OPBTSR ID
4816: 			{
4817: 			 bool declared = false;
4818: 			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
4819: 			 {
4820:   			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
4821: 			  {
4822: 			   declared = true;
4823: 			   	
4824: 			   switch (varTable[scope][i].value().getType())
4825: 			   {
4826:   			    case TNUMBER:
4827: 			    {
4828: 			     if ($1.getType() != TNUMBER)
4829: 			     {
4830: 			      PNF_Number n(0);
4831: 			      $$.put(n);
4832: 			     }
4833: 
4834: 
4835: 			     int d1 = (int)$1.to_number().get();
4836: 			     int d2 = (int)varTable[scope][i].value().to_number().get();
4837: 			     int d3 = d1 >> d2;
4838: 			     PNF_Number n(d3);
4839: 			     $$.put(n);
4840: 			    }
4841: 			    break;
4842: 
4843:     		            default:
4844: 			     PNF_Number n(0);
4845: 			     $$.put(n);
4846: 			     break;
4847: 			   }
4848: 			  }
4849: 			 }
4850: 
4851: 			 if (!declared)
4852: 			 {
4853: 			  String str = $3.to_string().get();
4854: 			  str += " was not declared.";
4855: 			  yyerror(str.getString().c_str());
4856: 			 }
4857: 			}
4858: 			;
4859: 
4860: function_expression:	function_command
4861: 			| LEFTP function_expression RIGHTP
4862: 			;
4863: 
4864: declaration:		variable_declaration
4865: 			{
4866: 			}
4867: 			| label_declaration
4868: 			{
4869: 			}
4870: 			| enum_declaration
4871: 			{
4872: 			}
4873: 			| range_declaration
4874: 			{
4875: 			}
4876: 			| function_declaration
4877: 			{
4878: 			}
4879: 			| function_declaration2
4880: 			{
4881: 			}
4882: 			| struct_declaration
4883: 			{
4884: 			}
4885: 			| struct_declaration2
4886: 			;
4887: 
4888: variable_declaration:	VAR ID
4889: 			{
4890: 			 Var v;
4891: 			 v.name($2.to_string().get());
4892: 			 varTable[scope][varTable.length() - 1] = v;
4893: 
4894: 			 conprint("var %s;\n", $2.to_string().get().getString().c_str());
4895: 			}
4896: 			| VAR ID OPEQUAL expression
4897: 			{
4898: 			 Var v;
4899: 			 v.name($2.to_string().get());
4900: 			 v.value($4);
4901: 			 varTable[scope][varTable.length() - 1] = v;
4902: 
4903: 			 switch ($4.getType())
4904: 			 {
4905: 			  case TVOID:
4906: 			   conprint("var %s = %s;\n", $2.to_string().get().getString().c_str(), $4.to_string().get().getString().c_str());
4907: 			   break;
4908: 
4909: 			  case TBOOLEAN:
4910: 			   conprint("var %s = %s;\n", $2.to_string().get().getString().c_str(), $4.to_boolean().get().getString().c_str());
4911: 			   break;
4912: 
4913: 			  case TNUMBER:
4914: 			   conprint("var %s = %g;\n", $2.to_string().get().getString().c_str(), $4.to_number().get());
4915: 			   break;
4916: 
4917: 			  case TCHARACTER:
4918: 			   conprint("var %s = %c;\n", $2.to_string().get().getString().c_str(), $4.to_character().get());
4919: 			   break;
4920: 
4921: 			  case TSTRING:
4922: 			   conprint("var %s = %s;\n", $2.to_string().get().getString().c_str(), $4.to_string().get().getString().c_str());
4923: 			   break;
4924: 
4925: 			  default:
4926: 			   yyerror("Bad type.");
4927: 			 }
4928: 			}
4929: 			| FVAR ID
4930: 			{
4931: 			 conprint("fvar %s;\n", $2.to_string().get().getString().c_str());
4932: 			}
4933: 			| enumv_declaration
4934: 			{
4935: 			}
4936: 			| rangev_declaration
4937: 			{
4938: 			}
4939: 			| array_declaration
4940: 			{
4941: 			}
4942: 			;
4943: 
4944: enumv_declaration:	ENUMV STRINGV STRINGV OPEQUAL STRINGV
4945: 			{
4946: 			 Var v;
4947: 			 v.name($2.to_string().get());
4948: 			 v.value($5);
4949: 			 varTable[scope][varTable.length() - 1] = v;
4950: 
4951: 			 conprint("enumv %s %s = %s\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
4952: 				  $5.to_string().get().getString().c_str());
4953: 			}
4954: 			;
4955: 
4956: rangev_declaration:	RANGEV RTYPE2 STRINGV STRINGV OPEQUAL STRINGV
4957: 			{
4958: 			 Var v;
4959: 			 v.name($3.to_string().get());
4960: 			 v.value($6);
4961: 			 varTable[scope][varTable.length() - 1] = v;
4962: 
4963: 			 conprint("rangev %s %s %s = %s\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
4964: 				  $4.to_string().get().getString().c_str(), $6.to_string().get().getString().c_str());
4965: 			}
4966: 			| RANGEV RTYPE2 STRINGV STRINGV
4967: 			{
4968: 			 Var v;
4969: 			 v.name($2.to_string().get());
4970: 			 v.value($4);
4971: 			 varTable[scope][varTable.length() - 1] = v;
4972: 			
4973: 			 conprint("rangev %s %s %s\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
4974: 				  $4.to_string().get().getString().c_str());
4975: 			}
4976: 			;
4977: 
4978: array_declaration:	ARRAY STRINGV OPLSQ number_expression OPRSQ
4979: 			{
4980: 			 Var v;
4981: 			 v.name($2.to_string().get());
4982: 			 v.value((char *)"{array}");
4983: 			 varTable[scope][varTable.length() - 1] = v;
4984: 
4985: 			 conprint("array %s[%s]\n", $2.to_string().get().getString().c_str(), $4.to_string().get().getString().c_str());
4986: 			}
4987: 			;
4988: 
4989: enum_declaration:	ENUM ID OPEQUAL LEFTB 
4990: 			{
4991: 			 conprint("enum %s = {\n", $2.to_string().get().getString().c_str());
4992: 			}
4993: 			enum_strings
4994: 			{
4995: 			}
4996: 			RIGHTB
4997: 			{
4998: 			 conprint("}\n");
4999: 			}
5000: 			;
5001: 
5002: enum_strings:		STRINGV
5003: 			{
5004: 			 conprint("%s\n", $1.to_string().get().getString().c_str());
5005: 			}
5006: 			| enum_strings COMMA STRINGV
5007: 			{
5008: 			 conprint("%s, %s\n", $1.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5009: 			}
5010: 			;
5011: 
5012: range_declaration:	RANGE RTYPE2 STRINGV OPEQUAL STRINGV OPDOT OPDOT STRINGV
5013: 			{
5014: 			 conprint("range %s %s = %s..%s\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
5015: 				  $5.to_string().get().getString().c_str(), $8.to_string().get().getString().c_str());
5016: 			}
5017: 			;
5018: 
5019: label_declaration:	SUB ID
5020: 			{
5021: 			 conprint("sub %s;\n", $2.to_string().get().getString().c_str());
5022: 			}
5023: 			| EVENT ID
5024: 			{
5025: 			 conprint("event %s;\n", $2.to_string().get().getString().c_str());
5026: 			}
5027: 			| LABEL ID
5028: 			{
5029: 			 conprint("label %s;\n", $2.to_string().get().getString().c_str());
5030: 			}
5031: 			;
5032: 
5033: function_declaration:	VOIDV ID LEFTP parameter_declaration RIGHTP
5034: 			{
5035: 			 Function f;
5036: 			 f.name($2.to_string().get());
5037: 			 PNF_Void v;
5038: 			 PNF_Variable v2(v);
5039: 			 f.ret(v2);
5040: 
5041: 			 for (unsigned long i = 0; i < paramcount; ++i)
5042:                          {
5043: 			  String str = "";
5044: 			  str.from_long(i);
5045: 			  String str2 = "p";
5046: 			  str2 += str;
5047: 
5048: 			  f.param(i, v2);
5049: 			  f.pname(i, str2);
5050: 			 }
5051: 			 paramcount = 0;
5052: 			 funcs.add_function(f);
5053: 
5054: 			 conprint("subroutine %s;\n", $2.to_string().get().getString().c_str());
5055: 			 conprint("var %s;\n", $2.to_string().get().getString().c_str());
5056: 			}
5057: 			| VAR ID LEFTP parameter_declaration RIGHTP
5058: 			{
5059: 			 Function f;
5060: 			 f.name($2.to_string().get());
5061: 			 PNF_Void v;
5062: 			 PNF_Variable v2(v);
5063: 			 f.ret(v2);
5064: 
5065: 			 for (unsigned long i = 0; i < paramcount; ++i)
5066:                          {
5067: 			  f.param(i, v2);
5068: 			  f.pname(i, $4.to_string().get());
5069: 			 }
5070: 			 paramcount = 0;
5071: 			 funcs.add_function(f);
5072: 			 
5073: 			 conprint("subroutine %s;\n", $2.to_string().get().getString().c_str());
5074: 			 conprint("var %s;\n", $2.to_string().get().getString().c_str());
5075: 			}
5076: 			;
5077: 
5078: parameter_declaration:	opt_var
5079: 			{
5080: 			 ++paramcount;
5081: 			 $$ = $1;
5082: 			}
5083: 			| parameter_declaration "," VAR ID
5084: 			;
5085: 
5086: parameter_declaration2:	opt_var2
5087: 			{
5088: 			 ++paramcount2;
5089: 			}
5090: 			| parameter_declaration "," VAR ID
5091: 			;
5092: 
5093: opt_var:		VAR ID
5094: 			{
5095: 			 $$ = $2;
5096: 			}
5097: 			| VOIDV
5098: 			;
5099: 
5100: opt_var2:		VAR ID
5101: 			{
5102: 			 conprint("var %s;\n", $2.to_string().get().getString().c_str());			 
5103: 			}
5104: 			| VOIDV
5105: 			;
5106: 
5107: function_declaration2:	FUNCTION VOIDV ID LEFTP parameter_declaration2 RIGHTP
5108: 			{
5109: 			 Function f;
5110: 			 f.name($3.to_string().get());
5111: 			 PNF_Void v;
5112: 			 PNF_Variable v2(v);
5113: 			 f.ret(v2);
5114: 
5115: 			 for (unsigned long i = 0; i < paramcount2; ++i)
5116:                          {
5117: 			  f.param(i, v2);
5118: 			  			 }
5119: 			 paramcount2 = 0;
5120: 
5121: 			 bool b = false;
5122: 			 funcs.find_duplicate(f, b);
5123: 			 if (b)
5124: 			  yyerror("Function mismatch.");
5125: 
5126: 			 conprint("%s:\n", $3.to_string().get().getString().c_str());
5127: 			}
5128: 			function_body
5129: 			{
5130: 			}
5131: 			| FUNCTION VAR ID LEFTP parameter_declaration RIGHTP
5132: 			{
5133: 			 Function f;
5134: 			 f.name($3.to_string().get());
5135: 			 PNF_Void v;
5136: 			 PNF_Variable v2(v);
5137: 			 f.ret(v2);
5138: 
5139: 			 for (unsigned long i = 0; i < paramcount2; ++i)
5140:                          {
5141: 			  f.param(i, v2);
5142: 			 }
5143: 			 paramcount2 = 0;
5144: 
5145: 			 bool b = false;
5146: 			 funcs.find_duplicate(f, b);
5147: 			 if (b)
5148: 			  yyerror("Function mismatch.");
5149: 			 conprint("%s:\n", $3.to_string().get().getString().c_str());
5150: 			}
5151: 			function_body
5152: 			{
5153: 			}
5154: 			;
5155: 
5156: function_body:		LEFTB
5157: 			statements
5158: 			RIGHTB
5159: 			;
5160: 
5161: struct_declaration:	{	 
5162: 			 if (struct_counter != 0)
5163: 			  structs.insert();
5164: 			}
5165: 			STRUCT ID
5166: 			{
5167: 			 structs[struct_counter].name($2.to_string().get());
5168: 			 struct_counter++;
5169: 			}
5170: 			struct_body
5171: 			;
5172: 
5173: struct_body:		LEFTB vars SEND RIGHTB
5174: 			;
5175: 
5176: vars:			variable_declaration SEND
5177: 			{
5178: 			 Var v = varTable[scope][varTable[scope].length() - 1];
5179: 			 structs[struct_counter].var(struct_counter, v);
5180: 			}
5181: 			| variable_declaration SEND vars
5182: 			{
5183: 			 Var v = varTable[scope][varTable[scope].length() - 1];
5184: 			 structs[struct_counter].var(struct_counter, v);
5185: 			}
5186: 			;
5187: 
5188: struct_declaration2:	STRUCT ID
5189: 			{
5190: 			 bool found = false;
5191: 			 for (unsigned long i = 0; i < struct_counter; ++i)
5192: 			 {
5193: 			  if (structs[struct_counter].name() == $2.to_string().get())
5194: 			   found = true;
5195: 			 }
5196: 
5197: 			 if (found)
5198: 			 {
5199: 			  for (unsigned long i = 0; i < structs[struct_counter].vnumber(); ++i)
5200: 			  {
5201: 			   conprint((char *)"var %s %s = %s", (char *)$2.to_string().get().getString().c_str(),
5202: 				    (char *)structs[struct_counter].var(i).name().getString().c_str(),
5203: 				    (char *)structs[struct_counter].var(i).value().to_string().get().getString().c_str());
5204: 			  }
5205: 			 }
5206: 			}
5207: 			;
5208: 
5209: command:		print_command
5210: 			{
5211: 			}
5212: 			| read_command
5213: 			{
5214: 			}
5215: 			| end_command
5216: 			{
5217: 			}
5218: 			| asm_command
5219: 			{
5220: 			}
5221: 			| load_command
5222: 			{
5223: 			}
5224: 			| goto_command
5225: 			{
5226: 			}
5227: 			| operator_command
5228: 			{
5229: 			}
5230: 			| st_command
5231: 			{
5232: 			}
5233: 			| stack_command
5234: 			{
5235: 			}
5236: 			| typeof_command
5237: 			{
5238: 			}
5239: 			| rm_command
5240: 			{
5241: 			}
5242: 			| crash_command
5243: 			{
5244: 			}
5245: 			| version_command
5246: 			{
5247: 			}
5248: 			| halt_command
5249: 			{
5250: 			}
5251: 			| modt_command
5252: 			{
5253: 			}
5254: 			| subroutine_command
5255: 			{
5256: 			}
5257: 			| register_command
5258: 			{
5259: 			}
5260: 			| store_command
5261: 			{
5262: 			}
5263: 			| break_command
5264: 			{
5265: 			}
5266: 			| address_command
5267: 			{
5268: 			}
5269: 			| add2v_command
5270: 			{
5271: 			}
5272: 			| continue_command
5273: 			{
5274: 			}
5275: 			| check_command
5276: 			{
5277: 			}
5278: 			| comment_command
5279: 			{
5280: 			}
5281: 			| file_command
5282: 			{
5283: 			}
5284: 			| meml_command
5285: 			{
5286: 			}
5287: 			| pnfasm_command
5288: 			{
5289: 			}
5290: 			| array_length_command
5291: 			{
5292: 			}
5293: 			| dup_command
5294: 			{
5295: 			}
5296: 			;
5297: 
5298: print_command:		
5299: 			PRINT
5300: 			{
5301: 			 conprint("print;\n");
5302: 			}
5303: 			| PRINT expression
5304: 			{
5305: 			 conprint("print %s;\n", $2.to_string().get().getString().c_str());
5306: 			}
5307: 			| PRINT CTYPE
5308: 			{
5309: 			 conprint("print %s;\n", $2.to_string().get().getString().c_str());
5310: 			}
5311: 			| PRINTLN
5312: 			{
5313: 			 conprint("println;");
5314: 			}
5315: 			| PRINTLN expression
5316: 			{
5317: 			 conprint("println %s;\n", $2.to_string().get().getString().c_str());
5318: 			}
5319: 			| PRINTLN CTYPE
5320: 			{
5321: 			 conprint("println %s;\n", $2.to_string().get().getString().c_str());
5322: 			}
5323: 			| EPRINT
5324: 			{
5325: 			 conprint("eprint;");
5326: 			}
5327: 			| EPRINT expression
5328: 			{
5329: 			 conprint("eprint %s;\n", $2.to_string().get().getString().c_str());
5330: 			}
5331: 			| EPRINTLN
5332: 			{
5333: 			 conprint("eprintln;");
5334: 			}
5335: 			| EPRINTLN expression
5336: 			{
5337: 			 conprint("eprintln %s;\n", $2.to_string().get().getString().c_str());
5338: 			}
5339: 			| FPRINT
5340: 			{
5341: 			 conprint("fprint;");
5342: 			}
5343: 			| FPRINT expression
5344: 			{
5345: 			 conprint("fprint %s;\n", $2.to_string().get().getString().c_str());
5346: 			}
5347: 			| FPRINTLN
5348: 			{
5349: 			 conprint("fprintln;");
5350: 			}
5351: 			| FPRINTLN expression
5352: 			{
5353: 			 conprint("fprintln %s;\n", $2.to_string().get().getString().c_str());
5354: 			}
5355: 			| PRINT ARRAY STRINGV
5356: 			{
5357: 			 conprint("print array %s\n", $3.to_string().get().getString().c_str());
5358: 			}
5359: 			;
5360: 
5361: read_command:
5362: 			READ TYPE ID
5363: 			{
5364: 			 conprint("read %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5365: 			}
5366: 			| FREAD TYPE ID
5367: 			{
5368: 			 conprint("fread %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5369: 			}
5370: 			;
5371: 
5372: end_command:
5373: 			END number_expression
5374: 			{
5375: 			 conprint("end %g;\n", $2.to_number().get());
5376: 			}
5377: 			;
5378: 
5379: asm_command:		ASM STRINGV STRINGV string_expression
5380: 			{
5381: 			 conprint("asm %s %s %s\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
5382: 				  $4.to_string().get().getString().c_str());
5383: 			}
5384: 			;
5385: 
5386: load_command:		LOAD RTYPE LTYPE number_expression
5387: 			{
5388: 			 conprint("load %s %s %g;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), $4.to_number().get());
5389: 			}
5390: 			| LOAD RTYPE LTYPE TYPE
5391: 			{
5392: 			 conprint("load %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5393: 			}
5394: 			| LOAD LTYPE
5395: 			{
5396: 			 conprint("load %s;\n", $2.to_string().get().getString().c_str());
5397: 			}
5398: 			| LOAD LTYPE boolean_expression
5399: 			{
5400: 			 conprint("load %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_boolean().get().getString().c_str());
5401: 			}
5402: 			| LOAD LTYPE number_expression
5403: 			{
5404: 			 conprint("load %s %g;\n", $2.to_string().get().getString().c_str(), $3.to_number().get());
5405: 			}
5406: 			| LOAD LTYPE character_expression
5407: 			{
5408: 			 conprint("load %s %c;\n", $2.to_string().get().getString().c_str(), $3.to_character().get());
5409: 			}
5410: 			| LOAD LTYPE string_expression
5411: 			{
5412: 			 conprint("load %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5413: 			}
5414: 			| LOAD RTYPE LTYPE ID
5415: 			{
5416: 			 conprint("load %s %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
5417: 				  $4.to_string().get().getString().c_str());
5418: 			}
5419: 			| LOAD RANGE RTYPE2 STRINGV
5420: 			{
5421: 			 conprint("load %s %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
5422: 				  $4.to_string().get().getString().c_str());
5423: 			}
5424: 			| LOAD RANGE RTYPE2 STRINGV OPLSQ number_expression OPRSQ
5425: 			{
5426: 			 conprint("load %s %s %s[%g];\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
5427: 				  $5.to_number().get());
5428: 			}
5429: 			| LOAD ARRAY STRINGV OPLSQ number_expression OPRSQ
5430: 			{
5431: 			 conprint("load array %s[%g];\n", $3.to_string().get().getString().c_str(), $5.to_number().get());
5432: 			}
5433: 			| LOAD ARRAY STRINGV OPLSQ OPRSQ
5434: 			{
5435: 			 conprint("load array %s[];\n", $3.to_string().get().getString().c_str());
5436: 			}
5437: 			;
5438: 
5439: goto_command:		GOTO GTYPE number_expression
5440: 			{
5441: 			 conprint("goto %s %g;\n", $2.to_string().get().getString().c_str(), $3.to_number().get());
5442: 			}
5443: 			| GOTO GTYPE ID
5444: 			{
5445: 			 conprint("goto %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5446: 			}
5447: 			;
5448: 
5449: operator_command:	OPPLUS
5450: 			{
5451: 			 conprint("+;\n");
5452: 			}
5453: 			| OPPLUS number_expression
5454: 			{
5455: 			 conprint("+ %g;\n", $2.to_number().get());
5456: 			}
5457: 			| OPPLUS character_expression
5458: 			{
5459: 			 conprint("+ %c;\n", $2.to_character().get());
5460: 			}
5461: 			| OPPLUS string_expression
5462: 			{
5463: 			 conprint("+ %s;\n", $2.to_string().get().getString().c_str());
5464: 			}
5465: 			| OPMINUS
5466: 			{
5467: 			 conprint("-;\n");
5468: 			}
5469: 			| OPSUB number_expression
5470: 			{
5471: 			 conprint("- %g;\n", $2.to_number().get());
5472: 			}
5473: 			| OPTIMES
5474: 			{
5475: 			 conprint("*;\n");
5476: 			}
5477: 			| OPTIMES number_expression
5478: 			{
5479: 			 conprint("* %g;\n", $2.to_number().get());
5480: 			}
5481: 			| OPDIV
5482: 			{
5483: 			 conprint("/;\n");
5484: 			}
5485: 			| OPDIV number_expression
5486: 			{
5487: 			 conprint("/ %g;\n", $2.to_number().get());
5488: 			}
5489: 			| OPMODULUS
5490: 			{
5491: 			 conprint("%%;\n");
5492: 			}
5493: 			| OPMODULUS number_expression
5494: 			{
5495: 			 conprint("%% %g;\n", $2.to_number().get());
5496: 			}
5497: 			| OPPOWER
5498: 			{
5499: 			 conprint("^;\n");
5500: 			}
5501: 			| OPPOWER number_expression
5502: 			{
5503: 			 conprint("^ %g;\n", $2.to_number().get());
5504: 			}
5505: 			| OPROOT
5506: 			{
5507: 			 conprint("!^;\n");
5508: 			}
5509: 			| OPROOT number_expression
5510: 			{
5511: 			 conprint("!^ %g;\n", $2.to_number().get());
5512: 			}
5513: 			| OPINC
5514: 			{
5515: 			 conprint("++;\n");
5516: 			}
5517: 			| OPDEC
5518: 			{
5519: 			 conprint("--;\n");
5520: 			}
5521: 			| OPAND
5522: 			{
5523: 			 conprint("&&;\n");
5524: 			}
5525: 			| OPOR
5526: 			{
5527: 			 conprint("||;\n");
5528: 			}
5529: 			| OPNOT
5530: 			{
5531: 			 conprint("!;\n");
5532: 			}
5533: 			| OPEQU
5534: 			{
5535: 			 conprint("==;\n");
5536: 			}
5537: 			| OPNEQU
5538: 			{
5539: 			 conprint("!=;\n");
5540: 			}
5541: 			| OPLSS
5542: 			{
5543: 			 conprint("<;\n");
5544: 			}
5545: 			| OPGTR
5546: 			{
5547: 			 conprint(">;\n");
5548: 			}
5549: 			| OPLEQU
5550: 			{
5551: 			 conprint("<=;\n");
5552: 			}
5553: 			| OPGEQU
5554: 			{
5555: 			 conprint(">=;\n");
5556: 			}
5557: 			| OPEQU boolean_expression
5558: 			{
5559: 			 conprint("== %s;\n", $2.to_boolean().get().getString().c_str());
5560: 			}
5561: 			| OPNEQU boolean_expression
5562: 			{
5563: 			 conprint("!= %s;\n", $2.to_boolean().get().getString().c_str());
5564: 			}
5565: 			| OPEQU number_expression
5566: 			{
5567: 			 conprint("== %g;\n", $2.to_number().get());
5568: 			}
5569: 			| OPNEQU number_expression
5570: 			{
5571: 			 conprint("!= %g;\n", $2.to_number().get());
5572: 			}
5573: 			| OPLSS number_expression
5574: 			{
5575: 			 conprint("< %g;\n", $2.to_number().get());
5576: 			}
5577: 			| OPGTR number_expression
5578: 			{
5579: 			 conprint("> %g;\n", $2.to_number().get());
5580: 			}
5581: 			| OPLEQU number_expression
5582: 			{
5583: 			 conprint("<= %g;\n", $2.to_number().get());
5584: 			}
5585: 			| OPGEQU number_expression
5586: 			{
5587: 			 conprint(">= %g;\n", $2.to_number().get());
5588: 			}
5589: 			| OPEQU character_expression
5590: 			{
5591: 			 conprint("== %c;\n", $2.to_character().get());
5592: 			}
5593: 			| OPNEQU character_expression
5594: 			{
5595: 			 conprint("!= %c;\n", $2.to_character().get());
5596: 			}
5597: 			| OPLSS character_expression
5598: 			{
5599: 			 conprint("< %c;\n", $2.to_character().get());
5600: 			}
5601: 			| OPGTR character_expression
5602: 			{
5603: 			 conprint("> %c;\n", $2.to_character().get());
5604: 			}
5605: 			| OPLEQU character_expression
5606: 			{
5607: 			 conprint("<= %c;\n", $2.to_character().get());
5608: 			}
5609: 			| OPGEQU character_expression
5610: 			{
5611: 			 conprint(">= %c;\n", $2.to_character().get());
5612: 			}
5613: 			| OPAMP
5614: 			{
5615: 			 conprint("&;\n");
5616: 			}
5617: 			| OPBTOR
5618: 			{
5619: 			 conprint("|;\n");
5620: 			}
5621: 			| OPBTXOR
5622: 			{
5623: 			 conprint("^|;\n");
5624: 			}
5625: 			| OPBTNOT
5626: 			{
5627: 			 conprint("~;\n");
5628: 			}
5629: 			| OPBTSL
5630: 			{
5631: 			 conprint("<<;\n");
5632: 			}
5633: 			| OPBTSR
5634: 			{
5635: 			 conprint(">>;\n");
5636: 			}
5637: 			| top_command
5638: 			{
5639: 			 conprint("\n;\n");
5640: 			}
5641: 			;
5642: 
5643: 
5644: top_command:		stmt
5645: 			OPQUES
5646: 			{
5647: 			 conprint("? ");
5648: 			}
5649: 			{
5650: 			}
5651: 			stmt
5652: 			{
5653: 			}
5654:  			OPCOLON
5655: 			{
5656: 			 conprint(": ");
5657: 			}
5658: 			stmt
5659: 			{
5660: 			}
5661: 			;
5662: 
5663: st_command:		ST
5664: 			{
5665: 			 conprint("st;\n");
5666: 			}
5667: 			;
5668: 
5669: stack_command:		PUSH
5670: 			{
5671: 			 conprint("push;\n");
5672: 			}
5673: 			| POP
5674: 			{
5675: 			 conprint("pop;\n");
5676: 			}
5677: 			;
5678: 
5679: typeof_command:		TYPEOF RTYPE
5680: 			{
5681: 			 conprint("typeof %s;\n", $2.to_string().get().getString().c_str());
5682: 			}
5683: 			;
5684: 
5685: rm_command:		ATOC
5686: 			{
5687: 			 conprint("atoc;\n");
5688: 			}
5689: 			| ATOSP
5690: 			{
5691: 			 conprint("atosp;\n");
5692: 			}
5693: 			| SPTOA
5694: 			{
5695: 			 conprint("sptoa;\n");
5696: 			}
5697: 			| SWITCH
5698: 			{
5699: 			 conprint("switch;\n");
5700: 			}
5701: 			;
5702: 
5703: crash_command:		CRASH string_expression
5704: 			{
5705: 			 conprint("crash %s;\n", $2.to_string().get().getString().c_str());
5706: 			}
5707: 			;
5708: 
5709: version_command:	VERSION VTYPE
5710: 			{
5711: 			 conprint("version %s;\n", $2.to_string().get().getString().c_str());
5712: 			}
5713: 			;
5714: 
5715: halt_command:		HALT
5716: 			{
5717: 			 conprint("halt;\n");
5718: 			}
5719: 			;
5720: 
5721: modt_command:		MODT RTYPE
5722: 			{
5723: 			 conprint("modt %s;\n", $2.to_string().get().getString().c_str());
5724: 			}
5725: 			;
5726: 
5727: subroutine_command:	RETURN
5728: 			{
5729: 			 conprint("return;\n");
5730: 			}
5731: 			| GOSUB number_expression
5732: 			{
5733: 			 conprint("gosub %g;\n", $2.to_number().get());
5734: 			}
5735: 			| GOSUB STYPE ID
5736: 			{
5737: 			 conprint("gosub %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5738: 			}
5739: 			;
5740: 
5741: register_command:	UNREGISTER STYPE
5742: 			{
5743: 			 conprint("unregister %s;\n", $2.to_string().get().getString().c_str());
5744: 			}
5745: 			| REGISTER STYPE ID
5746: 			{
5747: 			 conprint("register %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5748: 			}
5749: 			| REREGISTER STYPE ID ID
5750: 			{
5751: 			 conprint("reregister %s %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
5752: 				  $4.to_string().get().getString().c_str());
5753: 			}
5754: 			| REGISTER BLANK STYPE number_expression
5755: 			{
5756: 			 conprint("register blank %s %g;\n", $2.to_string().get().getString().c_str(), $3.to_number().get());
5757: 			}
5758: 			;
5759: 
5760: store_command:		STORE RTYPE LTYPE number_expression
5761: 			{
5762: 			 conprint("store %s %s %g;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), $4.to_number().get());
5763: 			}
5764: 			| STORE LTYPE
5765: 			{
5766: 			 conprint("store %s;\n", $2.to_string().get().getString().c_str());
5767: 			}
5768: 			| STORE RTYPE LTYPE
5769: 			{
5770: 			 conprint("store %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5771: 			}
5772: 			| STORE STOREA
5773: 			{
5774: 			 conprint("store storea;\n");
5775: 			}
5776: 			| STORE VTYPE2 STRINGV
5777: 			{
5778: 			 conprint("store %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5779: 			}
5780: 			| STORE RANGE RTYPE2 STRINGV
5781: 			{
5782: 			 conprint("store range %s %s;\n", $3.to_string().get().getString().c_str(), $4.to_string().get().getString().c_str());
5783: 			}
5784: 			| STORE ARRAY STRINGV OPLSQ number_expression OPRSQ
5785: 			{
5786: 			 conprint("store array %s[%g];\n", $3.to_string().get().getString().c_str(), $4.to_number().get());
5787: 			}
5788: 			| STORE ARRAY STRINGV OPLSQ OPRSQ
5789: 			{
5790: 			 conprint("store array %s[];\n", $3.to_string().get().getString().c_str());
5791: 			}
5792: 			;
5793: 
5794: break_command:		BREAK
5795: 			{
5796: 			 conprint("break;\n");
5797: 			}
5798: 			| BREAK ID
5799: 			{
5800: 			 conprint("break %s;\n", $2.to_string().get().getString().c_str());
5801: 			}
5802: 			;
5803: 
5804: address_command:	ADDRESSOF ATYPE ID
5805: 			{
5806: 			 conprint("addressof %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5807: 			}
5808: 			;
5809: 
5810: add2v_command:		ADD2V
5811: 			{
5812: 			 conprint("add2v;\n");
5813: 			}
5814: 			;
5815: 
5816: continue_command:	CONTINUE
5817: 			{
5818: 			 conprint("continue;\n");
5819: 			}
5820: 			;
5821: 
5822: check_command:		CHECK CTYPE TYPE number_expression
5823: 			{
5824: 			 conprint("check %s %s %g;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), $4.to_number().get());
5825: 			}
5826: 			| CHECK CTYPE TYPE boolean_expression
5827: 			{
5828: 			 conprint("check %s %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(),
5829: 				  $4.to_boolean().get().getString().c_str());
5830: 			}
5831: 			| CHECK CTYPE TYPE string_expression
5832: 			{
5833: 			 conprint("check %s %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
5834: 				  $4.to_string().get().getString().c_str());
5835: 			}
5836: 			| CHECK CTYPE number_expression
5837: 			{
5838: 			 conprint("check %s %g;\n", $2.to_string().get().getString().c_str(), $3.to_number().get());
5839: 			}
5840: 			;
5841: 
5842: comment_command:	HCMNT CMTYPE string_expression
5843: 			{
5844: 			 conprint("hcmnt %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5845: 			}
5846: 			;
5847: 
5848: file_command:		FMODE BFMODEC FMODEC
5849: 			{
5850: 			 conprint("fmode %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5851: 			}
5852: 			| FOPEN BFMODEC string_expression
5853: 			{
5854: 			 conprint("fopen %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5855: 			}
5856: 			| FCLOSE BFMODEC
5857: 			{
5858: 			 conprint("fclose %s;\n", $2.to_string().get().getString().c_str());
5859: 			}
5860: 			| FEOF
5861: 			{
5862: 			 conprint("feof;\n");
5863: 			}			
5864: 			;
5865: 
5866: meml_command:		MEML
5867: 			{
5868: 			 conprint("meml;\n");
5869: 			}
5870: 			;
5871: 
5872: pnfasm_command:		PNFASM STRINGV STRINGV STRINGV
5873: 			{
5874: 			 conprint("pnfasm %s %s %s;\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str(), 
5875: 				  $4.to_string().get().getString().c_str());
5876: 			}
5877: 			;
5878: 
5879: array_length_command:	ARRAY STRINGV OPDOT LENGTH
5880: 			{
5881: 			 conprint("array %s.length;\n", $2.to_string().get().getString().c_str());
5882: 			}
5883: 
5884: dup_command:		DUP RTYPE
5885: 			{
5886: 			 conprint("dup %s;\n", $2.to_string().get().getString().c_str());
5887: 			}
5888: 			;
5889: 
5890: function_command:	ID LEFTP actual_function_parameters RIGHTP
5891: 			{
5892: 			 current_param = 0;
5893: 			
5894: 			 bool found = false;
5895: 			 Function f = funcs.get_function($1.to_string().get(), found);
5896: 			 
5897: 			 if (!found)
5898: 			  yyerror("Function not found.");
5899: 
5900: 			 Array<Param> p;
5901: 			 p = f.params();
5902: 			 Array<Param> p2;
5903: 			 p2 = current_func->params();
5904: 
5905: 			 if (p.length() != p2.length())
5906: 			  yyerror("Function parameter mismatch.");
5907: 
5908: 			 delete current_func;
5909: 
5910: 			 for (unsigned long i = 0; i < p.length(); ++i)
5911: 			 {
5912: 			  switch (p[i].param().getType())
5913: 			  {
5914: 			   case TVOID:
5915:   			    conprint("var %s = %s;\n", p[i].name().getString().c_str(), (char *)"0V");
5916: 			    break;
5917: 
5918: 			   case TBOOLEAN:
5919:   			    conprint("var %s = %s;\n", p[i].name().getString().c_str(), (p[i]).param().to_boolean().get().getString().c_str());
5920: 			    break;
5921: 
5922: 			   case TNUMBER:
5923:   			    conprint("var %s = %g;\n", p[i].name().getString().c_str(), (p[i]).param().to_number().get());
5924:    			    break;
5925: 
5926: 			   case TCHARACTER:
5927:   			    conprint("var %s = %c;\n", p[i].name().getString().c_str(), (p[i]).param().to_character().get());
5928: 			    break;
5929: 
5930: 			   case TSTRING:
5931:   			    conprint("var %s = %s;\n", p[i].name().getString().c_str(), (p[i]).param().to_string().get().getString().c_str());
5932: 			    break;
5933: 
5934: 			   default:
5935: 			    yyerror("Invalid function parameter type.");
5936: 			  };
5937: 			 }
5938: 
5939: 			 conprint("gosub sub %s;\n", $1.to_string().get().getString().c_str());
5940: 			}
5941: 			;
5942: 
5943: actual_function_parameters:	{
5944: 				 current_func = new Function();
5945: 				}
5946: 				| opt_expression
5947: 				{
5948: 				 current_func->param(current_param++, $1);
5949: 				}
5950: 				| actual_function_parameters "," expression
5951: 				;
5952: 
5953: opt_expression:			expression
5954: 				{
5955: 				 $$ = $1;
5956: 				}
5957: 				;
5958: 
5959: pp_directive:		PBIN
5960: 			{
5961: 			 conprint("%BIN%\n");
5962: 			}
5963: 			| PPBIN
5964: 			{
5965: 			 conprint("%PBIN%\n");
5966: 			}
5967: 			| PLIB
5968: 			{
5969: 			 conprint("%LIB%\n");
5970: 			}
5971: 			;
5972: 
5973: pp_statement:		PINCLUDE STRINGV 
5974: 			{
5975: 			 conprint("%include %s\n", $2.to_string().get().getString().c_str()); 
5976: 			}
5977: 			| PINCLUDE "<" STRINGV ">" 
5978: 			{ 
5979: 			 conprint("%include <%s>\n", $3.to_string().get().getString().c_str());
5980: 			}
5981: 			| PIMPORT STRINGV 
5982: 			{
5983: 			 conprint("%import %s\n", $2.to_string().get().getString().c_str()); 
5984: 			}
5985: 			| PIMPORT "<" STRINGV ">" 
5986: 			{
5987: 			 conprint("%import <%s>\n", $3.to_string().get().getString().c_str()); 
5988: 			}
5989: 			| PDEFINE STRINGV STRINGV 
5990: 			{
5991: 			 conprint("%define %s %s\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
5992: 			}
5993: 			| PMACRO STRINGV 
5994: 			{
5995: 			 conprint("%macro %s\n", $2.to_string().get().getString().c_str());
5996: 			}
5997: 			| PENDM 
5998: 			{
5999: 			 conprint("%endm\n");
6000: 		 	}
6001: 			| PUNDEF STRINGV 
6002: 			{
6003: 			 conprint("%undef %s\n", $2.to_string().get().getString().c_str());
6004: 			}
6005: 			| PIFDEF STRINGV 
6006: 			{
6007:  			 conprint("%ifdef %s\n", $2.to_string().get().getString().c_str());
6008: 			}
6009: 			| PIFNDEF STRINGV 
6010: 			{
6011: 			 conprint("%ifndef %s\n", $2.to_string().get().getString().c_str());
6012: 			}
6013: 			| PELSE 
6014: 			{
6015: 			 conprint("else\n");
6016: 			}
6017: 			| PENDIF 
6018: 			{
6019: 			 conprint("endif\n");
6020: 			}
6021: 			| PPDATE 
6022: 			{
6023: 			 conprint("%_DATE()\n");
6024: 			}
6025: 			| PPTIME 
6026: 			{
6027: 			 conprint("%_TIME()\n");
6028: 			}
6029: 			| PPLINE 
6030: 			{
6031: 			 conprint("%_LINE()\n");
6032: 			}
6033: 			| PPFILE 
6034: 			{
6035: 			 conprint("%_FILE()\n");
6036: 			}
6037: 			| PPCDATE 
6038: 			{
6039: 			 conprint("%_CDATE()\n");
6040: 			}
6041: 			| PPCTIME 
6042: 			{
6043: 			 conprint("%_CTIME()\n");
6044: 			}			
6045: 			| PPINCLUDE STRINGV 
6046: 			{
6047: 			 conprint("%%include %s\n", $2.to_string().get().getString().c_str()); 
6048: 			}
6049: 			| PPINCLUDE "<" STRINGV ">" 
6050: 			{
6051: 			 conprint("%%include <%s>\n", $3.to_string().get().getString().c_str()); 
6052: 			}
6053: 			| PPIMPORT STRINGV 
6054: 			{
6055: 			 conprint("%%import %s\n", $2.to_string().get().getString().c_str()); 
6056: 			}
6057: 			| PPIMPORT "<" STRINGV ">" 
6058: 			{
6059: 			 conprint("%%import <%s>\n", $3.to_string().get().getString().c_str()); 
6060: 			}
6061: 			| PPDEFINE STRINGV STRINGV 
6062: 			{
6063: 			 conprint("%%define %s %s\n", $2.to_string().get().getString().c_str(), $3.to_string().get().getString().c_str());
6064: 			}
6065: 			| PPMACRO STRINGV 
6066: 			{
6067: 			 conprint("%%macro %s\n", $2.to_string().get().getString().c_str());
6068: 			}
6069: 			| PPENDM 
6070: 			{
6071: 			 conprint("%%endm\n");
6072: 			}
6073: 			| PPUNDEF STRINGV 
6074: 			{
6075: 			 conprint("%%undef %s\n", $2.to_string().get().getString().c_str());
6076: 			}
6077: 			| PPIFDEF STRINGV 
6078: 			{
6079: 			 conprint("%%ifdef %s\n", $2.to_string().get().getString().c_str());
6080: 			}
6081: 			| PPIFNDEF STRINGV 
6082: 			{
6083: 			 conprint("%%ifndef %s\n", $2.to_string().get().getString().c_str());
6084: 			}
6085: 			| PPELSE 
6086: 			{
6087: 			 conprint("%%else\n");
6088: 			}
6089: 			| PPENDIF 
6090: 			{
6091: 			 conprint("%%endif\n");
6092: 			}
6093: 			| PPPDATE 
6094: 			{
6095: 			 conprint("%%_DATE()\n");
6096: 			}
6097: 			| PPPTIME 
6098: 			{
6099: 			 conprint("%%_TIME()\n");
6100: 			}
6101: 			| PPPLINE 
6102: 			{
6103: 			 conprint("%%_LINE()\n");
6104: 			}
6105: 			| PPPFILE 
6106: 			{
6107: 			 conprint("%%_FILE\n");
6108: 			}
6109: 			| PPPCDATE 
6110: 			{
6111: 			 conprint("%%_CDATE()\n");
6112: 			}
6113: 			| PPPCTIME 
6114: 			{
6115: 			 conprint("%%_CTIME()\n");
6116: 			}
6117: 
6118: %%
6119: /* Additional C/C++ Code */
