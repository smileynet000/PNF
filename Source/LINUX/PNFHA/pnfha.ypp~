%{
/* Prologue */
/*
Copyright (C) 2019 Dennis Earl Smiley

This file is part of pnfha.

    pnfha is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    pnfha is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with pnfha.  If not, see <https://www.gnu.org/licenses/>. 
*/
/*
CHANGELOG
=========

5/3/19 Origional a-a-a - 1. The first version.
			 2. Fixed bug.
			 3. Added functions.
			 4. Debugged functions...
			 5. Finished debugging function parameters.
			 6. Added return type specification instructions.
			 7. Debugged...
			 8. Added default parameters...
			 9. Debugged...
			10. Bug fixes...
			11. Debugged...
 		    12. Implemented through segments...
*/
#include <desLib/deslib.hpp>
#include <cmath>
#include <sstream>
#include <typeinfo>

#include "../pnf.hpp"


#define YYSTYPE PNF_Variable
#define YYDEBUG 1


int main(int argc, char ** argv);
void yyerror(char const * c);
String get_extension(String fileName);
String strip_extension(String fileName);
void preprocess(String arg);
int conprint(const char * format, ...);
void movelineno(unsigned long index, unsigned long line);
void sort(Array<unsigned long> & array);
void sort_lines(Array<String> & array);
int yylex();
String strip_quotes(String str);

void actual_parameters(PNF_Variable v);
void actual_parameters2();

FILE * output;

PNF_Type_Enum exptype;


class Var
{
 private:
  String itsname;
  PNF_Variable itsvalue;
  unsigned long itsaddress;

 public:
  Var();
  Var(int v);


  void name(String name);
  String name();

  void value(PNF_Variable value);
  PNF_Variable value();

  void address(unsigned long a);
  unsigned long address();

  Var operator=(const Var & v);
};

Var::Var()
{
 itsname = "";
 itsvalue.to_number().put(0);
 itsaddress = 0;
}

Var::Var(int v)
{
 itsname = "";
 PNF_Number n(v);
 PNF_Variable p(n);
 itsvalue = p;
 itsaddress = 0;
}

void Var::name(String name)
{
 itsname = name;
}

String Var::name()
{
 return itsname;
}

void Var::value(PNF_Variable value)
{
 itsvalue = value;
}

PNF_Variable Var::value()
{
 return itsvalue;
}

void Var::address(unsigned long a)
{
 itsaddress = a;
}

unsigned long Var::address()
{
 return itsaddress;
}

Var Var::operator=(const Var & v)
{
 if (this == &v)
  return *this;

 itsname = v.itsname;
 itsvalue = v.itsvalue;
 itsaddress = v.itsaddress;
  
  
 return (*this);
}


class CLabel
{
 private:
  String itsname;
  unsigned long itsaddress;
  bool itsdeclared;

 public:
  CLabel();
  CLabel(int i);


  void name(String name);
  String name();

  void address(unsigned long a);
  unsigned long address();

  void declared(bool d);
  bool declared();
};

CLabel::CLabel()
{
 itsname = "";
 itsaddress = 0;
}

CLabel::CLabel(int i)
{
 itsname = "";
 itsaddress = i;
 itsdeclared = false;
}

void CLabel::name(String name)
{
 itsname = name;
}

String CLabel::name()
{
 return itsname;
}

void CLabel::address(unsigned long a)
{
 itsaddress = a;
}

unsigned long CLabel::address()
{
 return itsaddress;
}

void CLabel::declared(bool d)
{
 itsdeclared = d;
}

bool CLabel::declared()
{
 return itsdeclared;
}

class CELabel : public CLabel
{
 protected:
  static unsigned long itshevents;
  static unsigned long itsshevents;
  static unsigned long itsevents;
  static unsigned long itsexceptions;
  static unsigned long itsints;

 
 public:
  CELabel();
  CELabel(int i);

  static void inchevents();
  static void dechevents();
  static unsigned long hevents();

  static void incshevents();
  static void decshevents();
  static unsigned long shevents();

  static void incevents();
  static void decevents();
  static unsigned long events();

  static void incexceptions();
  static void decexceptions();
  static unsigned long exceptions();

  static void incints();
  static void decints();
  static unsigned long ints();
};


unsigned long CELabel::itshevents = 0;
unsigned long CELabel::itsshevents = 0;
unsigned long CELabel::itsevents = 0;
unsigned long CELabel::itsexceptions = 0;
unsigned long CELabel::itsints = 0;

CELabel::CELabel() : CLabel()
{

}

CELabel::CELabel(int i) : CLabel(i)
{

}

void CELabel::inchevents()
{
 ++itshevents;
}

void CELabel::dechevents()
{
 --itshevents;
}

unsigned long CELabel::hevents()
{
 return itshevents;
}

void CELabel::incshevents()
{
 ++itsshevents;
}

void CELabel::decshevents()
{
 --itsshevents;
}

unsigned long CELabel::shevents()
{
 return itsshevents;
}

void CELabel::incevents()
{
 ++itsevents;
}

void CELabel::decevents()
{
 --itsevents;
}

unsigned long CELabel::events()
{
 return itsevents;
}

void CELabel::incexceptions()
{
 ++itsexceptions;
}

void CELabel::decexceptions()
{
 --itsexceptions;
}

unsigned long CELabel::exceptions()
{
 return itsexceptions;
}

void CELabel::incints()
{
 ++itsints;
}

void CELabel::decints()
{
 --itsints;
}

unsigned long CELabel::ints()
{
 return itsints;
}

class ASTNode
{
 protected:
  String name;
  Array<String> value;
  unsigned long valuecount;


 public:
  ASTNode(const String n = "");
  ASTNode(char * n);
  ASTNode(const Array<String> v, const String n = "");
	
  ASTNode(ASTNode & n);

  ~ASTNode();

  
  String getName();
  Array<String> getValue();

  void setName(const String n);
  void setValue(const Array<String> v);

  void setNode(const ASTNode n);


  int conprint(const char * format, ...);


  ASTNode operator=(ASTNode & n);
};

ASTNode::ASTNode(const String n)
{
 name = n;
 valuecount = 0;
}

ASTNode::ASTNode(char * n)
{
 name = n;
 valuecount = 0;
}

ASTNode::ASTNode(const Array<String> v, const String n)
{
 name = n;
 value = v;
 valuecount = value.length();
}

ASTNode::ASTNode(ASTNode & n)
{
 name = n.getName();
 
 for (unsigned long i = 0; i < n.value.length(); ++i)
 {
  if (i != 0)
   value.insert();

  value[i] = n.value[i];
 }
}

ASTNode::~ASTNode()
{
 
}

String ASTNode::getName()
{
 return name;
}

Array<String> ASTNode::getValue()
{
 return value;
}

void ASTNode::setName(String n)
{
 name = n;
}

void ASTNode::setValue(Array<String> v)
{
 for (unsigned long i = 0; i < v.length(); ++i)
 {
  if (i != 0)
   value.insert();

  value[i] = v[i];
 }
}

void ASTNode::setNode(ASTNode n)
{
 name = n.getName();
 
 for (unsigned long i = 0; i < n.value.length(); ++i)
 {
  if (i != 0)
   value.insert();

  value[i] = n.value[i];
 }
}

int ASTNode::conprint(const char * format, ...)
{
 char outbuffer[256];


 va_list arg;
 int done = 0;

 va_start(arg, format);

 value.insert();
 done = vsnprintf(outbuffer, 256, format, arg);
 String str = "";
 if (outbuffer != NULL)
  str += outbuffer;
 value[valuecount] = str;
 ++valuecount;

 va_end(arg);


 return done;
}

ASTNode ASTNode::operator=(ASTNode & n)
{
 if (this == &n)
  return *this;

 name = n.name;
 value = n.value;

 return *this; 
}

class ASTTree
{
 protected:
  Array<ASTNode *> nodes;


 public:
  ASTTree();
  ASTTree(ASTTree & t);
  ~ASTTree();


  void add_node(ASTNode & node);
  void remove_node();
  void remove_node(String n);

  ASTNode & getNode(String n);
  ASTNode & getNode(unsigned long offset);
  void setNode(String n, ASTNode & node);
  void setNode(unsigned long offset, ASTNode & node);

  unsigned long nodenumber();
};

ASTTree::ASTTree()
{
 nodes[0] = 0;
}

ASTTree::ASTTree(ASTTree & t)
{
 nodes = t.nodes;
}

ASTTree::~ASTTree()
{
 for (unsigned long i = 1; i < nodenumber(); ++i)
  remove_node();
}

void ASTTree::add_node(ASTNode & node)
{
 if (nodes.length() == 1 && nodes[0] == NULL)
  nodes[0] = new ASTNode (node);
 else
 {
  nodes.insert();
  nodes[nodes.length() - 1] = new ASTNode(node);
 }
}

void ASTTree::remove_node()
{
 if (nodes.length() > 1)
 {
  delete nodes[nodes.length() - 1];
  nodes[nodes.length() - 1] = NULL;
  nodes.remove();
 }
 else if (nodes.length() == 1 && nodes[0] != NULL)
 {
  delete nodes[0];
  nodes[0] = NULL;
 }
 else
 {
  cout << "* ERROR: Called ASTTree::remove_node(), but nothing to do." << endl;
  exit(-1);
 }
}

void ASTTree::remove_node(String n)
{
 for (unsigned long i = 0; i < nodes.length(); ++i)
 {
  if (nodes[i]->getName().getString() == n.getString())
  {
   nodes.remove(i);
  }
 }
}

ASTNode & ASTTree::getNode(String n)
{
 for (unsigned long i = 0; i < nodes.length(); ++i)
 {
  if (nodes[i]->getName().getString() == n.getString())
   return *nodes[i];
 }
}
 
ASTNode & ASTTree::getNode(unsigned long offset)
{
 if (offset < nodes.length())
 {
  return *nodes[offset];
 }
 else if (offset < 0 || offset > nodes.length())
 {
  String errormsg = "Index out of bounds. node = ";
  String temp;
  char temp2[33];
  sprintf(temp2, "%d", offset);
  temp = temp2;
  errormsg += temp;
  cout << "* ERROR: " << errormsg.getString().c_str() << endl;
  exit(-1);
 }
}

void ASTTree::setNode(String n, ASTNode & node)
{
 for (unsigned long i = 0; i < nodes.length(); ++i)
 {
  if (nodes[i]->getName().getString() == n.getString())
  {
   nodes[i] = NULL;
   nodes[i] = new ASTNode(node);
  }
 }
}

void ASTTree::setNode(unsigned long offset, ASTNode & node)
{
 if (offset < nodes.length())
 {
  nodes[offset] = NULL;
  nodes[offset] = new ASTNode(node);
 }
 else
 {
  String errormsg = "Index out of bounds. node = ";
  String temp;
  char temp2[33];
  sprintf(temp2, "%d", offset);
  temp = temp2;
  errormsg += temp;
  cout << "* ERROR: " << errormsg.getString().c_str() << endl;
  exit(-1);
 }
}

unsigned long ASTTree::nodenumber()
{
 return nodes.length();
}


unsigned long scope = 0;
Array< Array<Var> > varTable;
Array<CLabel> labelTable;
Array<CELabel> eventLabelTable;
Array<CLabel> parameterTable;

unsigned long ifcounter = 0;
String ifcounternum = "";
unsigned long ifnest = 0;
unsigned long elsecounter = 0;
unsigned long ifgoto = 0;

Array<String> out;
char outbuffer[256];
unsigned long outcount;

Array<unsigned long> statementoutcount = 0;
unsigned long ifbegin = 0;
unsigned long ifbeginlineno = 0;
unsigned long elsebegin = 0;
unsigned long elsebeginlineno = 0;
unsigned long endifbegin = 0;
Array<unsigned long> statementlineno = 0;


unsigned long varcount = 0;

bool inblock = false;
bool blockinstmt = false;
bool blockinelse = false;
bool blockinif = false;
bool inif = false;


unsigned long switchcounter = 0;
PNF_Type_Enum switchexptype = TVOID;
unsigned long switchcasecounter = 0;
bool inswitch = false;
bool switchfound = false;

bool inloop = false;
unsigned long midloop = 0;
bool loopexpr = false;
bool infor = false;
unsigned short inforfor = 3;

unsigned long whilecounter = 0;

unsigned long dowhilecounter = 0;

unsigned long forcounter = 0;

unsigned long doforcounter = 0;

unsigned long forevercounter = 0;

unsigned long untilcounter = 0;

unsigned long dountilcounter = 0;


bool inloop2 = false;
bool inwhile = false;
bool indowhile = false;
bool infor2 = false;
bool indofor = false;
bool inforever = false;
bool inuntil = false;
bool indountil = false;


bool exptruth = false;


unsigned long topcounter = 0;

bool intop = false;
unsigned long intopfor = 2;


bool breakinforever = false;


unsigned long pnum = 0;
unsigned long pnum3 = 0;
unsigned long pnum4 = 0;
unsigned long pnum5 = 0;
unsigned long rnum = 0;
unsigned long funcnum = 0;


Function_Stack funcstk;
Function * funcptr = NULL;


Array<String> frets;
Array<String> fparams;

Array<String> frets2;
Array<String> fparams2;

Array<String> frets3;
Array<String> fparams3;

Array<String> frets4;
Array<String> fparams4;

Array<String> frets5;
Array<String> fparams5;

Array<String> frets6;
Array<String> fparams6;


PNF_Variable fsaveid;
PNF_Variable fsaveid2;
PNF_Variable fsaveid3;

PNF_Variable saveid3;

PNF_Variable saveexp;
PNF_Variable saveexp2;

unsigned long fsaveindex = 0;
bool saw_12 = false;
unsigned long fsavepindex = 0;
unsigned long fsaveindex2 = 0;

PNF_Variable savenumber;


Array < Array<Var> > funcps;


bool fncdefault = false;


ASTTree tree;
%}
/* Bison Declarations */
%debug


%expect 451
%error-verbose


%left OPINC OPDEC
%left NEG
%left OPNOT OPBTNOT
%left OPAMP
%right OPPOWER OPROOT
%left OPTIMES OPDIV OPMODULUS
%left OPMINUS OPPLUS
%left OPBTSL OPBTSR
%left OPLSS OPLEQU OPGTR OPGEQU OPCMP
%left OPEQU OPNEQU
%left OPBTXOR OPBTOR
%left OPAND
%left OPOR
%right OPEQUAL

%token LEFTP
%token RIGHTP
%token LEFTB
%token RIGHTB

%token VOIDV
%token BOOLEANV
%token NUMBERV
%token CHARACTERV
%token STRINGV

%token SEND
%token COMMA

%token OPEQUAL
%token OPPLUS
%token OPMINUS
%token OPTIMES
%token OPDIV
%token OPMODULUS
%token OPPOWER
%token OPROOT
%token OPINC
%token OPDEC
%token OPAND
%token OPAMP
%token OPOR
%token OPNOT
%token OPQUES
%token OPCOLON
%token OPSUB
%token OPEQU
%token OPNEQU
%token OPGTR
%token OPLSS
%token OPLEQU
%token OPGEQU
%token OPBTOR
%token OPBTXOR
%token OPBTNOT
%token OPBTSL
%token OPBTSR
%token OPSTR
%token OPSTRTIMES
%token OPRUN

%token ID

%token VAR
%token PRINT
%token PRINTLN
%token EPRINT
%token EPRINTLN
%token END
%token ASM
%token TYPE
%token READ
%token LOAD
%token LTYPE
%token GOTO
%token GTYPE
%token ST
%token PUSH
%token POP
%token TOP
%token TYPEOF
%token RTYPE
%token ATOC
%token SWITCH
%token CSWITCH
%token CRASH
%token VERSION
%token VTYPE
%token HALT
%token MODT
%token RETURN
%token GOSUB
%token SUB
%token EVENT
%token STYPE
%token ATYPE
%token CTYPE
%token CMTYPE
%token BFMODEC
%token FMODEC
%token UNREGISTER
%token REGISTER
%token REREGISTER
%token STORE
%token IF
%token ELSE
%token CASE
%token CCASE
%token DEFAULT
%token CDEFAULT
%token BREAK
%token LABEL
%token WHILEC
%token ADDRESSOF
%token ADD2V
%token STOREA
%token DOWHILEC
%token DOFORC
%token FORC
%token FVAR
%token FOREVERC
%token CONTINUE
%token CHECK
%token HCMNT
%token FMODE
%token FOPEN
%token FCLOSE
%token FEOF
%token FPRINT
%token FPRINTLN
%token FREAD
%token MEML
%token ENUM
%token ENUMV
%token VTYPE2
%token RANGE
%token RTYPE2
%token OPDOT
%token RANGEV
%token OPLSQ
%token OPRSQ
%token ARRAY
%token BLANK
%token PNFASM
%token LENGTH
%token DUP
%token THEN
%token ENDIF
%token DONEIF
%token ATOSP
%token SPTOA
%token FUNCTION
%token FUNCDEF
%token FUNCCALL
%token FRET
%token FPARAMETER
%token DEFAULTV
%token DEFAULTV2
%token UNTILC
%token UNLESS
%token DOUNTILC
%token RUNOPOP
%token STRUCT
%token STRUCTVAR
%token UNION
%token UNIONVAR
%token USE
%token OTYPE
%token MODE
%token EXTMODE
%token COPY
%token SEGMENT
%token CETYPE
%token WHILE
%token DOWHILE
%token UNTIL
%token DOUNTIL
%token FOR
%token DOFOR
%token FOREVER


%token PBIN
%token PPBIN
%token PLIB

%token PINCLUDE
%token PIMPORT
%token PDEFINE
%token PMACRO
%token PENDM
%token PUNDEF
%token PIFDEF
%token PIFNDEF
%token PELSE
%token PENDIF
%token PPDATE
%token PPTIME
%token PPLINE
%token PPFILE
%token PPCDATE
%token PPCTIME

%token PPINCLUDE
%token PPIMPORT
%token PPDEFINE
%token PPMACRO
%token PPENDM
%token PPUNDEF
%token PPIFDEF
%token PPIFNDEF
%token PPELSE
%token PPENDIF
%token PPPDATE
%token PPPTIME
%token PPPLINE
%token PPPFILE
%token PPPCDATE
%token PPPCTIME

%%
/* Grammar Rules */

input:	// Empty
	| input line { ASTNode start("START"); tree.add_node(start); }
	;

line:	{
	 ASTNode line("line");
         tree.add_node(line);
	}
	"\n"
	| statement
	| error		{ yyerrok; }
	;

statement:	{
		 ASTNode statement("statement");
  		 tree.add_node(statement);
		}
		stmt
		| statement COMMA stmt
		;

stmt:		control_statement { statementoutcount.insert(); statementoutcount[statementoutcount.length() - 1] = outcount - 1; 
		    	                    statementlineno.insert(); statementlineno[statementlineno.length() - 1] = yylineno; }
		| SEND { conprint("VOID TVOID 0V\n"); statementoutcount.insert(); 
                         statementoutcount[statementoutcount.length() - 1] = outcount - 1; statementlineno.insert(); statementlineno[statementlineno.length() - 1]                          = yylineno; }
		| expression_statement  { statementoutcount.insert(); statementoutcount[statementoutcount.length() - 1] = outcount - 1;
					  statementlineno.insert(); statementlineno[statementlineno.length() - 1] = yylineno; }
		| declaration_statement  { statementoutcount.insert(); statementoutcount[statementoutcount.length() - 1] = outcount - 1;
					   statementlineno.insert(); statementlineno[statementlineno.length() - 1] = yylineno; }
		| label_statement  { statementoutcount.insert(); statementoutcount[statementoutcount.length() - 1] = outcount - 1;
				     statementlineno.insert(); statementlineno[statementlineno.length() - 1] = yylineno; }
		| command_statement  { statementoutcount.insert(); statementoutcount[statementoutcount.length() - 1] = outcount - 1;
				       statementlineno.insert(); statementlineno[statementlineno.length() - 1] = yylineno; }
		| statement_block  { statementoutcount.insert(); statementoutcount[statementoutcount.length() - 1] = outcount - 1;
				     statementlineno.insert(); statementlineno[statementlineno.length() - 1] = yylineno; inblock = true;
				   }
		| pp_directive
		| pp_statement
		;

expression_statement:	expression SEND
			{
			 ASTNode expression_statement("expression_statement");
			 tree.add_node(expression_statement);
			}
			;

declaration_statement:	declaration SEND
			{
			 ASTNode declaration_statement("declaration_statement");
			 tree.add_node(declaration_statement);
			}
			;

command_statement:	command SEND
			{
			 ASTNode command_statement("command_statement");
			 tree.add_node(command_statement);
			}
			;

label_statement:	ID OPCOLON 
			{
			 ASTNode label_statement("label_statement");

			 bool declared = false;
			 String str;
			 for (unsigned long i = 0; i < labelTable.length(); ++i)
			 {
			  str = labelTable[i].name();
			  if ($1.to_string().get().getString() == labelTable[i].name().getString())
			  {
			   declared = true;
			   if (labelTable[i].declared() == true)
 			   {
			    str += " implemented already.";
			    yyerror(str.getString().c_str());
			   }
			   else
			   {
                            labelTable[i].declared(true);
			    conprint("LBL TVOID 0V\n");
			   }
			  }
			 }

			 if (!declared)
			 {	  
			  str += " not declared.";
			  yyerror(str.getString().c_str());
			 }

			 tree.add_node(label_statement);
			}
			| SUB ID OPCOLON
			{
			 ASTNode label_statement("label_statement");

			 conprint("LBL TVOID 0V\n");

			 tree.add_node(label_statement);
			}
			| EVENT ID OPCOLON
			{
			 ASTNode label_statement("label_statement");

			 conprint("ELBL TVOID 0V\n");

			 tree.add_node(label_statement);
			}
			;

control_statement:	if_statement
			{
			 ASTNode control_statement("control_statement");
			
			 tree.add_node(control_statement);
			}
			| unless_statement
			{
			 ASTNode control_statement("control_statement");
			
			 tree.add_node(control_statement);
			}
			| switch_statement
			{
			 ASTNode control_statement("control_statement");
			 tree.add_node(control_statement);
			}
			| loop_statement
			{
			 ASTNode control_statement("control_statement");

			 breakinforever = false;

			 tree.add_node(control_statement);
			}
			;

if_statement:		IF LEFTP stmt RIGHTP
			{
			 ASTNode if_statementp1("if_statementp1");

			 tree.add_node(if_statementp1);		
			}
			THEN			
			{			 
			 ASTNode if_statementp2("if_statementp2");
			
			 conprint("IF TVOID 0V\n");
			 conprint("IFBEGIN TVOID 0V\n");

			 tree.add_node(if_statementp2);
			}
			stmt
			{
			 ASTNode if_statementp3("if_statementp3");
			 // Code for if will be inserted here...
			
			 tree.add_node(if_statementp3);
			}
			ENDIF
			{
			 conprint("IFEND TVOID 0V\n");
			 conprint("ENDIF TVOID 0V\n");
			}
			opt_else
			{
			 ASTNode if_statementp6("if_statementp6");

			 tree.add_node(if_statementp6);
			}
			eif			
			{
			 ASTNode if_statementp4("if_statementp4");

			 conprint("EIF TVOID 0V\n");

			 tree.add_node(if_statementp4);
			}
			;

unless_statement:	UNLESS LEFTP stmt RIGHTP
			{
			 ASTNode if_statementp1("if_statementp1");

			 conprint("NOT TVOID 0V\n");	

			 tree.add_node(if_statementp1);		
			}
			THEN			
			{			 
			 ASTNode if_statementp2("if_statementp2");
		
			 conprint("IF TVOID 0V\n");
			 conprint("IFBEGIN TVOID 0V\n");

			 tree.add_node(if_statementp2);
			}
			stmt
			{
			 ASTNode if_statementp3("if_statementp3");
			 // Code for if will be inserted here...
			
			 tree.add_node(if_statementp3);
			}
			ENDIF
			{
			 conprint("IFEND TVOID 0V\n");
			 conprint("ENDIF TVOID 0V\n");
			}
			opt_else
			{
			 ASTNode if_statementp6("if_statementp6");

			 tree.add_node(if_statementp6);
			}
			eif			
			{
			 ASTNode if_statementp4("if_statementp4");

			 conprint("EIF TVOID 0V\n");

			 tree.add_node(if_statementp4);
			}
			;

opt_else:	| ELSE
			{
			 ASTNode if_statementp5("if_statementp5");

			 conprint("IFELSE TVOID 0V\n");
			 conprint("IFBEGIN TVOID 0V\n");

			 // Code for else will be inserted here if exists...
			 tree.add_node(if_statementp5);
			}
			stmt
			ENDIF
			{
			 ASTNode if_statementp7("if_statementp7");

			 conprint("IFEND TVOID 0V\n");
			 conprint("ENDIFELSE TVOID 0V\n");

			 tree.add_node(if_statementp7);
			}
			;

eif:			DONEIF
			;
			
switch_statement:	SWITCH LEFTP expression RIGHTP LEFTB
			{
			 ASTNode switch_statementp1("switch_statementp1");

			 switchfound = true;
			 ++switchcounter;
			 switchcasecounter = 0;
			 inswitch = true;

			 switch (exptype)
			 {
			  case TBOOLEAN:
			   conprint("ALOAD TBOOLEAN %s\n", $3.to_string().get().getString().c_str());
			   switchexptype = TBOOLEAN;
     			   break;

			  case TNUMBER:
			   conprint("ALOAD TNUMBER %s\n", $3.to_string().get().getString().c_str());
			   switchexptype = TNUMBER;
			   break;

			  case TCHARACTER:
			   conprint("ALOAD TCHARACTER %s\n", $3.to_string().get().getString().c_str());
			   switchexptype = TCHARACTER;
			   break;

			  case TSTRING:
			   conprint("ALOAD TSTRING %s\n", $3.to_string().get().getString().c_str());
			   switchexptype = TSTRING;
			   break;

			  default:
			   yyerror("Invalid switch statement.");
			 }
			 conprint("SWITCH2 TVOID 0V\n");
                         conprint("SWBEGIN TVOID 0V\n");

			 tree.add_node(switch_statementp1);
			}
			case_statements
			{
			 ASTNode switch_statementp2("switch_statementp2");


			 switch (exptype)
                         {
			  case TBOOLEAN:
                           switchexptype = TBOOLEAN;
			   break;

                          case TNUMBER:
			   switchexptype = TNUMBER;
			   break;

			  case TCHARACTER:
			   switchexptype = TCHARACTER;
			   break;

			  case TSTRING:			   
			   switchexptype = TSTRING;
			   break;

			  default:
			   yyerror("Invalid switch statement.");
			 };

			 tree.add_node(switch_statementp2);
			}
			opt_default_statement
			{
			 ASTNode switch_statementp3("switch_statementp3");

			 tree.add_node(switch_statementp3);
			}
			{

			}
			RIGHTB
			{
			 ASTNode switch_statementp4("switch_statementp4");

			 conprint("SWEND TVOID 0V\n");

			 tree.add_node(switch_statementp4);
			}
			| CSWITCH LEFTP stmt RIGHTP
			{
			 ASTNode switch_statementp1("switch_statementp1");

			 switchfound = true;
			 ++switchcounter;
			 switchcasecounter = 0;
			 inswitch = true;

			 conprint("SWITCH2 TVOID 0V\n");
			 conprint("SWBEGIN TVOID 0V\n");

			 tree.add_node(switch_statementp1);
			}
			LEFTB
			case_statements2
			{
			 ASTNode switch_statementp2("switch_statementp2");
			 
			 tree.add_node(switch_statementp2);
			}
			opt_default_statement2
			{
			 ASTNode switch_statementp3("switch_statementp3");
			 tree.add_node(switch_statementp3);
			}
			RIGHTB
			{
			 ASTNode switch_statementp4("switch_statementp4");

			 conprint("SWEND TVOID 0V\n");

			 tree.add_node(switch_statementp4);
			}
			;

case_statements:	{
			 ASTNode case_statements("case_statements");
			 tree.add_node(case_statements);
			}
			case_statement
			| case_statements case_statement
			;

case_statement:		CASE expression
			{
			 ASTNode case_statement("case_statement");

			 ++switchcasecounter;

			 if (switchexptype != exptype)
			  yyerror("Non-Matching Switch Expression");

			 
 			 switch (exptype)
			 {
			  case TBOOLEAN:
			   conprint("SWCASE TBOOLEAN %s\n", $2.to_boolean().get().getString().c_str());
			   conprint ("SWCBEGIN TVOID 0V\n");
			   break;

			  case TNUMBER:
			   conprint("SWCASE TNUMBER %g\n", $2.to_number().get());
			   conprint ("SWCBEGIN TVOID 0V\n");
			   break;

			  case TCHARACTER:
			   conprint("SWCASE TCHARCTER %c\n", $2.to_character().get());
			   conprint ("SWCBEGIN TVOID 0V\n");
			   break;

		 	  case TSTRING:
			   conprint("SWCASE TSTRING %s\n", $2.to_string().get().getString().c_str());
			   conprint ("SWCBEGIN TVOID 0V\n");
			   break;

			  default:
			   yyerror("Invalid switch statement.");
			};

			 tree.add_node(case_statement);
			}
			OPCOLON stmt
			{
			 conprint("SWCEND TVOID 0V\n");
			}
			;

opt_default_statement:	| DEFAULT OPCOLON
			{
			 conprint("SWDEFAULT TVOID 0V\n");
			 conprint("SWCBEGIN TVOID 0V\n");
			}
			stmt
			{
			 conprint("SWCEND TVOID 0V\n");
			}
			;

case_statements2:	{
			 ASTNode case_statements("case_statements");
			 tree.add_node(case_statements);
			}
			case_statement2
			| case_statements2 case_statement2
			;

case_statement2:	CCASE expression
			{
			 ASTNode case_statementp1("case_statement");

			 ++switchcasecounter;

			 switch (exptype)
			 {
			  case TBOOLEAN:
			   conprint("SWCASE TBOOLEAN %s\n", $2.to_boolean().get().getString().c_str());
			   break;

			  case TNUMBER:
			   conprint("SWCASE TNUMBER %g\n", $2.to_number().get());
			   break;

			  case TCHARACTER:
			   conprint("SWCASE TCHARACTER %c\n", $2.to_character().get());
			   break;

			  case TSTRING:
			   conprint("SWCASE TSTRING %s\n", $2.to_string().get().getString().c_str());
			   break;

			  default:
			   yyerror("Invalid type.");
			 }
			 conprint("SWCBEGIN TVOID 0V\n");
			
			 tree.add_node(case_statementp1);
			}
			OPCOLON
			{
			 ASTNode case_statementp2("case_statementp2");

			 tree.add_node(case_statementp2);
			}
			stmt
			{
			 ASTNode case_statementp3("case_statementp3");

			 conprint("SWCEND TVOID 0V\n");

			 tree.add_node(case_statementp3);
			}
			;

opt_default_statement2:	| CDEFAULT OPCOLON
			{
			 conprint("SWDEFAULT TVOID 0V\n");
			 conprint("SWCBEGIN TVOID 0V\n");
			}
			stmt
			{
			 conprint("SWCEND TVOID 0V\n");
			}
			;

loop_statement:
            {
			 loopexpr = true;
			 inloop2 = true;
			}
            while_loop
			{
			 ASTNode loop_statement("loop_statement");
			 tree.add_node(loop_statement);
			}
			| whileb_loop
			{
			 ASTNode loop_statement("loop_statement");
			 tree.add_node(loop_statement);
			}
			until_loop
			{
			 ASTNode loop_statement("loop_statement");
			 tree.add_node(loop_statement);
			}
			| untilb_loop
			{
			 ASTNode loop_statement("loop_statement");
			 tree.add_node(loop_statement);
			}
			| for_loop
			{
			 ASTNode loop_statement("loop_statement");
			 tree.add_node(loop_statement);
			}
			| forb_loop
			{
			 ASTNode loop_statement("loop_statement");
			 tree.add_node(loop_statement);
			}
			| forever_loop
			{
			 ASTNode loop_statement("loop_statement");
			 
			 loopexpr = false;
			 inloop = true;		 

			 tree.add_node(loop_statement);
			}
			{
			 inloop2 = false;
			 inwhile = false;
			 indowhile = false;
			 infor2 = false;
			 indofor = false;
			 inforever = false;
			}
			;

while_loop:	WHILEC LEFTP
			{
			 ASTNode while_loopp1("while_loopp1");

			 inwhile = true;
			 ++whilecounter;
			 conprint("LBL TSTRING \"while_test_%u\"\n", whilecounter);

			 tree.add_node(while_loopp1);
			}
			stmt
			{
			 ASTNode while_loopp2("while_loopp2");

			 tree.add_node(while_loopp2);
			}
			RIGHTP
			{
			 ASTNode while_loopp3("while_loopp3");

			 conprint("CGOTOL TSTRING \"while_body_%u\"\n", whilecounter);
			 conprint("GOTOL TSTRING \"while_end_%u\"\n", whilecounter);

			 conprint("LBL TSTRING \"while_body_%u\"\n", whilecounter);

			 tree.add_node(while_loopp3);
			}
			stmt
			{
			 ASTNode while_loopp4("while_loopp4");

			 conprint("GOTOL TSTRING \"while_test_%u\"\n", whilecounter);
			 conprint("LBL TSTRING \"while_end_%u\"\n", whilecounter);

			 tree.add_node(while_loopp4);
			}
            WHILE LEFTP
			{
			 ASTNode while_loopp1("while_loopp1");

			 inwhile = true;
			 ++whilecounter;
            
             conprint("LOOP TVOID 0V\n");

			 tree.add_node(while_loopp1);
			}
			stmt
			{
			 ASTNode while_loopp2("while_loopp2");

			 tree.add_node(while_loopp2);
			}
			RIGHTP
			{
			 ASTNode while_loopp3("while_loopp3");

			 conprint("ELOOP TVOID 0V\n");
             conprint("WHILE TVOID 0V\n")
             
             conprint("WHILEB TVOID 0V\n");

			 tree.add_node(while_loopp3);
			}
			stmt
			{
			 ASTNode while_loopp4("while_loopp4");

			 conprint("WHILEE TVOID 0V\n");

			 tree.add_node(while_loopp4);
			}
			;

whilebc_loop:		{
			 ASTNode do_while_loopp1("do_while_loopp1");

			 indowhile = true;
			 ++dowhilecounter;
			 conprint("LBL TSTRING \"do_while_body_%u\"\n", dowhilecounter);

			 tree.add_node(do_while_loopp1);
			}
			DOWHILEC
			{
			 ASTNode do_while_loopp2("do_while_loopp2");

			 tree.add_node(do_while_loopp2);
			}
			stmt
			WHILEC 
			{
			 ASTNode do_while_loopp3("do_while_loopp3");

			 conprint("LBL TSTRING \"do_while_test_%u\"\n", dowhilecounter);

			 tree.add_node(do_while_loopp3);
			}
			LEFTP
			{
			 ASTNode do_while_loopp4("do_while_loopp4");

			 tree.add_node(do_while_loopp4);
			}
			stmt
			{
			 ASTNode do_while_loopp5("do_while_loopp5");

			 conprint("CGOTOL TSTRING \"do_while_body_%u\"\n", dowhilecounter);
			 conprint("GOTOL TSTRING \"do_while_end_%u\"\n", dowhilecounter);

			 tree.add_node(do_while_loopp5);
			}
			RIGHTP
			{
			 ASTNode do_while_loopp6("do_while_loopp6");

			 conprint("LBL TSTRING \"do_while_end_%u\"\n", dowhilecounter);

			 tree.add_node(do_while_loopp6);
			}
			;

untilc_loop: UNTILC LEFTP
			{
			 ASTNode until_loopp1("until_loopp1");

			 inuntil = true;
			 ++untilcounter;
			 conprint("LBL TSTRING \"until_test_%u\"\n", untilcounter);

			 tree.add_node(until_loopp1);
			}
			stmt
			{
			 ASTNode until_loopp2("until_loopp2");

			 tree.add_node(until_loopp2);
			}
			RIGHTP
			{
			 ASTNode until_loopp3("until_loopp3");


			 conprint("NOT TVOID 0V\n");

			 conprint("CGOTOL TSTRING \"until_body_%u\"\n", untilcounter);
			 conprint("GOTOL TSTRING \"until_end_%u\"\n", untilcounter);

			 conprint("LBL TSTRING \"until_body_%u\"\n", untilcounter);

			 tree.add_node(until_loopp3);
			}
			stmt
			{
			 ASTNode until_loopp4("until_loopp4");

			 conprint("GOTOL TSTRING \"until_test_%u\"\n", untilcounter);
			 conprint("LBL TSTRING \"until_end_%u\"\n", untilcounter);

			 tree.add_node(until_loopp4);
			}
			;

untilbc_loop:		{
			 ASTNode do_until_loopp1("do_until_loopp1");

			 indountil = true;
			 ++dountilcounter;
			 conprint("LBL TSTRING \"do_until_body_%u\"\n", dountilcounter);

			 tree.add_node(do_until_loopp1);
			}
			DOUNTILC
			{
			 ASTNode do_until_loopp2("do_until_loopp2");

			 tree.add_node(do_until_loopp2);
			}
			stmt
			UNTILC 
			{
			 ASTNode do_until_loopp3("do_until_loopp3");

			 conprint("LBL TSTRING \"do_until_test_%u\"\n", dountilcounter);

			 tree.add_node(do_until_loopp3);
			}
			LEFTP
			{
			 ASTNode do_until_loopp4("do_until_loopp4");

			 tree.add_node(do_until_loopp4);
			}
			stmt
			{
			 ASTNode do_until_loopp5("do_until_loopp5");

			 conprint("CGOTOL TSTRING \"do_until_body_%u\"\n", dountilcounter);
			 conprint("GOTOL TSTRING \"do_until_end_%u\"\n", dountilcounter);

			 tree.add_node(do_until_loopp5);
			}
			RIGHTP
			{
			 ASTNode do_until_loopp6("do_until_loopp6");

			 conprint("NOT TVOID 0V\n");

			 conprint("LBL TSTRING \"do_until_end_%u\"\n", dountilcounter);

			 tree.add_node(do_until_loopp6);
			}
			;

forc_loop:		{
			 infor = true;
			}
			FORC LEFTP
			{
			 ASTNode for_loopp1("for_loopp1");

			 infor2 = true;
			 ++forcounter;
			 conprint("LBL TSTRING \"for_initialization_%u\"\n", forcounter);

			 tree.add_node(for_loopp1);
			}
			stmt SEND	// Initialization
			{
			 ASTNode for_loopp2("for_loopp2");

			 conprint("LBL TSTRING \"for_condition_%u\"\n", forcounter);

			 tree.add_node(for_loopp2);
			}
			stmt SEND	// Condition
			{
			 ASTNode for_loopp3("for_loopp3");

			 conprint("CGOTOL TSTRING \"for_body_%u\"\n", forcounter);
			 conprint("GOTOL TSTRING \"for_end_%u\"\n", forcounter);
			 conprint("LBL TSTRING \"for_increment_statement_%u\"\n", forcounter);

			 tree.add_node(for_loopp3);
			}
			stmt		// Increment Statement
			{
			 ASTNode for_loopp4("for_loopp4");

			 conprint("GOTOL TSTRING \"for_condition_%u\"\n", forcounter);
			 conprint("LBL TSTRING \"for_body_%u\"\n", forcounter);

			 tree.add_node(for_loopp4);
			}
			RIGHTP stmt
			{
			 ASTNode for_loopp5("for_loopp5");

			 conprint("GOTOL TSTRING \"for_increment_statement_%u\"\n", forcounter);
			 conprint("LBL TSTRING \"for_end_%u\"\n", forcounter);

			 tree.add_node(for_loopp5);
			}
			;

forbc_loop:		DOFORC
			{
			 ASTNode forb_loopp1("forb_loopp1");

			 indofor = true;
			 infor = true;
			 ++doforcounter;

			 conprint("GOTOL TSTRING \"dofor_initialization_%u\"\n", doforcounter);
			 conprint("LBL TSTRING \"dofor_body_%u\"\n", doforcounter);

			 tree.add_node(forb_loopp1);
			}
			stmt
			{
			 ASTNode forb_loopp2("forb_loopp2");

			 conprint("GOTOL TSTRING \"dofor_increment_statement_%u\"\n", doforcounter);
			 conprint("LBL TSTRING \"dofor_initialization_%u\"\n", doforcounter);

			 tree.add_node(forb_loopp2);
			}
			FORC LEFTP
			{
			 ASTNode forb_loopp3("forb_loopp3");

			 tree.add_node(forb_loopp3);
			}
			stmt SEND	// Initialization
			{
			 ASTNode forb_loopp4("forb_loopp4");

			 conprint("GOTOL TSTRING \"dofor_body_%u\"\n", doforcounter);
			 conprint("LBL TSTRING \"dofor_condition_%u\"\n", doforcounter);

			 tree.add_node(forb_loopp4);
			}
			stmt SEND	// Condition
			{
			 ASTNode forb_loopp5("forb_loopp5");

			 conprint("CGOTOL TSTRING \"dofor_body_%u\"\n", doforcounter);
			 conprint("GOTOL TSTRING \"dofor_end_%u\"\n", doforcounter);
			 conprint("LBL TSTRING \"dofor_increment_statement_%u\"\n", doforcounter);

			 tree.add_node(forb_loopp5);
			}
			stmt		// Increment Statement
			{
			 ASTNode forb_loopp6("forb_loopp6");
			 tree.add_node(forb_loopp6);
			}
			RIGHTP
			{
			 ASTNode forb_loopp7("forb_loopp7");

			 conprint("GOTOL TSTRING \"dofor_condition_%u\"\n", doforcounter);
			 conprint("LBL TSTRING \"dofor_end_%u\"\n", doforcounter);

			 tree.add_node(forb_loopp7);
			}
			;

foreverc_loop:		FOREVERC 
			{
			 ASTNode forever_loopp1("forever_loopp1");

			 breakinforever = true;
			 ++forevercounter;
			 conprint("LBL TSTRING \"forever_%u\"\n", forevercounter);

			 tree.add_node(forever_loopp1);			
			}
			stmt
			{
			 ASTNode forever_loopp2("forever_loopp2");

			 conprint("GOTOL TSTRING \"forever_%u\"\n", forevercounter);
			 conprint("LBL TSTRING \"forever_end_%u\"\n", forevercounter);

			 tree.add_node(forever_loopp2);			
			}
            ;

while_loop: ;

whileb_loop: ;

until_loop: ;

untilb_loop: ;

for_loop: ;

forb_loop: ;

forever_loop: ;

statement_block:	LEFTB statements RIGHTB { PNF_String str($2.to_string().get()); $$.put(str); ASTNode statement_block("statement_block"); 
                                                  tree.add_node(statement_block); }
			;

statements:		statement
			{
			 ASTNode statements("statements");
			 tree.add_node(statements);
			}
			| statement statements
			{
			 ASTNode statements("statements");
			 tree.add_node(statements);
			}
			;

expression:	void_expression { $$ = $1; exptype = TVOID; ASTNode expression("expression"); tree.add_node(expression); }
		| boolean_expression
		{
		 $$ = $1;
		 savenumber = $$;
		 exptype = TBOOLEAN;
		 ASTNode expression("expression");
		 tree.add_node(expression);
		}
		| number_expression { $$ = $1; savenumber = $$; exptype = TNUMBER; ASTNode expression("expression");
                                      tree.add_node(expression); }
		| character_expression { $$ = $1; savenumber = $$; exptype = TCHARACTER; ASTNode expression("expression"); 
                                         tree.add_node(expression); }
		| string_expression { $$ = $1; savenumber = (PNF_String)strip_quotes($$.to_string().get()); exptype = TSTRING; ASTNode expression("expression"); 
                                      tree.add_node(expression); }
		| id_expression { $$ = $1; exptype = (PNF_Type_Enum)$$.getType(); ASTNode expression("expression"); 
                                  tree.add_node(expression); }
		| relational_expression { $$ = $1; exptype = TBOOLEAN; ASTNode expression("expression"); 
					  tree.add_node(expression); }
		| mixed_expression { $$ = $1; exptype = (PNF_Type_Enum)$$.getType(); ASTNode expression("expression"); 
				     tree.add_node(expression); }
		| function_expression { $$ = $1; exptype = (PNF_Type_Enum)$$.getType(); ASTNode expression("expression"); tree.add_node(expression); 		
		}
		;

void_expression:
			VOIDV
			{
			 PNF_String s("0V");
			 $$.put(s);

			 exptruth = false;

			 ASTNode void_expression("void_expression");
			 tree.add_node(void_expression);
			}
			| LEFTP void_expression RIGHTP { $$ = $2; }
			;

boolean_expression:	BOOLEANV 
			{ 
			 $$ = $1;

			 String str = $$.to_boolean().get();
			 if (str == "true")
			  exptruth = true;
                         else if (str == "false")
                          exptruth = false;
			 else
			  exptruth = true;

			
			 ASTNode boolean_expression("boolean_expression"); 
			 tree.add_node(boolean_expression);
			}
			| OPNOT boolean_expression 
			{
			 bool b;
			 String str = $2.to_boolean().get();

			 if (str.getString() == "true")
			  b = true;
			 else
			  b = false;

			 PNF_Boolean b2(b);
			 b2.opnot();
			 $$.put(b2);
			}
			| boolean_expression OPAND boolean_expression
			{
			 String bl = $3.to_boolean().get();
			 bool b;
			
			 if (bl.getString() == "true")
			  b = true;
			 else if (bl.getString() == "false")
			  b = false;
			 else
			  b = false;

			 PNF_Boolean b2($1.to_boolean());
			 b2.opand(b);
			 $$.put(b2);
			}
			| boolean_expression OPOR boolean_expression
			{
			 String bl = $3.to_boolean().get();
			 bool b;
			
			 if (bl.getString() == "true")
			  b = true;
			 else if (bl.getString() == "false")
			  b = false;
			 else
			  b = false;

			 PNF_Boolean b2($1.to_boolean());
			 b2.opor(b);
			 $$.put(b2);
			}
			| LEFTP boolean_expression RIGHTP { $$ = $2; }
			;

number_expression:	NUMBERV
			{ 
			 $$ = $1;

			 double d = $$.to_number().get();

                         if (d == 0)
                          exptruth = false;
                         else
                          exptruth = true;

			 ASTNode number_expression("number_expression");
                         tree.add_node(number_expression);
			}
			| number_expression OPPLUS number_expression	
			{
			 double d = $2.to_number().get();
			 $1.to_number().add(d);
			 $$ = $1;
			}
			| number_expression OPMINUS number_expression
			{
			 double d = $2.to_number().get();
			 $1.to_number().sub(d);
			 $$ = $1;
			}
			| number_expression OPTIMES number_expression
			{
			 double d = $2.to_number().get();
			 $1.to_number().mul(d);
			 $$ = $1;
			}
			| number_expression OPDIV number_expression
			{
			 double d = $2.to_number().get();
			 $1.to_number().div(d);
			 $$ = $1;
			}
			| number_expression OPMODULUS number_expression
			{
			 double d = $2.to_number().get();
			 $1.to_number().mod(d);
			 $$ = $1;
			}
			| OPMINUS number_expression	%prec NEG	
			{
			 char * str = "-";
			 strcat(str, $2.to_string().get().getString().c_str());
			 PNF_String s(str);
			 PNF_Variable v(s);
			 $$ = v;
			}
			| number_expression OPPOWER number_expression	
			{
			 double d = $3.to_number().get();
			 PNF_Number n($1.to_number());
			 n.pow(d);
			 $$.put(n);
			}
			| number_expression OPROOT number_expression
			{
			 double d = $1.to_number().get();
			 PNF_Number n($3.to_number());
			 n.root(d);			 
			 $$.put(n);
			}
			| OPINC number_expression
			{
			 PNF_Number n($2.to_number().get());
			 n.inc(1);
			 $$.put(n);
			}
			| number_expression OPINC
			{
			 PNF_Number n($1.to_number().get());
			 $$.put(n);
			 n.inc(1);
			}
			| OPDEC number_expression
			{
			 PNF_Number n($2.to_number().get());
			 n.dec(1);
			 $$.put(n);
			}
			| number_expression OPDEC
			{
			 PNF_Number n($1.to_number().get());
			 $$.put(n);
			 n.dec(1);
			}
			| number_expression OPAMP number_expression
			{
			 int d1 = (int)$1.to_number().get();
			 int d2 = (int)$3.to_number().get();
			 int d3 = d1 & d2;
			 PNF_Number n(d3);
			 $$.put(n);
			}
			| number_expression OPBTOR number_expression
			{
			 int d1 = (int)$1.to_number().get();
			 int d2 = (int)$3.to_number().get();
			 int d3 = d1 | d2;
			 PNF_Number n(d3);
			 $$.put(n);
			}

			| number_expression OPBTXOR number_expression
			{
			 int d1 = (int)$1.to_number().get();
			 int d2 = (int)$3.to_number().get();
			 int d3 = d1 ^ d2;
			 PNF_Number n(d3);
			 $$.put(n);
			}
			| OPBTNOT number_expression
			{
			 int d = (int)$2.to_number().get();
			 d = ~d;
			 PNF_Number n(d);
			 $$.put(n);
			}
			| number_expression OPBTSL number_expression
			{
			 int d1 = (int)$1.to_number().get();
			 int d2 = (int)$3.to_number().get();
			 int d3 = d1 << d2;
			 PNF_Number n(d3);
			 $$.put(n);
			}
			| number_expression OPBTSR number_expression
			{
			 int d1 = (int)$1.to_number().get();
			 int d2 = (int)$3.to_number().get();
			 int d3 = d1 >> d2;
			 PNF_Number n(d3);
			 $$.put(n);
			}
			| LEFTP number_expression RIGHTP		{ $$ = $2; }
			;

character_expression:
			CHARACTERV
			{
			 $$ = $1;
			 char ch = $$.to_character().get();

			 if (ch == '\0')
                          exptruth = false;
			 else
			  exptruth = true;

			 ASTNode character_expression("character_expression"); 
			 tree.add_node(character_expression);
			}
			| character_expression OPPLUS character_expression	
			{
			 char d = $1.to_character().get();
			 PNF_Character c(d);
			 c.add($3.to_character().get());
			 $$.put(c);
			}
			| character_expression OPMINUS character_expression
			{
			 char d = $1.to_character().get();
			 PNF_Character c(d);
			 c.sub($3.to_character().get());
			 $$.put(c);
			}
			| character_expression OPTIMES character_expression
			{
			 char d = $1.to_character().get();
			 PNF_Character c(d);
			 c.mul($3.to_character().get());
			 $$.put(c);
			}
			| character_expression OPDIV character_expression
			{
			 char d = $1.to_character().get();
			 PNF_Character c(d);
			 c.div($3.to_character().get());
			 $$.put(c);			}
			| character_expression OPMODULUS character_expression
			{
			 char d = $1.to_character().get();
			 PNF_Character c(d);
			 c.mod($3.to_character().get());
			 $$.put(c);
			}
			| character_expression OPPOWER character_expression	
			{
			 char d = $3.to_character().get();
			 PNF_Character c($1.to_character());
			 c.pow(d);
			 $$.put(c);
			}
			| character_expression OPROOT character_expression
			{
			 char d = $1.to_character().get();
			 PNF_Character c($3.to_character());
			 c.root(d);
			 $$.put(c);
			}
			| OPINC character_expression
			{
			 PNF_Character n($2.to_character().get());
			 n.inc(1);
			 $$.put(n);
			}
			| character_expression OPINC
			{
			 PNF_Character n($1.to_character().get());
			 $$.put(n);
			 n.inc(1);
			}
			| OPDEC character_expression
			{
			 PNF_Character n($2.to_character().get());
			 n.dec(1);
			 $$.put(n);
			}
			| character_expression OPDEC
			{
			 PNF_Character n($1.to_character().get());
			 $$.put(n);
			 n.dec(1);
			}
			| LEFTP character_expression RIGHTP	{ $$ = $2; }
			;

string_expression:
			STRINGV
			{
			 $$ = $1;
		
			 String str = $$.to_string().get();
			 if (str == "")
			  exptruth = false;
			 else
			  exptruth = true;

			 ASTNode string_expression("string_expression"); 
			 tree.add_node(string_expression);
			}
			| string_expression OPPLUS string_expression
			{
			 String d = $1.to_string().get();
			 PNF_String s(d);
			 s.add($3.to_string().get());

			 String str = s.get();
			 String str2 = "";
	   	         for (unsigned long i = 0, j = 0; i < str.length(); ++i)
			 {
			  if (str[i] == '\"')
			   continue;
			  else
			  {
			   str2 += str[i];
			   ++j;
			  }
			 }

			 String str3 = '\"';
			 str3 += str2;
			 str3 += '\"';
			 s.put(str3);
			 $$.put(s);
			}
			| OPSTR string_expression
			{
			 String str = $2.to_string().get();
			 String str2 = "\"" + str + "\"";
			 PNF_String s(str2);
			 $$.put(s);
			}
			| LEFTP string_expression RIGHTP	{ $$ = $2; }
			;

id_expression:
			ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   $$ = varTable[scope][i].value();

			   switch ($$.getType())
			   {
			    case TVOID:
			     exptruth = false;
			     break;

			    case TBOOLEAN:
			    {
			     String str = $$.to_boolean().get();
			     if (str == "true")
			      exptruth = true;
			     else if (str == "false")
			      exptruth = false;
			     else
			      exptruth = true;
			     }
			     break;

			    case TNUMBER:
			    {
			     double d = $$.to_number().get();
			     if (d == 0)
			      exptruth = false;
			     else
			      exptruth = true;
			     }
			     break;

			    case TCHARACTER:
			    {
			     char ch = $$.to_character().get();
			     if (ch == '\0')
			      exptruth = false;
			     else
			      exptruth = true;
			     }
			     break;

			    case TSTRING:
			    {
			     String str = $$.to_string().get();
			     if (str == "")
			      exptruth = false;
			     else
			      exptruth = true;
			     }
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $1.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }

			 ASTNode id_expression("id_expression");
			 tree.add_node(id_expression);
			}			
			| OPAMP id_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   PNF_Number n(varTable[scope][i].address());
			   $$.put(n);
			  }
			 }

			 if (!declared)
			 {
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if (strcmp(labelTable[i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
			   {
			    declared = true;
			    PNF_Number n(labelTable[i].address());
			    $$.put(n);
			   }
 			  }


			  if (!declared)
			  {
			   for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			   {
			    if (strcmp(eventLabelTable[i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
			    {
			     declared = true;
			     PNF_Number n(eventLabelTable[i].address());
			     $$.put(n);
			    }
  			   }
			  }
			 }
			}
			| OPNOT id_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   PNF_Boolean b;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b.put(true);
			   else
			   {
			    bool b2;
			    String str = varTable[scope][i].value().to_boolean().get();
			    if (str.getString() == "true")
			     b2 = true;
			    else if (str.getString() == "false")
			     b2 = false;
			    else
			     b2 = true;

			    b.put(b2);
			   }

			   b.opnot();
			   $$.put(b);
			   varTable[scope][i].value(b);			  }
			 }

			 if (!declared)
			 {
			  String str = $2.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
			}
			| id_expression OPAND id_expression
			{
			 bool declared1 = false;
			 bool declared2 = false;
  		   	 PNF_Boolean b1;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared1 = true;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b1.put(true);
			   else
			   {
			    bool b2;
			    String str = varTable[scope][i].value().to_boolean().get();
			    if (str.getString() == "true")
			     b2 = true;
			    else if (str.getString() == "false")
			     b2 = false;
			    else
			     b2 = true;

			    b1.put(b2);
			   }
			  }
			 }

			 if (!declared1)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }

			 PNF_Boolean b3;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared2 = true;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b3.put(true);
			   else
			   {
			    bool b4;
			    String str = varTable[scope][i].value().to_boolean().get();
			    if (str.getString() == "true")
			     b4 = true;
			    else if (str.getString() == "false")
			     b4 = false;
			    else
			     b4 = true;
			    b3.put(b4);
			   }
			  }
			 }

			 if (!declared2)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }

			 bool b5;
			 String str = b3.get();
			 if (str.getString() == "true")
			  b5 = true;
			 else if (str.getString() == "false")
			  b5 = false;
			 else
			  b5 = true;

			 b1.opand(b5);
			 $$.put(b1);
			}
			| id_expression OPOR id_expression
			{
			 bool declared1 = false;
			 bool declared2 = false;
			 PNF_Boolean b1;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared1 = true;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b1.put(true);
			   else
			   {
			    String str = varTable[scope][i].value().to_boolean().get();
			    bool b2;
			    if (str.getString() == "true")
			     b2 = true;
			    else if (str.getString() == "false")
			     b2 = false;
			    else
			     b2 = true;

			    b1.put(b2);
			   }
			  }
			 }

			 if (!declared1)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }


   		         PNF_Boolean b3;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared2 = true;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b3.put(true);
			   else
			   {
			    String str = varTable[scope][i].value().to_boolean().get();
			    bool b4;
			    if (str.getString() == "true")
			     b4 = true;
			    else if (str.getString() == "false")
			     b4 = false;
			    else
			     b4 = true;

			    b3.put(b4);
			   }
			  }
			 }

			 if (!declared2)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }

			 bool b5;
			 String str = b3.get();
			 if (str.getString() == "true")
			  b5 = true;
			 else if (str.getString() == "false")
			  b5 = false;
			 else
			  b5 = true;

			 b1.opor(b5);
			 $$.put(b1);
			}
			| id_expression OPPLUS id_expression	
			{
			 switch ($1.getType())
			 {
			  case TNUMBER:
			  {
			   if ($3.getType() != TNUMBER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   double d = $3.to_number().get();
			   PNF_Number n($1.to_number());
			   n.add(d);
			   $$.put(n);
			  }
			  break;

		          case TCHARACTER:
			  {
			   if ($3.getType() != TCHARACTER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   char d = $3.to_character().get();
			   PNF_Character n($1.to_character());
			   n.add(d);
			   $$.put(n);
			  }
			  break;

			  case TSTRING:
			  {
			   if ($3.getType() != TSTRING)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }

			   String str = $3.to_string().get();
			   String str2 = "";
			   for (unsigned long i = 0; i < str.length(); ++i)
 			   {
			    if (str[i] == '\"')
			     continue;
			    str2 += str[i];
			   }

			   str = $1.to_string().get();
			   String str3 = "";
			   for (unsigned long i = 0; i < str.length(); ++i)
 			   {
			    if (str[i] == '\"')
			     continue;
			    str3 += str[i];
			   }

			   PNF_String s(str3);
			   s.add(str2);

			   str = s.get();
			   String str4 = "\"";
			   for (unsigned long i = 0; i < str.length(); ++i)
 			   {			    
			    str4 += str[i];
			   }
			   str4 += "\"";
			   s.put(str4);

			   $$.put(s);
			  }
			  break;

			  default:
			   PNF_Number n(0);
			   $$.put(n);
			   break;
			 }
			}
			| id_expression OPMINUS id_expression
			{
			 switch ($1.getType())
			 {
			  case TNUMBER:
			  {
			   if ($3.getType() != TNUMBER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   double d = $3.to_number().get();
			   PNF_Number n($1.to_number());
			   n.sub(d);
			   $$.put(n);
			  }
			  break;

		          case TCHARACTER:
			  {
			   if ($3.getType() != TCHARACTER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   char d = $3.to_character().get();
			   PNF_Character n($1.to_character());
			   n.sub(d);
			   $$.put(n);
			  }
			  break;			

			  default:
			   PNF_Number n(0);
			   $$.put(n);
			   break;
			 }
			}
			| id_expression OPTIMES id_expression
			{
			 switch ($1.getType())
			 {
			  case TNUMBER:
			  {
			   if ($3.getType() != TNUMBER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   double d = $3.to_number().get();
			   PNF_Number n($1.to_number());
			   n.mul(d);
			   $$.put(n);
			  }
			  break;

		          case TCHARACTER:
			  {
			   if ($3.getType() != TCHARACTER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   char d = $3.to_character().get();
			   PNF_Character n($1.to_character());
			   n.mul(d);
			   $$.put(n);
			  }
			  break;				

			  default:
			   PNF_Number n(0);
			   $$.put(n);
			   break;
			 }
			}
			| id_expression OPDIV id_expression
			{
			 switch ($1.getType())
			 {
			  case TNUMBER:
			  {
			   if ($3.getType() != TNUMBER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   double d = $3.to_number().get();
			   PNF_Number n($1.to_number());
			   n.div(d);
			   $$.put(n);
			  }
			  break;

		          case TCHARACTER:
			  {
			   if ($3.getType() != TCHARACTER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   char d = $3.to_character().get();
			   PNF_Character n($1.to_character());
			   n.div(d);
			   $$.put(n);
			  }
			  break;			

			  default:
			   PNF_Number n(0);
			   $$.put(n);
			   break;
			 }
			}
			| id_expression OPMODULUS id_expression
			{
			 switch ($1.getType())
			 {
			  case TNUMBER:
			  {
			   if ($3.getType() != TNUMBER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   double d = $3.to_number().get();
			   PNF_Number n($1.to_number());
			   n.mod(d);
			   $$.put(n);
			  }
			  break;

		          case TCHARACTER:
			  {
			   if ($3.getType() != TCHARACTER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   char d = $3.to_character().get();
			   PNF_Character n($1.to_character());
			   n.mod(d);
			   $$.put(n);
			  }
			  break;	

			  default:
			   PNF_Number n(0);
			   $$.put(n);
			   break;
			 }
			}
			| OPMINUS id_expression	%prec NEG	
			{
			 if ($2.getType() != TNUMBER)
			 {
			  PNF_Number n(0);
                          $$.put(n);
			 }
			 double d = $2.to_number().get();
			 d = -d;
			 PNF_Number n(d);
			 PNF_Variable v(n);
			 $$ = v;
			}
			| id_expression OPPOWER id_expression	
			{
			 switch ($1.getType())
			 {
			  case TNUMBER:
			  {
			   if ($3.getType() != TNUMBER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   double d = $3.to_number().get();
			   PNF_Number n($1.to_number());
			   n.pow(d);
			   $$.put(n);
			  }
			  break;

		          case TCHARACTER:
			  {
			   if ($3.getType() != TCHARACTER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   char d = $3.to_character().get();
			   PNF_Character n($1.to_character());
			   n.pow(d);
			   $$.put(n);
			  }
			  break;	

			  default:
			   PNF_Number n(0);
			   $$.put(n);
			   break;
			 }
			}
			| id_expression OPROOT id_expression
			{
			 switch ($1.getType())
			 {
			  case TNUMBER:
			  {
			   if ($3.getType() != TNUMBER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   double d = $1.to_number().get();
			   PNF_Number n($3.to_number());
			   n.root(d);
			   $$.put(n);
			  }
			  break;

		          case TCHARACTER:
			  {
			   if ($3.getType() != TCHARACTER)
			   {
			    PNF_Number n(0);
			    $$.put(n);
			   }
			   char d = $1.to_character().get();
			   PNF_Character n($3.to_character());
			   n.root(d);
			   $$.put(n);
			  }
			  break;	

			  default:
			   PNF_Number n(0);
			   $$.put(n);
			   break;
			 }
			}
			| OPINC id_expression
			{
			 switch ($2.getType())
			 {
			  case TNUMBER:
			  {
			   PNF_Number n($2.to_number().get());
			   n.inc(1);
			   $$.put(n);
			  }
			  break;

			  case TCHARACTER:
			  {
			   PNF_Character c($2.to_character().get());
			   c.inc(1);
			   $$.put(c);
			  }
	                  break;
			  
			  default:
			  {
			   PNF_Number n(0);
                           $$.put(n);
			  }
			  break;
			 }
			}
			| id_expression OPINC
			{
			 switch ($2.getType())
			 {
			  case TNUMBER:
			  {
			   PNF_Number n($2.to_number().get());
			   $$.put(n);
			   n.inc(1);
			  }
			  break;

			  case TCHARACTER:
			  {
			   PNF_Character c($2.to_character().get());
			   $$.put(c);
			   c.inc(1);
			  }
	                  break;
			  
			  default:
			  {
			   PNF_Number n(0);
                           $$.put(n);
			  }
			  break;
			 }
			}
			| OPDEC id_expression
			{
			 switch ($2.getType())
			 {
			  case TNUMBER:
			  {
			   PNF_Number n($2.to_number().get());
			   n.dec(1);
			   $$.put(n);
			  }
			  break;

			  case TCHARACTER:
			  {
			   PNF_Character c($2.to_character().get());
			   c.dec(1);
			   $$.put(c);
			  }
	                  break;
			  
			  default:
			  {
			   PNF_Number n(0);
                           $$.put(n);
			  }
			  break;
			 }
			}
			| id_expression OPDEC
			{
			 switch ($2.getType())
			 {
			  case TNUMBER:
			  {
			   PNF_Number n($2.to_number().get());
			   $$.put(n);
			   n.dec(1);
			  }
			  break;

			  case TCHARACTER:
			  {
			   PNF_Character c($2.to_character().get());
			   $$.put(c);
			   c.dec(1);
			  }
	                  break;
			  
			  default:
			  {
			   PNF_Number n(0);
                           $$.put(n);
			  }
			  break;
			 }
			}
			| LEFTP id_expression RIGHTP { $$ = $1; }
			;

relational_expression:	number_expression OPEQU number_expression
			{
			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b = d1 == d2;
			 PNF_Boolean b2(b);
			 $$.put(b2);

			 ASTNode relational_expression("relational_expression");
			 tree.add_node(relational_expression);
			}
			| number_expression OPNEQU number_expression
			{
			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b = d1 != d2;
			 PNF_Boolean b2(b);
			 $$.put(b2);

			 ASTNode relational_expression("relational_expression");
			 tree.add_node(relational_expression);
			}
			| number_expression OPLSS number_expression
			{
			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b = d1 < d2;
			 PNF_Boolean b2(b);
			 $$.put(b2);

			 ASTNode relational_expression("relational_expression");
			 tree.add_node(relational_expression);
			}
			| number_expression OPGTR number_expression
			{
			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b = d1 > d2;
			 PNF_Boolean b2(b);
			 $$.put(b2);

			 ASTNode relational_expression("relational_expression");
			 tree.add_node(relational_expression);
			}
			| number_expression OPLEQU number_expression
			{
			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b = d1 <= d2;
			 PNF_Boolean b2(b);
			 $$.put(b2);

			 ASTNode relational_expression("relational_expression");
			 tree.add_node(relational_expression);
			}
			| number_expression OPGEQU number_expression
			{
			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b = d1 >= d2;
			 PNF_Boolean b2(b);
			 $$.put(b2);

			 ASTNode relational_expression("relational_expression");
			 tree.add_node(relational_expression);
			}
			{
			 String str = $$.to_boolean().get();
			 if (str == "false")
			  exptruth = false;
			 else if (str == "true")
			  exptruth = true;
			 else
			  exptruth = true;
			}
			| number_expression OPCMP number_expression
			{
			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b1 = d1 < d2;
			 bool b2 = d1 == d2;
			 bool b3 = d1 > d2;
			 double answer = 0;

			 if (b1)
			  answer = -1;
			 else if (b2)
			  answer = 0;
			 else if (b3)
			  answer = 1;
			 else
			 {
			  yyerror((char *)"Bad CMP.");
			  exit(-1);
			 }
			 PNF_Number n(answer);
			 $$.put(n);
			}
			;

mixed_expression:	
			LEFTP mixed_expression RIGHTP { $$ = $2; }
			| ID OPAND boolean_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   PNF_Boolean b1;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b1.put(true);
			   else
			   {
			    bool b2;
			    String str = varTable[scope][i].value().to_boolean().get();
			    if (str.getString() == "true")
			     b2 = true;
			    else if (str.getString() == "false")
			     b2 = false;
			    else
			     b2 = true;

			    b1.put(b2);
			   }

			   bool b2;
			   String str = $3.to_boolean().get();
			   if (str.getString() == "true")
			    b2 = true;
			   else if (str.getString() == "false")
			    b2 = false;
			   else
			    b2 = true;

			   b1.opand(b2);

			   $$.put(b1);
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| boolean_expression OPAND ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   PNF_Boolean b1;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b1.put(true);
			   else
			   {
			    bool b2;
			    String str = varTable[scope][i].value().to_boolean().get();
			    if (str.getString() == "true")
			     b2 = true;
			    else if (str.getString() == "false")
			     b2 = false;
			    else
			     b2 = true;

			    b1.put(b2);
			   }

			   bool b2;
			   String str = $1.to_boolean().get();
			   if (str.getString() == "true")
			    b2 = true;
			   else if (str.getString() == "false")
			    b2 = false;
			   else
			    b2 = true;

			   b1.opand(b2);

			   $$.put(b1);
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPOR boolean_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   PNF_Boolean b1;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b1.put(true);
			   else
			   {
			    bool b2;
			    String str = varTable[scope][i].value().to_boolean().get();
			    if (str.getString() == "true")
                             b2 = true;
			    else if (str.getString() == "false")
			     b2 = false;
			    else
			     b2 = true;

			    b1.put(b2);
			   }

			   bool b2;
			   String str = $3.to_boolean().get();
			   if (str.getString() == "true")
			    b2 = true;
			   else if (str.getString() == "false")
			    b2 = false;
			   else
			    b2 = true;

			   b1.opor(b2);

			   $$.put(b1);
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| boolean_expression OPOR ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   PNF_Boolean b1;
			   if (varTable[scope][i].value().getType() != TBOOLEAN)
             		    b1.put(true);
			   else
			   {
			    bool b2;
			    String str = varTable[scope][i].value().to_boolean().get();
			    if (str.getString() == "true")
			     b2 = true;
			    else if (str.getString() == "false")
			     b2 = false;
			    else
			     b2 = true;

			    b1.put(b2);
			   }

			   bool b2;
			   String str = $1.to_boolean().get();
			   if (str.getString() == "true")
			    b2 = true;
			   else if (str.getString() == "false")
			    b2 = false;
			   else
			    b2 = true;

			   b1.opor(b2);

			   $$.put(b1);
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPPLUS number_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $3.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.add(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPMINUS number_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $3.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.sub(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPTIMES number_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $3.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.mul(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPDIV number_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $3.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.div(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPPOWER number_expression	
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $3.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.pow(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPROOT number_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = varTable[scope][i].value().to_number().get();
			     PNF_Number n($3.to_number());
			     n.root(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPPLUS ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $1.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.add(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPMINUS ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $1.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.sub(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPTIMES ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $1.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.mul(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPDIV ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $1.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.div(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPPOWER ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = $1.to_number().get();
			     PNF_Number n(varTable[scope][i].value().to_number());
			     n.pow(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPROOT ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     double d = varTable[scope][i].value().to_number().get();
			     PNF_Number n($1.to_number());
			     n.root(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPPLUS character_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($3.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $3.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.add(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPMINUS character_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($3.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $3.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.sub(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPTIMES character_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($3.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $3.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.mul(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPDIV character_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($3.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $3.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.div(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPPOWER character_expression	
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($3.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $3.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.pow(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPROOT character_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($3.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = varTable[scope][i].value().to_character().get();
			     PNF_Character n($3.to_character());
			     n.root(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| character_expression OPPLUS ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($1.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $1.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.add(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| character_expression OPMINUS ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($1.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $1.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.sub(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| character_expression OPTIMES ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($1.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $1.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.mul(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| character_expression OPDIV ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($1.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $1.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.div(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| character_expression OPPOWER ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($1.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = $1.to_character().get();
			     PNF_Character n(varTable[scope][i].value().to_character());
			     n.pow(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| character_expression OPROOT ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TCHARACTER:
			    {
			     if ($1.getType() != TCHARACTER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }
			     char d = varTable[scope][i].value().to_character().get();
			     PNF_Character n($1.to_character());
			     n.root(d);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPPLUS string_expression
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TSTRING:
			    {
			     if ($3.getType() != TSTRING)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     String d = $3.to_string().get();
			     String str = "";
			     for (unsigned is = 0; is < d.length(); ++is)
			     {
			      if (d[is] == '\"')
			       continue;
			      str += d[is];
			     }
			     String str2 = varTable[scope][i].value().to_string().get();
			     String str3 = "";
			     for (unsigned is = 0; is < str2.length(); ++is)
			     {
			      if (str2[is] == '\"')
			       continue;
			      str3 += str2[is];
			     }

			     PNF_String n(str3);
			     n.add(str);
	  		     String str4 = "\"";
			     str4 += n.get();
			     str4 += "\"";
			     PNF_String n2(str4);
			     $$.put(n2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| string_expression OPPLUS ID
			{
                         bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TSTRING:
			    {
			     if ($1.getType() != TSTRING)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     String d = $1.to_string().get();
			     String str = "";
			     for (unsigned is = 0; is < d.length(); ++is)
			     {
			      if (d[is] == '\"')
			       continue;
			      str += d[is];
			     }
			     String str2 = varTable[scope][i].value().to_string().get();
			     String str3 = "";
			     for (unsigned is = 0; is < str2.length(); ++is)
			     {
			      if (str2[is] == '\"')
			       continue;
			      str3 += str2[is];
			     }

			     PNF_String n(str3);
			     n.add(str);
	  		     String str4 = "\"";
			     str4 += n.get();
			     str4 += "\"";
			     PNF_String n2(str4);
			     $$.put(n2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPEQU ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $1.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 == d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPNEQU ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $1.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 != d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPLSS ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $1.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 < d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPGTR ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $1.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 > d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPLEQU ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $1.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 <= d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPGEQU ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $1.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 >= d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPEQU number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $3.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 == d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPNEQU number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $3.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 != d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPLSS number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $3.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 < d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPGTR number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $3.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 > d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPLEQU number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $3.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 <= d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPGEQU number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     double d1 = $3.to_number().get();
			     double d2 = varTable[scope][i].value().to_number().get();
			     bool b = d1 >= d2;
			     PNF_Boolean b2(b);
			     $$.put(b2);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPAMP number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$3.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 & d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPBTOR number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$3.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 | d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPBTXOR number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$3.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 ^ d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPAMP ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$1.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 & d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPBTOR ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$1.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 | d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPBTXOR ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$1.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 ^ d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| OPBTNOT ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     int d1 = (int)varTable[scope][i].value().to_number().get();
			     int d2 = ~d1;
			     PNF_Number n(d1);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $2.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPBTSL number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$3.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 << d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| ID OPBTSR number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($3.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$3.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 >> d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPBTSL ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$1.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 << d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPBTSR ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			     int d1 = (int)$1.to_number().get();
			     int d2 = (int)varTable[scope][i].value().to_number().get();
			     int d3 = d1 >> d2;
			     PNF_Number n(d3);
			     $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }
	 		 ASTNode mixed_expression("mixed_expression"); 
		         tree.add_node(mixed_expression);
			}
			| number_expression OPCMP ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b1 = d1 < d2;
			 bool b2 = d1 == d2;
			 bool b3 = d1 > d2;
			 double answer = 0;

			 if (b1)
			  answer = -1;
			 else if (b2)
			  answer = 0;
			 else if (b3)
			  answer = 1;
			 else
			 {
			  yyerror((char *)"Bad CMP.");
			  exit(-1);
			 }
			 PNF_Number n(answer);
			 $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }			
			}
			| ID OPCMP number_expression
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			 {
  			  if (strcmp(varTable[scope][i].name().getString().c_str(), $1.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   	
			   switch (varTable[scope][i].value().getType())
			   {
  			    case TNUMBER:
			    {
			     if ($1.getType() != TNUMBER)
			     {
			      PNF_Number n(0);
			      $$.put(n);
			     }


			 double d1 = $1.to_number().get();
			 double d2 = $3.to_number().get();
			 bool b1 = d1 < d2;
			 bool b2 = d1 == d2;
			 bool b3 = d1 > d2;
			 double answer = 0;

			 if (b1)
			  answer = -1;
			 else if (b2)
			  answer = 0;
			 else if (b3)
			  answer = 1;
			 else
			 {
			  yyerror((char *)"Bad CMP.");
			  exit(-1);
			 }
			 PNF_Number n(answer);
			 $$.put(n);
			    }
			    break;

    		            default:
			     PNF_Number n(0);
			     $$.put(n);
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  String str = $1.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }			
			}
			;

function_expression:	function_command
			{
			 $$ = $1;
			}
			| LEFTP function_expression RIGHTP
			{
			 $$ = $2;
			}
			;

function_command:	FUNCCALL OPCOLON NUMBERV
			{
			 funcnum = (unsigned long)$3.to_number().get();
			}
			LEFTP vars3 RIGHTP ID
			{
			 fsaveid2 = $8;

			 conprint("FCALL TSTRING \"%s\"\n", $8.to_string().get().getString().c_str());
			 conprint("FCPARAMS TVOID 0V\n");
			}
			LEFTP
			{
			 pnum3 = 0;
			 pnum4 = 0;
			}
			actual_function_parameters
			{		 
			 unsigned long index = funcstk.find(fsaveid2.to_string().get(), frets3, fparams3);
			 if (index == -1)
			 {
			  fparams3.remove();
			  index = funcstk.find(fsaveid2.to_string().get(), frets3, fparams3);
			  if (index == -1)
			  {
			   fparams3.remove();
			   index = funcstk.find(fsaveid2.to_string().get(), frets3, fparams3);
			   if (index == -1)
			   {
			    yyerror("Function not found.");
			    exit(-1);
			   }
			  }
			 }
			 fsaveindex = index;
			}
			{
			 if(fncdefault)
			 {
			  fncdefault = false;
			  conprint("FNCDEFAULT2 TVOID 0V\n");
			 }

			 conprint("FECPARAMS TVOID 0V\n");
			}
			RIGHTP
			{
			 conprint("FECALL TVOID 0V\n");
			}
			nothing
			{
			 for (unsigned long i = frets3.length() - 1; i > 0; --i)
			  frets3.remove();
			 frets3[0] = "";

			 for (unsigned long i = fparams3.length() - 1; i > 0; --i)
			  fparams3.remove();
			 fparams3[0] = "";
			}
			;

actual_function_parameters:	dv
				{

				}
				;


dv:				opt_expressions
				{
				 $$ = $1;				 

				 for (unsigned long i = 0; i < funcps[funcps.length() - 1].length(); ++i)
			 	 {
			 	  funcps[funcps.length() - 1][i].value($1);
			 	 }
				}				
				;

opt_expressions:		opt_expression
				{
 				 switch (exptype)
				 {
				  case TVOID:
				  {
				  }
				  break;
				  
				  case TBOOLEAN:
				  {
				   fparams3[fparams3.length() - 1] = "BOOLEAN";
			           fparams3.insert();
				  }
				  break;

				  case TNUMBER:
				  {
				   fparams3[fparams3.length() - 1] = "NUMBER";
			           fparams3.insert();			   
				  }
				  break;

				  case TCHARACTER:
				  {
				   fparams3[fparams3.length() - 1] = "CHARACTER";
			           fparams3.insert();
				  }
				  break;

				  case TSTRING:
				  {
				   fparams3[fparams3.length() - 1] = "STRING";
			           fparams3.insert();
				  }
				  break;

				  default:
				   yyerror("Invalid type.");
				 }

				 ++pnum4;
				}
				| opt_expressions COMMA opt_expression
				{
 				 switch (exptype)
				 {
				  case TVOID:
				  {
				  }
				  break;
				  
				  case TBOOLEAN:
				  {
				   fparams3[fparams3.length() - 1] = "BOOLEAN";
			           fparams3.insert();
				  }
				  break;

				  case TNUMBER:
				  {
				   fparams3[fparams3.length() - 1] = "NUMBER";
			           fparams3.insert();			   
				  }
				  break;

				  case TCHARACTER:
				  {
				   fparams3[fparams3.length() - 1] = "CHARACTER";
			           fparams3.insert();
				  }
				  break;

				  case TSTRING:
				  {
				   fparams3[fparams3.length() - 1] = "STRING";
			           fparams3.insert();
				  }
				  break;

				  default:
				   yyerror("Invalid type.");
				 }

				 ++pnum4;
				}
				| DEFAULTV2 OPCOLON TYPE
				{
				 PNF_Type_Enum t;
			  	 if ($3.to_string().get() == "void")
				  t = TVOID;
				 else if ($3.to_string().get() == "boolean")
				  t = TBOOLEAN;
				 else if ($3.to_string().get() == "number")
				  t = TNUMBER;
				 else if ($3.to_string().get() == "character")
				  t = TCHARACTER;
				 else if ($3.to_string().get() == "string")
				  t = TSTRING;
				 else
				 {
				  yyerror("Invalid Type.");
				  exit(-1);
				 }

				 switch (t)
				 {
				  case TVOID:
				  {
				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TVOID 0V\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");				   
				  }
				  break;
				  
				  case TBOOLEAN:
				  {
				   fparams3[fparams3.length() - 1] = "BOOLEAN";
			           fparams3.insert();

				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TBOOLEAN false\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");		
				  }
				  break;

				  case TNUMBER:
				  {
				   fparams3[fparams3.length() - 1] = "NUMBER";
			           fparams3.insert();

				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TNUMBER 0\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");		   
				  }
				  break;

				  case TCHARACTER:
				  {
				   fparams3[fparams3.length() - 1] = "CHARACTER";
			           fparams3.insert();

				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TCHARACTER ''\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");
				  }
				  break;

				  case TSTRING:
				  {
				   fparams3[fparams3.length() - 1] = "STRING";
			           fparams3.insert();

				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TSTRING \"\" 0\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");
				  }
				  break;

				  default:
				   yyerror("Invalid type.");
				 }


 				 switch (exptype)
				 {
				  case TVOID:
				  {
				  }
				  break;
				  
				  case TBOOLEAN:
				  {
				   fparams3[fparams3.length() - 1] = "BOOLEAN";
			           fparams3.insert();
				  }
				  break;

				  case TNUMBER:
				  {
				   fparams3[fparams3.length() - 1] = "NUMBER";
			           fparams3.insert();			   
				  }
				  break;

				  case TCHARACTER:
				  {
				   fparams3[fparams3.length() - 1] = "CHARACTER";
			           fparams3.insert();
				  }
				  break;

				  case TSTRING:
				  {
				   fparams3[fparams3.length() - 1] = "STRING";
			           fparams3.insert();
				  }
				  break;

				  default:
				   yyerror("Invalid type.");
				 }


				 ++pnum3;
				 ++pnum4;
				}
				| opt_expressions COMMA DEFAULTV2 OPCOLON TYPE
				{
				 PNF_Type_Enum t;
			  	 if ($5.to_string().get() == "void")
				  t = TVOID;
				 else if ($5.to_string().get() == "boolean")
				  t = TBOOLEAN;
				 else if ($5.to_string().get() == "number")
				  t = TNUMBER;
				 else if ($5.to_string().get() == "character")
				  t = TCHARACTER;
				 else if ($5.to_string().get() == "string")
				  t = TSTRING;
				 else
				 {
				  yyerror("Invalid Type.");
				  exit(-1);
				 }

				 switch (t)
				 {
				  case TVOID:
				  {
				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TVOID 0V\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");				   
				  }
				  break;
				  
				  case TBOOLEAN:
				  {
				   fparams3[fparams3.length() - 1] = "BOOLEAN";
			           fparams3.insert();

				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TBOOLEAN false\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");		
				  }
				  break;

				  case TNUMBER:
				  {
				   fparams3[fparams3.length() - 1] = "NUMBER";
			           fparams3.insert();

				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TNUMBER 0\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");		   
				  }
				  break;

				  case TCHARACTER:
				  {
				   fparams3[fparams3.length() - 1] = "CHARACTER";
			           fparams3.insert();

				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TCHARACTER ''\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");
				  }
				  break;

				  case TSTRING:
				  {
				   fparams3[fparams3.length() - 1] = "STRING";
			           fparams3.insert();

				   conprint("ALOAD TNUMBER %d\n", funcnum);
				   conprint("PNUM TNUMBER %d\n", pnum3);
				   conprint("PARAMF TSTRING \"\" 0\n");
				   conprint("FNCDEFAULTSYNC TVOID 0V\n");
				  }
				  break;

				  default:
				   yyerror("Invalid type.");
				 }


 				 switch (exptype)
				 {
				  case TVOID:
				  {
				  }
				  break;
				  
				  case TBOOLEAN:
				  {
				   fparams3[fparams3.length() - 1] = "BOOLEAN";
			           fparams3.insert();
				  }
				  break;

				  case TNUMBER:
				  {
				   fparams3[fparams3.length() - 1] = "NUMBER";
			           fparams3.insert();			   
				  }
				  break;

				  case TCHARACTER:
				  {
				   fparams3[fparams3.length() - 1] = "CHARACTER";
			           fparams3.insert();
				  }
				  break;

				  case TSTRING:
				  {
				   fparams3[fparams3.length() - 1] = "STRING";
			           fparams3.insert();
				  }
				  break;

				  default:
				   yyerror("Invalid type.");
				 }


				 ++pnum3;
				 ++pnum4;
				}
				;

actual_function_parameters2:	opt_expression2
				{
				 $$ = $1
				 saveexp2 = $$;
				}
				nothing
				{
			 	 unsigned long index = funcstk.find(fsaveid3.to_string().get(), frets4, fparams4);
				 if (index == -1)
				 {
				  yyerror("Function not found.");
				  exit(-1);
				 }
				 fsaveindex2 = index;
				}			
				;

opt_expression:			expression
				{
				 $$ = $1;
				 saveexp = savenumber;


				 conprint("FNCLOAD TNUMBER %d\n", funcnum);

				 conprint("PNUM TNUMBER %d\n", pnum4);
				 switch (exptype)
				 {
				  case TVOID:
				   conprint("FNCSPARAM TVOID 0V\n");
				   break;

				  case TBOOLEAN:
				   conprint("FNCSPARAM TBOOLEAN 0V\n");
				   break;

				  case TNUMBER:
				   conprint("FNCSPARAM TNUMBER 0V\n");
				   break;

				  case TCHARACTER:
				   conprint("FNCSPARAM TCHARACTER 0V\n");
				   break;

				  case TSTRING:
				   conprint("FNCSPARAM TSTRING 0V\n");
				   break;

				  default:
				  {
				   yyerror("Invalid type.");
				   exit(-1);
				  }
				 }

	
				 conprint("FNCSTORE TNUMBER %d\n", funcnum);
				 actual_parameters(saveexp);
				}
				;

opt_expression2:		{
				 PNF_Number n(0);
				 $$ = n;
				}
				| expression
				{
				 $$ = $1;
				 saveexp2 = $$;

				 pnum = 0;
 				 switch (exptype)
				 {
				  case TVOID:
				   break;
				  
				  case TBOOLEAN:
				   fparams4[fparams4.length() - 1] = "BOOLEAN";
			           fparams4.insert();
				   break;

				  case TNUMBER:
				   fparams4[fparams4.length() - 1] = "NUMBER";
			           fparams4.insert();
				   break;

				  case TCHARACTER:
				   fparams4[fparams4.length() - 1] = "CHARACTER";
			           fparams4.insert();
				   break;

				  case TSTRING:
				   fparams4[fparams4.length() - 1] = "STRING";
			           fparams4.insert();
				   break;

				  default:
				   yyerror("Invalid type.");
				 }
				 actual_parameters2();
				}
				| opt_expression2 COMMA expression
				{
				 $$ = $3;
				 saveexp2 = $$;

				 switch (exptype)
				 {
				  case TVOID:
				   funcps[funcps.length() - 1][funcps[funcps.length() - 1].length() - 1].value($$);
				   funcps[funcps.length() - 1].insert();
				   break;

				  case TBOOLEAN:
				   fparams4[fparams4.length() - 1] = "BOOLEAN";
			           fparams4.insert();

				   funcps[funcps.length() - 1].value($$);
				   funcps[funcps.length() - 1].insert();
				   break;

				  case TNUMBER:
				   fparams4[fparams4.length() - 1] = "NUMBER";
			           fparams4.insert();

				   funcps[funcps.length() - 1][funcps[funcps.length() - 1].length() - 1].value($$);
				   funcps[funcps.length() - 1].insert();
				   break;

				  case TCHARACTER:
				   fparams4[fparams4.length() - 1] = "CHARACTER";
			           fparams4.insert();

				   funcps[funcps.length() - 1][funcps[funcps.length() - 1].length() - 1].value($$);
				   funcps[funcps.length() - 1].insert();
				   break;

				  case TSTRING:
				   fparams4[fparams4.length() - 1] = "STRING";
			           fparams4.insert();

				   funcps[funcps.length() - 1][funcps[funcps.length() - 1].length() - 1].value($$);
				   funcps[funcps.length() - 1].insert();
				   break;

				  default:
				   yyerror("Invalid type.");
				 }
				 actual_parameters2();
				}
				;

declaration:		variable_declaration
			{
			 ASTNode declaration("declaration"); 
		         tree.add_node(declaration);
			}
			| label_declaration
			{
			 ASTNode declaration("declaration"); 
		         tree.add_node(declaration);
			}
			| enum_declaration
			{
			 ASTNode declaration("declaration");
			 tree.add_node(declaration);
			}
			| range_declaration
			{
			 ASTNode declaration("declaration");
			 tree.add_node(declaration);
			}
			| struct_declaration
			{
			 ASTNode declaration("declaration");
			 tree.add_node(declaration);
			}
			| struct_declaration2
			{
			 ASTNode declaration("declaration");
			 tree.add_node(declaration);
			}
			| struct_var_declaration3
			{
			 ASTNode declaration("declaration");
			 tree.add_node(declaration);
			}
			| union_declaration
			{
			 ASTNode declaration("declaration");
			 tree.add_node(declaration);
			}
			| union_declaration2
			{
			 ASTNode declaration("declaration");
			 tree.add_node(declaration);
			}
			| union_var_declaration3
			{
			 ASTNode declaration("declaration");
			 tree.add_node(declaration);
			}
			;			;

variable_declaration:	VAR ID
			{
			 ASTNode variable_declaration("variable_declaration"); 

			 bool declared = false;
	     		 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
		  	 {
	 		  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   PNF_Number n(0);
			   PNF_Variable p(n);
			   varTable[scope][i].value(p);
			   $$.put(varTable[scope][i].value().to_number());
			  }
			 }

			 if (!declared)
			 {
			  varTable[scope].insert();
			  varTable[scope][varTable[scope].length() - 1].name($2.to_string().get());
			  PNF_Number n(0);
			  PNF_Variable p(n);
			  varTable[scope][varTable[scope].length() - 1].value(p);

			  switch (p.getType())
		    	  {
			   case TVOID:
   			    conprint("ALOAD TVOID 0V\n");
			    break;

			   case TBOOLEAN:
   			    conprint("ALOAD TBOOLEAN %s\n", p.to_boolean().get().getString().c_str());
			    break;

			   case TNUMBER:
   			    conprint("ALOAD TNUMBER %g\n", p.to_number().get());
			    break;

			   case TCHARACTER:
   			    conprint("ALOAD TCHARACTER %c\n", p.to_character().get());
			    break;

			   case TSTRING:
   			    conprint("ALOAD TSTRING %s\n", p.to_string().get().getString().c_str());
			    break;
			  }
			  conprint("VSTORE TVOID 0V\n");
			  ++varcount;
			  $$.put(varTable[scope][varTable[scope].length() - 1].value().to_number());

			  if (varTable[scope].length() - 2 <= 0)
		  	   varTable[scope][varTable[scope].length() - 1].address(scope + 0);
			  else
			   varTable[scope][varTable[scope].length() - 1].address(scope + (varTable[scope][varTable[scope].length() - 2].address() + 1));
			 }
		         tree.add_node(variable_declaration);
			}
			| VAR ID OPEQUAL expression
			{
			 ASTNode variable_declaration("variable_declaration"); 

			 bool declared = false;
	     		 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
		  	 {
	 		  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   varTable[scope][i].value($4);
			
			   switch ($4.getType())
			   {
			    case TVOID:
			     $$.put("0V");
			     break;
			
			    case TBOOLEAN:
			     $$.put(varTable[scope][i].value().to_boolean());
			     break;

			    case TNUMBER:
			     $$.put(varTable[scope][i].value().to_number());
			     break;

			    case TCHARACTER:
			     $$.put(varTable[scope][i].value().to_character());
			     break;

			    case TSTRING:
			     $$.put(varTable[scope][i].value().to_string());
			     break;
			   }
			  }
			 }

			 if (!declared)
			 {
			  varTable[scope].insert();

			  varTable[scope][varTable[scope].length() - 1].name($2.to_string().get());
			  varTable[scope][varTable[scope].length() - 1].value($4);

			  $$ = $4;

			  switch ($$.getType())
		    	  {
			   case TVOID:
   			    conprint("ALOAD TVOID 0V\n");
			    break;

			   case TBOOLEAN:
   			    conprint("ALOAD TBOOLEAN %s\n", $$.to_boolean().get().getString().c_str());
			    break;

			   case TNUMBER:
   			    conprint("ALOAD TNUMBER %g\n", $$.to_number().get());
			    break;

			   case TCHARACTER:
   			    conprint("ALOAD TCHARACTER \'%c\'\n", $$.to_character().get());
			    break;

			   case TSTRING:
   			    conprint("ALOAD TSTRING \"%s\"\n", $$.to_string().get().getString().c_str());
			    break;
			  }
			  conprint("VSTORE TVOID 0V\n");
			  ++varcount;

			  unsigned long paddress = 0;
			  if (varTable[scope].length() - 2 <= 0)
		  	   paddress = scope + 0;
			  else
			   paddress = scope + (varTable[scope][varTable[scope].length() - 2].address() + 1);			  
			
			  varTable[scope][varTable[scope].length() - 1].address(paddress);
			 }
		         tree.add_node(variable_declaration);
			}
			| FVAR ID
			{
			 ASTNode variable_declaration("variable_declaration"); 

			 bool declared = false;
	     		 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
		  	 {
	 		  if (strcmp(varTable[scope][i].name().getString().c_str(), $2.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   PNF_Number n(0);
			   PNF_Variable p(n);
			   varTable[scope][i].value(p);
			   $$.put(varTable[scope][i].value().to_number());
			  }
			 }

			 if (!declared)
			 {
			  varTable[scope].insert();
			  varTable[scope][varTable[scope].length() - 1].name($2.to_string().get());
			  PNF_Number n(0);
			  PNF_Variable p(n);
			  varTable[scope][varTable[scope].length() - 1].value(p);

			  ++varcount;
			  $$.put(varTable[scope][varTable[scope].length() - 1].value().to_number());

			  if (varTable[scope].length() - 2 <= 0)
		  	   varTable[scope][varTable[scope].length() - 1].address(scope + 0);
			  else
			   varTable[scope][varTable[scope].length() - 1].address(scope + (varTable[scope][varTable[scope].length() - 2].address() + 1));
			 }
		         tree.add_node(variable_declaration);
			}
			| enumv_declaration
			{
			 ASTNode variable_declaration("variable_declaration");
			 tree.add_node(variable_declaration);
			}
			| rangev_declaration
			{
			 ASTNode variable_declaration("variable_declaration");
			 tree.add_node(variable_declaration);
			}
			| array_declaration
			{
			 ASTNode variable_declaration("variable_declaration");
			 tree.add_node(variable_declaration);
			}
			;

enumv_declaration:	ENUMV STRINGV STRINGV OPEQUAL STRINGV
			{
			 ASTNode enumv_declaration("enumv_declaration");

			 conprint("ENUMS TSTRING %s\n", $2.to_string().get().getString().c_str());
			 conprint("ENUM TSTRING %s\n", $5.to_string().get().getString().c_str());
			 conprint("SENUM TSTRING %s\n", $3.to_string().get().getString().c_str());

			 tree.add_node(enumv_declaration);
			}
			;

rangev_declaration:	RANGEV RTYPE2 STRINGV STRINGV OPEQUAL STRINGV
			{
			 ASTNode rangev_declaration("rangev_declaration");

			 if ($2.to_string().get() == "rtype1")
			 {
			  conprint("RSTART1 TSTRING %s\n", $3.to_string().get().getString().c_str());
			  conprint("RANGE1 TNUMBER %s\n", strip_quotes($6.to_string().get()).getString().c_str());
			  conprint("REND1 TSTRING %s\n", $4.to_string().get().getString().c_str());
			 }
			 else
			  yyerror("Invalid Range Type.");

			 tree.add_node(rangev_declaration);
			}
			| RANGEV RTYPE2 STRINGV STRINGV
			{
			 ASTNode rangev_declaration("rangev_declaration");

			 if ($2.to_string().get() == "rtype2")
			 {
			  conprint("RSTART2 TSTRING %s\n", $3.to_string().get().getString().c_str());
			  conprint("RANGE2 TSTRING %s\n", $4.to_string().get().getString().c_str());
			 }
			 else
			  yyerror("Invalid Range Type.");

			 tree.add_node(rangev_declaration);
			}
			;

array_declaration:	ARRAY STRINGV OPLSQ number_expression OPRSQ
			{
			 ASTNode array_declaration("array_declaration");

			 conprint("ASTART TSTRING %s\n", $2.to_string().get().getString().c_str());
			 conprint("AEND TNUMBER %g\n", $4.to_number().get());

			 tree.add_node(array_declaration);
			}
			;

enum_declaration:	ENUM ID OPEQUAL LEFTB 
			{
			 ASTNode enum_declarationp1("enum_declarationp1");

			 conprint("ESTART TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());

			 tree.add_node(enum_declarationp1);
			}
			enum_strings
			{
			 ASTNode enum_declarationp2("enum_declarationp2");
			 tree.add_node(enum_declarationp2);
			}
			RIGHTB
			{
			 ASTNode enum_declarationp3("enum_declarationp3");

			 conprint("EEND TVOID 0V\n");

			 tree.add_node(enum_declarationp3);
			}
			;

enum_strings:		STRINGV
			{
			 ASTNode enum_strings("enum_strings");

			 conprint("ENAME TSTRING %s\n", $1.to_string().get().getString().c_str());

			 tree.add_node(enum_strings);
			}
			| enum_strings COMMA STRINGV
			{
			 conprint("ENAME TSTRING %s\n", $3.to_string().get().getString().c_str());
			}
			;

range_declaration:	RANGE RTYPE2 STRINGV OPEQUAL STRINGV OPDOT OPDOT STRINGV
			{
			 ASTNode range_declaration("range_declaration");

			 if ($2.to_string().get() == "rtype1")
			 {
			  conprint("RDSTART1 TSTRING %s\n", $3.to_string().get().getString().c_str());
			  conprint("RFROM1 TNUMBER %s\n", strip_quotes($5.to_string().get()).getString().c_str());
			  conprint("RTO1 TNUMBER %s\n", strip_quotes($8.to_string().get()).getString().c_str());
			  conprint("RDEND1 TVOID 0V\n");
			 }
			 else if ($2.to_string().get() == "rtype2")
			 {
			  conprint("RDSTART2 TSTRING %s\n", $3.to_string().get().getString().c_str());
			  conprint("RFROM2 TNUMBER %s\n", strip_quotes($5.to_string().get()).getString().c_str());
			  conprint("RTO2 TNUMBER %s\n", strip_quotes($8.to_string().get()).getString().c_str());
			  conprint("RDEND2 TVOID 0V\n");
			 }
			 else
			  yyerror("Invalid Range Type.");

			 tree.add_node(range_declaration);
			}
			;

struct_declaration:	STRUCT ID
			{
			 conprint("STRUCT TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
			}
			struct_body
			;

struct_body:		LEFTB
			struct_var_declarations
			RIGHTB
			{
			 conprint("ENDSTRUCT TVOID 0V\n");
			}
			;

struct_var_declarations:	struct_var_declarations2
				| struct_var_declarations struct_var_declarations2
				;

struct_var_declarations2:	STRUCTVAR ID
				{
				 conprint("STRUCTVAR TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
				}
				SEND
				;

struct_declaration2:		STRUCT ID ID
				{
				 conprint("STRUCTNAME TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
				 conprint("STRUCTD TSTRING \"%s\"\n", $3.to_string().get().getString().c_str());
				}
				;

struct_var_declaration3:	STRUCT ID ID OPDOT ID OPEQUAL expression
				{
				 conprint("STRUCTNAME TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
				 conprint("STRUCTONAME TSTRING \"%s\"\n", $3.to_string().get().getString().c_str());
				 conprint("STRUCTUSE TSTRING \"%s\"\n", $5.to_string().get().getString().c_str());
				 
				 switch ($7.getType())
				 {
				  case TVOID:
				  {
				   conprint("ALOAD TVOID 0V\n");
				  }
				  break;

				  case TBOOLEAN:
				  {
				   conprint("ALOAD TBOOLEAN %s\n", $7.to_boolean().get());
				  }
				  break;

				  case TNUMBER:
				  {
				   conprint("ALOAD TNUMBER %f\n", $7.to_number().get());
				  }
				  break;

				  case TCHARACTER:
				  {
				   conprint("ALOAD TCHARACTER '%c'\n", $6.to_character().get());
				  }
				  break;

				  case TSTRING:
				  {
				   conprint("ALOAD TSTRING %s\n", $7.to_string().get().getString().c_str());
				  }
				  break;

				  default:
				   yyerror((char *)"Invalid type.");
				 }

				 conprint("STRUCTPUT TVOID 0V\n");
				}
				;

union_declaration:	UNION ID
			{
			 conprint("UNION TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
			}
			union_body
			;

union_body:		LEFTB
			union_var_declarations
			RIGHTB
			{
			 conprint("ENDUNION TVOID 0V\n");
			}
			;

union_var_declarations:		union_var_declarations2
				| union_var_declarations union_var_declarations2
				;

union_var_declarations2:	UNIONVAR ID
				{
				 conprint("UNIONVAR TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
				}
				SEND
				;

union_declaration2:		UNION ID ID
				{
				 conprint("UNIONNAME TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
				 conprint("UNIOND TSTRING \"%s\"\n", $3.to_string().get().getString().c_str());
				}
				;

union_var_declaration3:		UNION ID ID OPDOT ID OPEQUAL expression
				{
				 conprint("UNIONNAME TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
				 conprint("UNIONONAME TSTRING \"%s\"\n", $3.to_string().get().getString().c_str());
				 conprint("UNIONUSE TSTRING \"%s\"\n", $5.to_string().get().getString().c_str());
				 
				 switch ($7.getType())
				 {
				  case TVOID:
				  {
				   conprint("ALOAD TVOID 0V\n");
				  }
				  break;

				  case TBOOLEAN:
				  {
				   conprint("ALOAD TBOOLEAN %s\n", $7.to_boolean().get());
				  }
				  break;

				  case TNUMBER:
				  {
				   conprint("ALOAD TNUMBER %f\n", $7.to_number().get());
				  }
				  break;

				  case TCHARACTER:
				  {
				   conprint("ALOAD TCHARACTER '%c'\n", $6.to_character().get());
				  }
				  break;

				  case TSTRING:
				  {
				   conprint("ALOAD TSTRING %s\n", $7.to_string().get().getString().c_str());
				  }
				  break;

				  default:
				   yyerror((char *)"Invalid type.");
				 }

				 conprint("UNIONPUT TVOID 0V\n");
				}
				;

label_declaration:	SUB ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < labelTable.length(); ++i)
			 {
			  if ($2.to_string().get().getString() == labelTable[i].name().getString())
			  {
			   declared = true;
			   String str = labelTable[i].name();
			   str += " declared already.";
			   yyerror(str.getString().c_str());
			  }
			 }

			 if (!declared)
			 {
			  labelTable.insert();
			  labelTable[labelTable.length() - 1].name($2.to_string().get());
			  labelTable[labelTable.length() - 1].address(labelTable.length() - 2);
			 }

			 ASTNode label_declaration("label_declaration");
		         tree.add_node(label_declaration);
			}
			| EVENT ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < labelTable.length(); ++i)
			 {
			  if ($2.to_string().get().getString() == eventLabelTable[i].name().getString())
			  {
			   declared = true;
			   String str = eventLabelTable[i].name();
			   str += " declared already.";
			   yyerror(str.getString().c_str());
			  }
			 }

			 if (!declared)
			 {
			  eventLabelTable.insert();
			  eventLabelTable[eventLabelTable.length() - 1].name($2.to_string().get());
			  eventLabelTable[eventLabelTable.length() - 1].address(eventLabelTable.length() - 2);
			 }
			 ASTNode label_declaration("label_declaration");
		         tree.add_node(label_declaration);
			}
			| LABEL ID
			{
			 bool declared = false;
			 for (unsigned long i = 0; i < labelTable.length(); ++i)
			 {
			  if ($2.to_string().get().getString() == labelTable[i].name().getString())
			  {
			   declared = true;
			   String str = labelTable[i].name();
			   str += " declared already.";
			   yyerror(str.getString().c_str());
			  }
			 }

			 if (!declared)
			 {
			  labelTable.insert();
			  labelTable[labelTable.length() - 1].name($2.to_string().get());
			  labelTable[labelTable.length() - 1].address(labelTable.length() - 2);
			 }

			 ASTNode label_declaration("label_declaration");
		         tree.add_node(label_declaration);
			}
			| function_declaration
			| function_declaration2
			;

function_declaration:	FUNCDEF LEFTP vars RIGHTP ID LEFTP parameter_declaration RIGHTP
			{
			 funcps.insert();

			 funcptr->name($5.to_string().get());			 
			 funcstk.add_function(*funcptr);
			 delete funcptr;
			 funcptr = NULL;			 
	
			 saveid3 = $5;
			 unsigned long index = funcstk.find($5.to_string().get(), frets, fparams);
			 if (index == -1)
			 {
			  yyerror("Function not found.");
			  exit(-1);
			 }


			 for (unsigned long i = 0; i < funcstk.get_function(index).params().length(); ++i)
			 {
			  funcps[index].insert();
			  funcps[index][i].name(funcstk.get_function(index).pname(i));
			 }

			 for (unsigned long i = 0; i < funcstk.get_function(index).params().length(); ++i)
			 {
			  funcps[index][i].value(funcstk.get_function(index).param(i));
			 }
			 
			 
			 conprint("ALOAD TSTRING \"%s\"\n", $5.to_string().get().getString().c_str());
			 conprint("FNCSNAME TVOID 0V\n");
			 conprint("FNCSDEF TSTRING \"%s\"\n", funcstk.get_function(index).rname().getString().c_str());
			 conprint("FNCSTORE TVOID 0V\n");
			 conprint("FNCDELETE TVOID 0V\n");
			}
			nothing
			{
			 for (unsigned long i = frets.length() - 1; i > 0; --i)
			  frets.remove();

			 for (unsigned long i = fparams.length() - 1; i > 0; --i)
			  fparams.remove();
			}
			;

nothing:		;

parameter_declaration:	opt_var
			{
			 $$ = $1;

			 pnum = 0;
			 switch (exptype)
			 {
			  case TVOID:
			  {
			   PNF_Void v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "VOID";
			   fparams.insert();

			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TVOID 0V\n");
			   conprint("FNCSPARAM TVOID 0V\n");
			  }
			  break;

			  case TBOOLEAN:
			  {
			   PNF_Boolean v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "BOOLEAN";
			   fparams.insert();

			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TBOOLEAN false\n");
			   conprint("FNCSPARAM TBOOLEAN 0V\n");
			  }
			  break;

			  case TNUMBER:
			  {
			   PNF_Number v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "NUMBER";
			   fparams.insert();

			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TNUMBER 0\n");
			   conprint("FNCSPARAM TNUMBER 0V\n");
			  }
			  break;

			  case TCHARACTER:
			  {
			   PNF_Character v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "CHARACTER";
			   fparams.insert();


			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TCHARACTER '0'\n");
			   conprint("FNCSPARAM TCHARACTER 0V\n");
			  }
			  break;

			  case TSTRING:
			  {			   
			   PNF_String v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "STRING";
			   fparams.insert();


			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TSTRING \"\"\n");
			   conprint("FNCSPARAM TSTRING 0V\n");
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| parameter_declaration COMMA VAR ID OPCOLON TYPE
			{
			 $$ = $4;


			 String type = $6.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TVOID:
			  {
			   PNF_Void v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "VOID";
			   fparams.insert();


			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TVOID 0V\n");
			   conprint("FNCSPARAM TVOID 0V\n");
			  }
			  break;

			  case TBOOLEAN:
			  {
			   PNF_Boolean v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "BOOLEAN";
			   fparams.insert();


			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TBOOLEAN false\n");
			   conprint("FNCSPARAM TBOOLEAN 0V\n");
			  }
			  break;

			  case TNUMBER:
			  {
			   PNF_Number v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "NUMBER";
			   fparams.insert();


			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TNUMBER 0\n");
			   conprint("FNCSPARAM TNUMBER 0V\n");
			  }
			  break;

			  case TCHARACTER:
			  {
			   PNF_Character v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "CHARACTER";
			   fparams.insert();


			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TCHARACTER '0'\n");
			   conprint("FNCSPARAM TCHARACTER 0V\n");
			  }
			  break;

			  case TSTRING:
			  {
			   PNF_String v;
			   PNF_Variable v2(v);
			   funcptr->param(pnum, v2);
			   funcptr->pname(pnum, $$.to_string().get());

			   fparams[fparams.length() - 1] = "STRING";
			   fparams.insert();


			   conprint("PNUM TNUMBER %d\n", pnum++);
			   conprint("ALOAD TSTRING \"\"\n");
			   conprint("FNCSPARAM TSTRING 0V\n");
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;

parameter_declaration2:	opt_var2
			{
			 $$ = $1;

			 switch (exptype)
			 {
			  case TVOID:
			  {
			   fparams2[fparams2.length() - 1] = "VOID";
			   fparams2.insert();
			  }
			  break;

			  case TBOOLEAN:
			  {
			   fparams2[fparams2.length() - 1] = "BOOLEAN";
			   fparams2.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   fparams2[fparams2.length() - 1] = "NUMBER";
			   fparams2.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   fparams2[fparams2.length() - 1] = "CHARACTER";
			   fparams2.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   fparams2[fparams2.length() - 1] = "STRING";
			   fparams2.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }


			 if (fncdefault)
			 {
			  conprint("FNCLOAD TNUMBER %d\n", fsaveindex + 1);

			  switch (exptype)
			  {
			   case TVOID:
			   {
			    conprint("ALOAD TVOID 0V\n");
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   case TBOOLEAN:
			   {
			    conprint("ALOAD TBOOLEAN %s\n", funcstk.get_function(fsaveindex + 1).defaultv(pnum5).to_boolean().get().getString().c_str());
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   case TNUMBER:
			   {
			    conprint("ALOAD TNUMBER %g\n", funcstk.get_function(fsaveindex + 1).defaultv(pnum5).to_number().get());
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   case TCHARACTER:
			   {
			    conprint("ALOAD TCHARACTER %c\n", funcstk.get_function(fsaveindex + 1).defaultv(pnum5).to_character().get());
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   case TSTRING:
			   {
			    conprint("ALOAD TSTRING %s\n", funcstk.get_function(fsaveindex + 1).defaultv(pnum5).to_string().get().getString().c_str());
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   default:
			   {
			    yyerror((char *)"Invalid Type.");
			    exit(-1);
			   }
			  }

			  conprint("FNCSTORE TNUMBER %d\n", fsaveindex + 1);
			 }
			}
			| parameter_declaration2 COMMA VAR ID OPCOLON TYPE opt_default_value
			{
			 String type = $6.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TVOID:
			  {
			   fparams2[fparams2.length() - 1] = "VOID";
			   fparams2.insert();
			  }
			  break;

			  case TBOOLEAN:
			  {
			   fparams2[fparams2.length() - 1] = "BOOLEAN";
			   fparams2.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   fparams2[fparams2.length() - 1] = "NUMBER";
			   fparams2.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   fparams2[fparams2.length() - 1] = "CHARACTER";
			   fparams2.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   fparams2[fparams2.length() - 1] = "STRING";
			   fparams2.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }


			 if (fncdefault)
			 {
			  conprint("FNCLOAD TNUMBER %d\n", fsaveindex + 1);

			  switch (exptype)
			  {
			   case TVOID:
			   {
			    conprint("ALOAD TVOID 0V\n");
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   case TBOOLEAN:
			   {
			    conprint("ALOAD TBOOLEAN %s\n", funcstk.get_function(fsaveindex + 1).defaultv(pnum5).to_boolean().get().getString().c_str());
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   case TNUMBER:
			   {
			    conprint("ALOAD TNUMBER %g\n", funcstk.get_function(fsaveindex + 1).defaultv(pnum5).to_number().get());
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   case TCHARACTER:
			   {
			    conprint("ALOAD TCHARACTER %c\n", funcstk.get_function(fsaveindex + 1).defaultv(pnum5).to_character().get());
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   case TSTRING:
			   {
			    conprint("ALOAD TSTRING %s\n", funcstk.get_function(fsaveindex + 1).defaultv(pnum5).to_string().get().getString().c_str());
			    conprint("PNUM TNUMBER %d\n", pnum5);
			    conprint("FNCSDEFAULTV2 TVOID 0V\n");
			   }
			   break;

			   default:
			   {
			    yyerror((char *)"Invalid Type.");
			    exit(-1);
			   }
			  }

			  conprint("FNCSTORE TNUMBER %d\n", fsaveindex + 1);
			 }
			}
			;

parameter_declaration5:	opt_var5
			{
			 $$ = $1;

			 switch (exptype)
			 {
			  case TVOID:
			  {
			   fparams5[fparams5.length() - 1] = "VOID";
			   fparams5.insert();
			  }
			  break;

			  case TBOOLEAN:
			  {
			   fparams5[fparams5.length() - 1] = "BOOLEAN";
			   fparams5.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   fparams5[fparams5.length() - 1] = "NUMBER";
			   fparams5.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   fparams5[fparams5.length() - 1] = "CHARACTER";
			   fparams5.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   fparams5[fparams5.length() - 1] = "STRING";
			   fparams5.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| parameter_declaration5 COMMA VAR ID OPCOLON TYPE
			{
			 String type = $6.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TVOID:
			  {
			   fparams5[fparams5.length() - 1] = "VOID";
			   fparams5.insert();
			  }
			  break;

			  case TBOOLEAN:
			  {
			   fparams5[fparams5.length() - 1] = "BOOLEAN";
			   fparams5.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   fparams5[fparams5.length() - 1] = "NUMBER";
			   fparams5.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   fparams5[fparams5.length() - 1] = "CHARACTER";
			   fparams5.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   fparams5[fparams5.length() - 1] = "STRING";
			   fparams5.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;

parameter_declaration6:	opt_var6
			{
			 $$ = $1;

			 switch (exptype)
			 {
			  case TVOID:
			  {
			   fparams6[fparams6.length() - 1] = "VOID";
			   fparams6.insert();
			  }
			  break;

			  case TBOOLEAN:
			  {
			   fparams6[fparams6.length() - 1] = "BOOLEAN";
			   fparams6.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   fparams6[fparams6.length() - 1] = "NUMBER";
			   fparams6.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   fparams6[fparams6.length() - 1] = "CHARACTER";
			   fparams6.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   fparams6[fparams6.length() - 1] = "STRING";
			   fparams6.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| parameter_declaration6 COMMA VAR ID OPCOLON TYPE
			{
			 String type = $6.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TVOID:
			  {
			   fparams6[fparams6.length() - 1] = "VOID";
			   fparams6.insert();
			  }
			  break;

			  case TBOOLEAN:
			  {
			   fparams6[fparams6.length() - 1] = "BOOLEAN";
			   fparams6.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   fparams6[fparams6.length() - 1] = "NUMBER";
			   fparams6.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   fparams6[fparams6.length() - 1] = "CHARACTER";
			   fparams6.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   fparams6[fparams6.length() - 1] = "STRING";
			   fparams6.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;

opt_var:		VAR ID OPCOLON TYPE
			{
			 $$ = $2;

			 String type = $4.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");
			}
			| VOIDV
			{
			 $$ = $1;

			 exptype = TVOID;
			}
			;

opt_var2:		VAR ID OPCOLON TYPE opt_default_value
			{
			 $$ = $2;

			 String type = $4.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");
			}
			| VOIDV
			{
			 $$ = $1;

			 exptype = TVOID;
			}
			;

opt_default_value:	| dvalue
			{
			 $$ = $1;


			 funcps[fsaveindex + 1].insert();
			 funcps[fsaveindex + 1][pnum5].value($$);


			 funcstk.get_function(fsaveindex + 1).defaultv(pnum5, $$);
			 funcstk.get_function(fsaveindex + 1).syncdefaultp(pnum5);
			}
			;

dvalue:			OPEQUAL expression OPCOLON NUMBERV
			{
			 $$ = $2;
			 pnum5 = (unsigned long)$4.to_number().get();
			}
			;

optdefaultv:		| DEFAULTV
			{
			 fncdefault = true;
			 conprint("FNCDEFAULT TVOID 0V\n");
			}
			;

opt_var5:		VAR ID OPCOLON TYPE
			{
			 $$ = $2;

			 String type = $4.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");
			}
			| VOIDV
			{
			 $$ = $1;

			 exptype = TVOID;
			}
			;

opt_var6:		VAR ID OPCOLON TYPE
			{
			 $$ = $2;

			 String type = $4.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");
			}
			| VOIDV
			{
			 $$ = $1;

			 exptype = TVOID;
			}
			;

function_declaration2:	FUNCTION optdefaultv LEFTP vars2 RIGHTP ID LEFTP parameter_declaration2 RIGHTP
			{
			 pnum5 = 0;


			 fsaveid = $6;
			 unsigned long index = funcstk.find($6.to_string().get(), frets2, fparams2);
			 if (index == -1)
			 {
			  yyerror("Function not found.");
			  exit(-1);
			 }

			 fsaveindex = index;

			 conprint("GOTOL TSTRING \"%s_END\"\n", funcstk.get_function(index).rname().getString().c_str());
			 conprint("LBL TSTRING \"%s\"\n", funcstk.get_function(index).rname().getString().c_str());
			}
			function_body
			{
			 unsigned long index = funcstk.find(fsaveid.to_string().get(), frets2, fparams2);
			 if (index == -1)
			 {
			  yyerror("Function not found.");
			  exit(-1);
			 }

			 conprint("LBL TSTRING \"%s_END\"\n", funcstk.get_function(index).rname().getString().c_str());
			}
			nothing	
			{
			 for (unsigned long i = frets2.length() - 1; i > 0; --i)
			  frets2.remove();

			 for (unsigned long i = fparams2.length() - 1; i > 0; --i)
			  fparams2.remove();
			}		
			;

function_body:		LEFTB
			statements
			RIGHTB
			;

vars:			VOIDV
			{
			 funcptr = new Function();

		  	 conprint("FNCNEW TVOID 0V\n");

			 exptype = TVOID;
			}
			| VAR OPCOLON TYPE
			{
			 funcptr = new Function();

		  	 conprint("FNCNEW TVOID 0V\n");


			 String type = $3.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 rnum = 0;
			 switch (exptype)
			 {			  
			  case TBOOLEAN:
			  {
			   PNF_Boolean v(false);
			   PNF_Variable v2(v);
			   funcptr->ret(rnum, v2);

			   frets[frets.length() - 1] = "BOOLEAN";
			   frets.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("ALOAD TBOOLEAN false\n");
			   conprint("FNCSRET TBOOLEAN 0V\n");
			  }
			  break;

			  case TNUMBER:
			  {
			   PNF_Number v(0);
			   PNF_Variable v2(v);
			   funcptr->ret(rnum, v2);

			   frets[frets.length() - 1] = "NUMBER";
			   frets.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("ALOAD TNUMBER 0\n");
			   conprint("FNCSRET TNUMBER 0V\n");
			  }
			  break;

			  case TCHARACTER:
			  {
			   PNF_Character v('\0');
			   PNF_Variable v2(v);
			   funcptr->ret(rnum, v2);

			   frets[frets.length() - 1] = "CHARACTER";
			   frets.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("ALOAD TCHARACTER \'\'\n");
			   conprint("FNCSRET TCHARACTER 0V\n");
			  }
			  break;

			  case TSTRING:
			  {
			   PNF_String v("");
			   PNF_Variable v2(v);
			   funcptr->ret(rnum, v2);

			   frets[frets.length() - 1] = "STRING";
			   frets.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("ALOAD TSTRING \"\"\n");
			   conprint("FNCSRET TSTRING 0V\n");
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| vars COMMA VAR OPCOLON TYPE
			{
			 String type = $5.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   PNF_Boolean v(false);
			   PNF_Variable v2(v);
			   funcptr->ret(rnum, v2);

			   frets[frets.length() - 1] = "BOOLEAN";
			   frets.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("ALOAD TBOOLEAN false\n");
			   conprint("FNCSRET TBOOLEAN 0V\n");
			  }
			  break;

			  case TNUMBER:
			  {
			   PNF_Number v(0);
			   PNF_Variable v2(v);
			   funcptr->ret(rnum, v2);

			   frets[frets.length() - 1] = "NUMBER";
			   frets.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("ALOAD TNUMBER 0\n");
			   conprint("FNCSRET TNUMBER 0V\n");
			  }
			  break;

			  case TCHARACTER:
			  {
			   PNF_Character v('\0');
			   PNF_Variable v2(v);
			   funcptr->ret(rnum, v2);

			   frets[frets.length() - 1] = "CHARACTER";
			   frets.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("ALOAD TCHARACTER \'\'\n");
			   conprint("FNCSRET TCHARACTER 0V\n");
			  }
			  break;

			  case TSTRING:
			  {
			   PNF_String v("");
			   PNF_Variable v2(v);
			   funcptr->ret(rnum, v2);

			   frets[frets.length() - 1] = "STRING";
			   frets.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("ALOAD TSTRING \"\"\n");
			   conprint("FNCSRET TSTRING 0V\n");
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;

vars2:			VOIDV
			{
			 exptype = TVOID;
			}
			| VAR OPCOLON TYPE
			{
			 String type = $3.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   frets2[frets2.length() - 1] = "BOOLEAN";
			   frets2.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   frets2[frets2.length() - 1] = "NUMBER";
			   frets2.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets2[frets2.length() - 1] = "CHARACTER";
			   frets2.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   frets2[frets2.length() - 1] = "STRING";
			   frets2.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| vars2 COMMA VAR OPCOLON TYPE
			{
			 String type = $5.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   frets2[frets2.length() - 1] = "BOOLEAN";
			   frets2.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   frets2[frets2.length() - 1] = "NUMBER";
			   frets2.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets2[frets2.length() - 1] = "CHARACTER";
			   frets2.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   frets2[frets2.length() - 1] = "STRING";
			   frets2.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;

vars3:			VOIDV
			{
			 exptype = TVOID;			}
			| VAR OPCOLON TYPE
			{
			 String type = $3.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");


			 rnum = 0;
			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   frets3[frets3.length() - 1] = "BOOLEAN";
			   frets3.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TBOOLEAN 0V\n");
			  }
			  break;

			  case TNUMBER:
			  {
			   frets3[frets3.length() - 1] = "NUMBER";
			   frets3.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TNUMBER 0V\n");
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets3[frets3.length() - 1] = "CHARACTER";
			   frets3.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TCHARACTER 0V\n");
			  }
			  break;

			  case TSTRING:
			  {
			   frets3[frets3.length() - 1] = "STRING";
			   frets3.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TSTRING 0V\n");
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| vars3 COMMA VAR OPCOLON TYPE
			{
			 String type = $5.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TVOID:
			  {		  
			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TVOID 0V\n");
			  }
			  break;

			  case TBOOLEAN:
			  {
			   frets3[frets3.length() - 1] = "BOOLEAN";
			   frets3.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TBOOLEAN 0V\n");
			  }
			  break;

			  case TNUMBER:
			  {
			   frets3[frets3.length() - 1] = "NUMBER";
			   frets3.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TNUMBER 0V\n");
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets3[frets3.length() - 1] = "CHARACTER";
			   frets3.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TCHARACTER 0V\n");
			  }
			  break;

			  case TSTRING:
			  {
			   frets3[frets3.length() - 1] = "STRING";
			   frets3.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TSTRING 0V\n");
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;

vars4:			VOIDV
			{
			 exptype = TVOID;			}
			| VAR OPCOLON TYPE
			{
			 String type = $3.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");


			 rnum = 0;
			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   frets4[frets4.length() - 1] = "BOOLEAN";
			   frets4.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TBOOLEAN 0V\n");
			  }
			  break;

			  case TNUMBER:
			  {
			   frets4[frets4.length() - 1] = "NUMBER";
			   frets4.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TNUMBER 0V\n");
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets4[frets4.length() - 1] = "CHARACTER";
			   frets4.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TCHARACTER 0V\n");
			  }
			  break;

			  case TSTRING:
			  {
			   frets4[frets4.length() - 1] = "STRING";
			   frets4.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TSTRING 0V\n");
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| vars3 COMMA VAR OPCOLON TYPE
			{
			 String type = $5.to_string().get();
			 if (type == "void")
			  exptype = TVOID;
			 else if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TVOID:
			  {
			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TVOID 0V\n");
			  }
			  break;

			  case TBOOLEAN:
			  {
			   frets4[frets4.length() - 1] = "BOOLEAN";
			   frets4.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TBOOLEAN 0V\n");
			  }
			  break;

			  case TNUMBER:
			  {
			   frets4[frets4.length() - 1] = "NUMBER";
			   frets4.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TNUMBER 0V\n");
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets4[frets4.length() - 1] = "CHARACTER";
			   frets4.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TCHARACTER 0V\n");
			  }
			  break;

			  case TSTRING:
			  {
			   frets4[frets4.length() - 1] = "STRING";
			   frets4.insert();

			   conprint("RNUM TNUMBER %d\n", rnum++);
			   conprint("RETURNF2 TSTRING 0V\n");
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;

vars5:			VOIDV
			{
			 exptype = TVOID;
			}
			| VAR OPCOLON TYPE
			{
			 String type = $3.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   frets5[frets5.length() - 1] = "BOOLEAN";
			   frets5.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   frets5[frets5.length() - 1] = "NUMBER";
			   frets5.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets5[frets5.length() - 1] = "CHARACTER";
			   frets5.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   frets5[frets5.length() - 1] = "STRING";
			   frets5.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| vars5 COMMA VAR OPCOLON TYPE
			{
			 String type = $5.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   frets5[frets5.length() - 1] = "BOOLEAN";
			   frets5.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   frets5[frets5.length() - 1] = "NUMBER";
			   frets5.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets5[frets5.length() - 1] = "CHARACTER";
			   frets5.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   frets5[frets5.length() - 1] = "STRING";
			   frets5.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;

vars6:			VOIDV
			{
			 exptype = TVOID;
			}
			| VAR OPCOLON TYPE
			{
			 String type = $3.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   frets6[frets6.length() - 1] = "BOOLEAN";
			   frets6.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   frets6[frets6.length() - 1] = "NUMBER";
			   frets6.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets6[frets6.length() - 1] = "CHARACTER";
			   frets6.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   frets6[frets6.length() - 1] = "STRING";
			   frets6.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			| vars6 COMMA VAR OPCOLON TYPE
			{
			 String type = $5.to_string().get();
			 if (type == "boolean")
			  exptype = TBOOLEAN;
			 else if (type == "number")
			  exptype = TNUMBER;
			 else if (type == "character")
			  exptype = TCHARACTER;
			 else if (type == "string")
			  exptype = TSTRING;
			 else
			  yyerror("Invalid type.");

			 switch (exptype)
			 {
			  case TBOOLEAN:
			  {
			   frets6[frets6.length() - 1] = "BOOLEAN";
			   frets6.insert();
			  }
			  break;

			  case TNUMBER:
			  {
			   frets6[frets6.length() - 1] = "NUMBER";
			   frets6.insert();
			  }
			  break;

			  case TCHARACTER:
			  {
			   frets6[frets6.length() - 1] = "CHARACTER";
			   frets6.insert();
			  }
			  break;

			  case TSTRING:
			  {
			   frets6[frets6.length() - 1] = "STRING";
			   frets6.insert();
			  }
			  break;

			  default:
			   yyerror("Invalid type.");
			 }
			}
			;



command:		print_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| read_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| end_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| asm_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| load_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| goto_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| operator_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| st_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| stack_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| typeof_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| rm_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| crash_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| version_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| halt_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| modt_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| subroutine_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| register_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| store_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| break_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| address_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| add2v_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| continue_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| check_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| comment_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| file_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| meml_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| pnfasm_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| array_length_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| dup_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| fret_command
			{
			 ASTNode command("command");
		         tree.add_node(command);
			}
			| parameter_command
			| struct_command
			| union_command
			| copy_command
			| segment_command
			;

print_command:		
			PRINT
			{
			 ASTNode print_command("print_command");
			 conprint("PRINT TVOID 0V\n");
			 tree.add_node(print_command);
			}
			| PRINT expression
			{
			 ASTNode print_command("print_command");
			 switch (exptype)
			 {
			  case TVOID:
			   yyerror("Cannot print void expression.");
			   break;

			  case TBOOLEAN:
			   conprint("PRINT TBOOLEAN %s\n", $2.to_string().get().getString().c_str());
			   break;

			  case TNUMBER:
			   conprint("PRINT TNUMBER %g\n", $2.to_number().get());
			   break;

			  case TCHARACTER:
			  {
			   String str = $2.to_string().get();
			   
			   String str2;
			   for (unsigned long i = 0, j = 0; i < str.length(); ++i)
			   {
			    if (str[i] == '\'')
			     continue;
			    else
			    {
			     str2[j] = str[i];
			     ++j;
			    }
			   }

			   conprint("PRINT TCHARACTER \'%s\'\n", str2.getString().c_str());
			  }
			  break;

			  case TSTRING:
			   conprint("PRINT TSTRING %s\n", $2.to_string().get().getString().c_str());
			   break;

			  default:
			   yyerror("Invalid exptype.");
			 }
			 tree.add_node(print_command);
			}
			| PRINT CTYPE
			{
			 ASTNode print_command("print_command");

			 if ($2.to_string().get() == "ver")
			  conprint("VPRINT TVOID 0V\n");
			 else
 			  yyerror("Invalid check type.");

			 tree.add_node(print_command);
			}
			| PRINTLN
			{
			 ASTNode print_command("print_command");
			 conprint("PRINTLN TVOID 0V\n");
			 tree.add_node(print_command);
			}
			| PRINTLN expression
			{
			 ASTNode print_command("print_command");
			 switch (exptype)
			 {
			  case TVOID:
			   yyerror("Cannot println void expression.");
			   break;

			  case TBOOLEAN:
			   conprint("PRINTLN TBOOLEAN %s\n", $2.to_string().get().getString().c_str());
			   break;

			  case TNUMBER:
			   conprint("PRINTLN TNUMBER %g\n", $2.to_number().get());
			   break;

			  case TCHARACTER:
			  {
			   String str = $2.to_string().get();
			   
			   String str2;
			   for (unsigned long i = 0, j = 0; i < str.length(); ++i)
			   {
			    if (str[i] == '\'')
			     continue;
			    else
			    {
			     str2[j] = str[i];
			     ++j;
			    }
			   }

			   conprint("PRINTLN TCHARACTER \'%s\'\n", str2.getString().c_str());
			  }
			  break;

			  case TSTRING:
                           conprint("PRINTLN TSTRING %s\n", $2.to_string().get().getString().c_str());
			   break;

			  default:
			   yyerror("Invalid exptype.");
			 }
			 tree.add_node(print_command);
			}
			| PRINTLN CTYPE
			{
			 ASTNode print_command("print_command");

			 if ($2.to_string().get() == "ver")
			  conprint("VPRINTLN TVOID 0V\n");
			 else
 			  yyerror("Invalid check type.");

			 tree.add_node(print_command);
			}
			| EPRINT
			{
			 ASTNode print_command("print_command");
			 conprint("EPRINT TVOID 0V\n");
			 tree.add_node(print_command);
			}
			| EPRINT expression
			{
			 ASTNode print_command("print_command");
			 switch (exptype)
			 {
			  case TVOID:
			   yyerror("Cannot print void expression.");
			   break;

			  case TBOOLEAN:
			   conprint("EPRINT TBOOLEAN %s\n", $2.to_string().get().getString().c_str());
			   break;

			  case TNUMBER:
			   conprint("EPRINT TNUMBER %g\n", $2.to_number().get());
			   break;

			  case TCHARACTER:
			  {
			   String str = $2.to_string().get();
			   
			   String str2;
			   for (unsigned long i = 0, j = 0; i < str.length(); ++i)
			   {
			    if (str[i] == '\'')
			     continue;
			    else
			    {
			     str2[j] = str[i];
			     ++j;
			    }
			   }

			   conprint("EPRINT TCHARACTER \'%s\'\n", str2.getString().c_str());
			  }
			  break;

			  case TSTRING:
			   conprint("EPRINT TSTRING %s\n", $2.to_string().get().getString().c_str());
			   break;

			  default:
			   yyerror("Invalid exptype.");
			 }
			 tree.add_node(print_command);
			}
			| EPRINTLN
			{
			 ASTNode print_command("print_command");
			 conprint("EPRINTLN TVOID 0V\n");
			 tree.add_node(print_command);
			}
			| EPRINTLN expression
			{
			 ASTNode print_command("print_command");
			 switch (exptype)
			 {
			  case TVOID:
			   yyerror("Cannot println void expression.");
			   break;

			  case TBOOLEAN:
			   conprint("EPRINTLN TBOOLEAN %s\n", $2.to_string().get().getString().c_str());
			   break;

			  case TNUMBER:
			   conprint("EPRINTLN TNUMBER %g\n", $2.to_number().get());
			   break;

			  case TCHARACTER:
			  {
			   String str = $2.to_string().get();
			   
			   String str2;
			   for (unsigned long i = 0, j = 0; i < str.length(); ++i)
			   {
			    if (str[i] == '\'')
			     continue;
			    else
			    {
			     str2[j] = str[i];
			     ++j;
			    }
			   }

			   conprint("EPRINTLN TCHARACTER \'%s\'\n", str2.getString().c_str());
			  }
			  break;

			  case TSTRING:
			   conprint("EPRINTLN TSTRING %s\n", $2.to_string().get().getString().c_str());
			   break;

			  default:
			   yyerror("Invalid exptype.");
			 }
			 tree.add_node(print_command);
			}
			| FPRINT
			{
			 ASTNode print_command("print_command");
			 conprint("FPRINT TVOID 0V\n");
			}
			| FPRINT expression
			{
			 ASTNode print_command("print_command");
			 switch (exptype)
			 {
			  case TVOID:
			   yyerror("Cannot print void expression.");
			   break;

			  case TBOOLEAN:
			   conprint("FPRINT TBOOLEAN %s\n", $2.to_string().get().getString().c_str());
			   break;

			  case TNUMBER:
			   conprint("FPRINT TNUMBER %g\n", $2.to_number().get());
			   break;

			  case TCHARACTER:
			  {
			   String str = $2.to_string().get();
			   
			   String str2;
			   for (unsigned long i = 0, j = 0; i < str.length(); ++i)
			   {
			    if (str[i] == '\'')
			     continue;
			    else
			    {
			     str2[j] = str[i];
			     ++j;
			    }
			   }

			   conprint("FPRINT TCHARACTER \'%s\'\n", str2.getString().c_str());
			  }
			  break;

			  case TSTRING:
			   conprint("FPRINT TSTRING %s\n", $2.to_string().get().getString().c_str());
			   break;

			  default:
			   yyerror("Invalid exptype.");
			 }
			 tree.add_node(print_command);
			}
			| FPRINTLN
			{
			 ASTNode print_command("print_command");
			 conprint("FPRINTLN TVOID 0V\n");
			 tree.add_node(print_command);
			}
			| FPRINTLN expression
			{
			 ASTNode print_command("print_command");
			 switch (exptype)
			 {
			  case TVOID:
			   yyerror("Cannot println void expression.");
			   break;

			  case TBOOLEAN:
			   conprint("FPRINTLN TBOOLEAN %s\n", $2.to_string().get().getString().c_str());
			   break;

			  case TNUMBER:
			   conprint("FPRINTLN TNUMBER %g\n", $2.to_number().get());
			   break;

			  case TCHARACTER:
			  {
			   String str = $2.to_string().get();
			   
			   String str2;
			   for (unsigned long i = 0, j = 0; i < str.length(); ++i)
			   {
			    if (str[i] == '\'')
			     continue;
			    else
			    {
			     str2[j] = str[i];
			     ++j;
			    }
			   }

			   conprint("FPRINTLN TCHARACTER '%s'\n", str2.getString().c_str());
			  }
			  break;

			  case TSTRING:
                           conprint("FPRINTLN TSTRING \"%s\"\n", $2.to_string().get().getString().c_str());
			   break;

			  default:
			   yyerror("Invalid exptype.");
			 }
			 tree.add_node(print_command);
			}
			| PRINT ARRAY STRINGV
			{
			 ASTNode print_command("print_command");
			
			 conprint("APREP TSTRING %s\n", $3.to_string().get().getString().c_str());
			 conprint("APRINT TVOID 0V\n");

			 tree.add_node(print_command);
			}
			;

read_command:
			READ TYPE ID
			{
			 ASTNode read_command("read_command");

			 bool declared = false;
			 unsigned long address = 0;
	     		 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
		  	 {
	 		  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
    		           address = varTable[scope][i].address();
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " is not declared.";
			  yyerror(str.getString().c_str());
			 }


			 PNF_Variable v;
			 if ($2.to_string().get().getString() == "void")
			 {
			  yyerror("Cannot read a void.");
			 }
			 else if ($2.to_string().get().getString() == "boolean")
			 {
			  conprint("READ TBOOLEAN 0V\n");
			  ++varcount;
			 }
			 else if ($2.to_string().get().getString() == "number")
			 {
			  conprint("READ TNUMBER 0V\n");
			  ++varcount;
			 }
			 else if ($2.to_string().get().getString() == "character")
			 {
			  conprint("READ TCHARACTER 0V\n");
			  ++varcount;
			 }
			 else if ($2.to_string().get().getString() == "string")
			 {
			  conprint("READ TSTRING 0V\n");
			  ++varcount;
			 }
			 else
			  yyerror("Invalid type specifier.");


			 conprint("ATOC TVOID 0V\n");
			 conprint("VADD TVOID %u\n", address);
			 conprint("SWITCH TVOID 0V\n");
			 conprint("STOREA TVOID 0V\n");

			 tree.add_node(read_command);
			}
			| FREAD TYPE ID
			{
			 ASTNode read_command("read_command");

			 bool declared = false;
			 unsigned long address = 0;
	     		 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
		  	 {
	 		  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
    		           address = varTable[scope][i].address();
			  }
			 }

			 if (!declared)
			 {
			  String str = $3.to_string().get();
			  str += " is not declared.";
			  yyerror(str.getString().c_str());
			 }


			 PNF_Variable v;
			 if ($2.to_string().get().getString() == "void")
			 {
			  yyerror("Cannot read a void.");
			 }
			 else if ($2.to_string().get().getString() == "boolean")
			 {
			  conprint("FREAD TBOOLEAN 0V\n");
			  ++varcount;
			 }
			 else if ($2.to_string().get().getString() == "number")
			 {
			  conprint("FREAD TNUMBER 0V\n");
			  ++varcount;
			 }
			 else if ($2.to_string().get().getString() == "character")
			 {
			  conprint("FREAD TCHARACTER 0V\n");
			  ++varcount;
			 }
			 else if ($2.to_string().get().getString() == "string")
			 {
			  conprint("FREAD TSTRING 0V\n");
			  ++varcount;
			 }
			 else
			  yyerror("Invalid type specifier.");


			 conprint("ATOC TVOID 0V\n");
			 conprint("VADD TVOID %u\n", address);
			 conprint("SWITCH TVOID 0V\n");
			 conprint("STOREA TVOID 0V\n");


			 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
		  	 {
	 		  if (strcmp(varTable[scope][i].name().getString().c_str(), $3.to_string().get().getString().c_str()) == 0)
			  {
			   PNF_Number n(0);
			   v.put(n);
			   varTable[scope][i].value(v);
			   varTable[scope][i].address(varcount - 1);
			  }
			 }
			 tree.add_node(read_command);
			}
			;

end_command:
			END number_expression
			{
			 ASTNode end_command("end_command");
			 conprint("QUIT TVOID %g\n", $2.to_number().get());
			 tree.add_node(end_command);
			}
			;

asm_command:		ASM STRINGV STRINGV string_expression
			{
			 ASTNode asm_command("asm_command");
			 conprint("%s %s %s\n", strip_quotes($2.to_string().get()).getString().c_str(), 
					      strip_quotes($3.to_string().get()).getString().c_str(), strip_quotes($4.to_string().get()).getString().c_str());
			 tree.add_node(asm_command);
			}
			;

load_command:		LOAD RTYPE LTYPE number_expression
			{
			 ASTNode load_command("load_command");
			 if ($3.to_string().get().getString() == "memory")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			  {
			   switch ($4.getType())
			   {
			    case TBOOLEAN:
    			     conprint("LOAD TBOOLEAN %g\n", $4.to_number().get());
			     break;

			    case TNUMBER:
    	 		     conprint("LOAD TNUMBER %g\n", $4.to_number().get());
			     break;

			    case TCHARACTER:
    			     conprint("LOAD TCHARACTER %g\n", $4.to_number().get());
			     break;

			    case TSTRING:
    			     conprint("LOAD TSTRING %g\n", $4.to_number().get());
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			  else if ($2.to_string().get().getString() == "%calc")
			  {
			   switch ($4.getType())
			   {
			    case TBOOLEAN:
    			     conprint("LOADC TBOOLEAN %g\n", $4.to_number().get());
			     break;

			    case TNUMBER:
    	 		     conprint("LOADC TNUMBER %g\n", $4.to_number().get());
			     break;

			    case TCHARACTER:
    			     conprint("LOADC TCHARACTER %g\n", $4.to_number().get());
			     break;

			    case TSTRING:
    			     conprint("LOADC TSTRING %g\n", $4.to_number().get());
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			  else
			   yyerror("Invalid register type.");
			 }
			 else if ($3.to_string().get().getString() == "variable")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			  {
			   switch ($4.getType())
			   {
			    case TBOOLEAN:
    			     conprint("VLOAD TBOOLEAN %g\n", $4.to_number().get());
			     break;

			    case TNUMBER:
    			     conprint("VLOAD TNUMBER %g\n", $4.to_number().get());
			     break;

			    case TCHARACTER:
    			     conprint("VLOAD TCHARACTER %g\n", $4.to_number().get());
			     break;

			    case TSTRING:
    			     conprint("VLOAD TSTRING %g\n", $4.to_number().get());
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			  else if ($2.to_string().get().getString() == "%calc")
			  {
			   switch ($4.getType())
			   {
			    case TBOOLEAN:
    			     conprint("VLOADC TBOOLEAN %g\n", $4.to_number().get());
			     break;

			    case TNUMBER:
    			     conprint("VLOADC TNUMBER %g\n", $4.to_number().get());
			     break;

			    case TCHARACTER:
    			     conprint("VLOADC TCHARACTER %g\n", $4.to_number().get());
			     break;

			    case TSTRING:
    			     conprint("VLOADC TSTRING %g\n", $4.to_number().get());
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			 }
			 else if ($3.to_string().get().getString() == "args")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			   conprint("ARLOAD TVOID %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid register type.");
			 }
			 else if ($3.to_string().get().getString() == "aload")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
 			   conprint("ALOAD TNUMBER %g\n", $4.to_number().get());
			  else
                           yyerror("Invalid register type.");
			 }
			 else if ($3.to_string().get().getString() == "stk")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
                           conprint("LOADSP TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid register type.");
			 }
			 else if ($3.to_string().get().getString() == "seg1")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			   conprint("SEGLOAD TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror((char *)"Invalid register type.");
			 }
			 else
			  yyerror("Invalid load type.");

			 tree.add_node(load_command);
			}
			| LOAD RTYPE LTYPE TYPE
			{
			 ASTNode load_command("load_command");
			 if ($3.to_string().get().getString() == "tend")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			  {
 			   PNF_Type_Enum t;
			   String str = $4.to_string().get();
			   if (str.getString() == "void")
			    t = TVOID;
			   else if (str.getString() == "boolean")
			    t = TBOOLEAN;
			   else if (str.getString() == "number")
			    t = TNUMBER;
 	 		   else if (str.getString() == "character")
			    t = TCHARACTER;
			   else if (str.getString() == "string")
			    t = TSTRING;
			   else
			    yyerror("Invalid type specified.");

			   switch (t)
			   {
			    case TBOOLEAN:
    			     conprint("ELOAD TBOOLEAN 0V\n");
	 		     break;

			    case TNUMBER:
    			     conprint("ELOAD TNUMBER 0V\n");
			     break;

			    case TCHARACTER:
    			     conprint("ELOAD TCHARACTER 0V\n");
			     break;

			    case TSTRING:
    			     conprint("ELOAD TSTRING 0V\n");
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
		          }
			  else if ($2.to_string().get().getString() == "%calc")
			  {
 			   PNF_Type_Enum t;
			   String str = $4.to_string().get();
			   if (str.getString() == "void")
			    t = TVOID;
			   else if (str.getString() == "boolean")
			    t = TBOOLEAN;
			   else if (str.getString() == "number")
			    t = TNUMBER;
 	 		   else if (str.getString() == "character")
			    t = TCHARACTER;
			   else if (str.getString() == "string")
			    t = TSTRING;
			   else
			    yyerror("Invalid type specified.");

			   switch (t)
			   {
			    case TBOOLEAN:
    			     conprint("ELOADC TBOOLEAN 0V\n");
	 		     break;

			    case TNUMBER:
    			     conprint("ELOADC TNUMBER 0V\n");
			     break;

			    case TCHARACTER:
    			     conprint("ELOADC TCHARACTER 0V\n");
			     break;

			    case TSTRING:
    			     conprint("ELOADC TSTRING 0V\n");
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			  else
			   yyerror("Invalid load type.");
			 }
			 else
			  yyerror("Invalid register type.");

			 tree.add_node(load_command);
			}
			| LOAD LTYPE
			{
			 ASTNode load_command("load_command");
			 if ($2.to_string().get().getString() == "typeof")
			 {
			   conprint("TLOAD TVOID 0V\n");
			 }
			 else if ($2.to_string().get().getString() == "iname")
			 {
			  conprint("INLOAD TVOID 0V\n");
			 }
			 else if ($2.to_string().get().getString() == "icount")
			 {
			  conprint("ICLOAD TVOID 0V\n");
			 }
			 else if ($2.to_string().get().getString() == "aload")
			 {
			  conprint("ALOAD TVOID 0V\n");
			 }
			 else if ($2.to_string().get().getString() == "argn")
			 {
			  conprint("ARNLOAD TVOID 0V\n");
			 }
			 else if ($2.to_string().get().getString() == "stk")
			  conprint("LOADSTACK TVOID 0V\n");	 
			 else
			  yyerror("Invalid load type.");
			}
			| LOAD LTYPE boolean_expression
			{
			 ASTNode load_command("load_command");
			 if ($2.to_string().get().getString() == "aload")
			 {
			  conprint("ALOAD TBOOLEAN %s\n", $3.to_string().get().getString().c_str());
			 }			 else
			  yyerror("Invalid load type.");

			 tree.add_node(load_command);
			}
			| LOAD LTYPE number_expression
			{
			 ASTNode load_command("load_command");
			 if ($2.to_string().get().getString() == "aload")
			 {
			  conprint("ALOAD TNUMBER %g\n", $3.to_number().get());
			 }
			 else if ($2.to_string().get().getString() == "rvalue")
			 {
			  conprint("RNUM TNUMBER %d\n", (unsigned long)$3.to_number().get());
			  conprint("RETURNV TVOID 0V\n");
			 }			 
			 else
			  yyerror("Invalid load type.");

			 tree.add_node(load_command);
			}
			| LOAD LTYPE character_expression
			{
			 ASTNode load_command("load_command");
			 if ($2.to_string().get().getString() == "aload")
			 {
			  conprint("ALOAD TCHARACTER %c\n", $3.to_character().get());
			 }			 
			 else
			  yyerror("Invalid load type.");

			 tree.add_node(load_command);
			}
			| LOAD LTYPE string_expression
			{
			 ASTNode load_command("load_command");
			 if ($2.to_string().get().getString() == "aload")
			 {
			  conprint("ALOAD TSTRING %s\n", $3.to_string().get().getString().c_str());
			 }			 
			 else
			  yyerror("Invalid load type.");

			 tree.add_node(load_command);
			}
			| LOAD RTYPE LTYPE ID
			{
			 ASTNode load_command("load_command");

			 PNF_Variable p;
			 unsigned long paddress = 0;
                         bool declared = false;
	     		 for (unsigned long i = 0; i < varTable[scope].length(); ++i)
		  	 {
	 		  if (strcmp(varTable[scope][i].name().getString().c_str(), $4.to_string().get().getString().c_str()) == 0)
			  {
			   declared = true;
			   p.put(varTable[scope][i].value());
			   paddress = varTable[scope][i].address();			   
			   break;
			  }
			 }

			 if (!declared)
			 {
			  String str = $4.to_string().get();
			  str += " was not declared.";
			  yyerror(str.getString().c_str());
			 }

			 if ($3.to_string().get().getString() == "memory")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			  {
			   switch (p.getType())
			   {
			    case TBOOLEAN:
    			     conprint("LOAD TBOOLEAN %g\n", p.to_number().get());
			     break;

			    case TNUMBER:
    	 		     conprint("LOAD TNUMBER %g\n", p.to_number().get());
			     break;

			    case TCHARACTER:
    			     conprint("LOAD TCHARACTER %g\n", p.to_number().get());
			     break;

			    case TSTRING:
    			     conprint("LOAD TSTRING %g\n", p.to_number().get());
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			  else if ($2.to_string().get().getString() == "%calc")
			  {
			   switch (p.getType())
			   {
			    case TBOOLEAN:
    			     conprint("LOADC TBOOLEAN %g\n", p.to_number().get());
			     break;

			    case TNUMBER:
    	 		     conprint("LOADC TNUMBER %g\n", p.to_number().get());
			     break;

			    case TCHARACTER:
    			     conprint("LOADC TCHARACTER %g\n", p.to_number().get());
			     break;

			    case TSTRING:
    			     conprint("LOADC TSTRING %g\n", p.to_number().get());
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			  else
			   yyerror("Invalid register type.");
			 }
			 else if ($3.to_string().get().getString() == "variable")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			  {
			   switch (p.getType())
			   {
			    case TBOOLEAN:
    			     conprint("VLOAD TBOOLEAN %u\n", paddress);
			     break;

			    case TNUMBER:			     
    			     conprint("VLOAD TNUMBER %u\n", paddress);
			     break;

			    case TCHARACTER:
    			     conprint("VLOAD TCHARACTER %u\n", paddress);
			     break;

			    case TSTRING:
    			     conprint("VLOAD TSTRING %u\n", paddress);
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			  else if ($2.to_string().get().getString() == "%calc")
			  {
			   switch (p.getType())
			   {
			    case TBOOLEAN:
    			     conprint("VLOADC TBOOLEAN %u\n", paddress);
			     break;

			    case TNUMBER:
    			     conprint("VLOADC TNUMBER %u\n", paddress);
			     break;

			    case TCHARACTER:
    			     conprint("VLOADC TCHARACTER %u\n", paddress);
			     break;

			    case TSTRING:
    			     conprint("VLOADC TSTRING %u\n", paddress);
			     break;

			    default:
			     yyerror("Invalid load expression.");
			     break;
			   }
			  }
			 }
			 else if ($3.to_string().get().getString() == "args")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			   conprint("ARLOAD TVOID %g\n", p.to_number().get());
			  else
			   yyerror("Invalid register type.");
			 }
			 else if ($3.to_string().get().getString() == "aload")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			  {
			   switch (p.getType())
			   {
			    case TBOOLEAN:
			     conprint("ALOAD TBOOLEAN %s\n", p.to_string().get().getString().c_str());
			     break;

			    case TNUMBER:
			     conprint("ALOAD TNUMBER %g\n", p.to_number().get());
			     break;

			    case TCHARACTER:
			     conprint("ALOAD TCHARACTER %c\n", p.to_character().get());
			     break;

			    case TSTRING:
			     conprint("ALOAD TSTRING %s\n", p.to_string().get().getString().c_str());
			     break;

			    default:
			     yyerror("Invalid ID type.");
			     break;
			   }
			  }
			  else
                           yyerror("Invalid register type.");
			 }
			 else if ($3.to_string().get().getString() == "seg2")
			 {
			  if ($2.to_string().get().getString() == "%accmumulator")
			  {
			   conprint("SEGVLOAD TBOOLEAN %s\n", $4.to_boolean().get().getString().c_str());
			  }
			 }
			 else
			  yyerror("Invalid load type.");

			 tree.add_node(load_command);
			}
			| LOAD STYPE number_expression
			{
			 ASTNode load_command("load_command");

			 if ($2.to_string().get().getString() == "heve")
			  conprint("HEGET TVOID %g", $3.to_number().get());
			 else if ($2.to_string().get().getString() == "sheve")
			  conprint("SHEGET TVOID %g", $3.to_number().get());
			 else if ($2.to_string().get().getString() == "eve")
			  conprint("EGET TVOID %g", $3.to_number().get());
			 else if ($2.to_string().get().getString() == "exe")
			  conprint("EXGET TVOID %g", $3.to_number().get());
			 else if ($2.to_string().get().getString() == "int")
			  conprint("IGET TVOID %g", $3.to_number().get());
		  	 else
			  yyerror("Invalid subroutine type.");

			 tree.add_node(load_command);
			}
			| LOAD VTYPE2 STRINGV
			{
			 ASTNode load_command("load_command");

			 if ($2.to_string().get() == "venum")
			 {
			  conprint("EPREP TSTRING %s\n", $3.to_string().get().getString().c_str());
			  conprint("LOADE TVOID 0V\n");
			 }
			 else
			  yyerror("Invalid VTYPE2.");

			 tree.add_node(load_command);
			}
			| LOAD RANGE RTYPE2 STRINGV
			{
			 ASTNode load_command("load_command");

			 if ($3.to_string().get() == "rtype1")
			 {
			  conprint("RLOAD1 TSTRING %s\n", $4.to_string().get().getString().c_str());
			 }
			 else
			  yyerror("Invalid Range Type.");

			 tree.add_node(load_command);
			}
			| LOAD RANGE RTYPE2 STRINGV OPLSQ number_expression OPRSQ
			{
			 ASTNode load_command("load_command");

			 if ($3.to_string().get() == "rtype2")
			 {
			  conprint("RPREP2 TSTRING %s\n", $4.to_string().get().getString().c_str());
			  conprint("RLOAD2 TNUMBER %g\n", $6.to_number().get());
			 }
			 else
			  yyerror("Invalid Range Type.");

			 tree.add_node(load_command);
			}
			| LOAD ARRAY STRINGV OPLSQ number_expression OPRSQ
			{
			 ASTNode load_command("load_command");

			 conprint("APREP TSTRING %s\n", $3.to_string().get().getString().c_str());
			 conprint("AIPREP TNUMBER %g\n", $5.to_number().get());
			 conprint("LOADIA TVOID 0V\n");

			 tree.add_node(load_command);
			}
			| LOAD ARRAY STRINGV OPLSQ OPRSQ
			{
			 ASTNode load_command("load_command");

			 conprint("APREP TSTRING %s\n", $3.to_string().get().getString().c_str());
			 conprint("AIPREP TVOID 0V\n");
			 conprint("LOADIA TVOID 0V\n");

			 tree.add_node(load_command);
			}
			| LOAD signature2 LTYPE number_expression OPCOLON boolean_expression
			{
			 ASTNode load_command("load_command");
			 
			 if ($3.to_string().get() == "rvalue")
			 {
			  unsigned long index = funcstk.find(fsaveid.to_string().get(), frets6, fparams6);
			  if (index == -1)
			  {
			   yyerror("Function not found.");
			   exit(-1);
			  }

			  unsigned long rindex = (unsigned long)$4.to_number().get();

			  conprint("FNCLOAD TNUMBER %d\n", index);
			  conprint("RNUM TNUMBER %d\n", rindex);
			  conprint("ALOAD TBOOLEAN %s\n", $6.to_boolean().get().getString().c_str());
			  conprint("FNCSRET TBOOLEAN 0V\n");
			 }
			 else
			  yyerror("Bad LTYPE.");

			 tree.add_node(load_command);
			}
			nothing
			{
			 for (unsigned long i = frets6.length() - 1; i > 0; --i)
			  frets6.remove();

			 for (unsigned long i = fparams6.length() - 1; i > 0; --i)
			  fparams6.remove();
			}
			| LOAD signature2 LTYPE number_expression OPCOLON number_expression
			{
			 ASTNode load_command("load_command");
			 
			 if ($3.to_string().get() == "rvalue")
			 {
			  unsigned long index = funcstk.find(fsaveid.to_string().get(), frets6, fparams6);
			  if (index == -1)
			  {
			   yyerror("Function not found.");
			   exit(-1);
			  }

			  unsigned long rindex = (unsigned long)$4.to_number().get();

			  conprint("FNCLOAD TNUMBER %d\n", index);
			  conprint("RNUM TNUMBER %d\n", rindex);
			  conprint("ALOAD TNUMBER %g\n", $6.to_number().get());
			  conprint("FNCSRET TNUMBER 0V\n");
			 }
			 else
			  yyerror("Bad LTYPE.");

			 tree.add_node(load_command);
			}
			nothing
			{
			 for (unsigned long i = frets6.length() - 1; i > 0; --i)
			  frets6.remove();

			 for (unsigned long i = fparams6.length() - 1; i > 0; --i)
			  fparams6.remove();
			}
			| LOAD signature2 LTYPE number_expression OPCOLON character_expression
			{
			 ASTNode load_command("load_command");
			 
			 if ($3.to_string().get() == "rvalue")
			 {
			  unsigned long index = funcstk.find(fsaveid.to_string().get(), frets6, fparams6);
			  if (index == -1)
			  {
			   yyerror("Function not found.");
			   exit(-1);
			  }

			  unsigned long rindex = (unsigned long)$4.to_number().get();

			  conprint("FNCLOAD TNUMBER %d\n", index);
			  conprint("RNUM TNUMBER %d\n", rindex);
			  conprint("ALOAD TCHARACTER %c\n", $6.to_character().get());
			  conprint("FNCSRET TCHARACTER 0V\n");
			 }
			 else
			  yyerror("Bad LTYPE.");

			 tree.add_node(load_command);
			}
			nothing
			{
			 for (unsigned long i = frets6.length() - 1; i > 0; --i)
			  frets6.remove();

			 for (unsigned long i = fparams6.length() - 1; i > 0; --i)
			  fparams6.remove();
			}
			| LOAD signature2 LTYPE number_expression OPCOLON string_expression
			{
			 ASTNode load_command("load_command");
			 
			 if ($3.to_string().get() == "rvalue")
			 {
			  unsigned long index = funcstk.find(fsaveid.to_string().get(), frets6, fparams6);
			  if (index == -1)
			  {
			   yyerror("Function not found.");
			   exit(-1);
			  }

			  unsigned long rindex = (unsigned long)$4.to_number().get();

			  conprint("FNCLOAD TNUMBER %d\n", index);
			  conprint("RNUM TNUMBER %d\n", rindex);
			  conprint("ALOAD TSTRING %s\n", $6.to_string().get().getString().c_str());
			  conprint("FNCSRET TSTRING 0V\n");
			 }
			 else
			  yyerror("Bad LTYPE.");

			 tree.add_node(load_command);
			}
			nothing
			{
			 for (unsigned long i = frets6.length() - 1; i > 0; --i)
			  frets6.remove();

			 for (unsigned long i = fparams6.length() - 1; i > 0; --i)
			  fparams6.remove();
			}
			| LOAD STRUCT STRINGV
			{
			 if ($3.to_string().get().getString() == "\"get\"")
			 {
			  conprint("STRUCTGET TVOID 0V\n");
			 }
			 else if ($3.to_string().get().getString() == "\"type1\"")
			 {
			  conprint("STRUCTTYPE TVOID 0V\n");
			 }
			 else if ($3.to_string().get().getString() == "\"type2\"")
			 {
			  conprint("STRUCTTYPE2 TVOID 0V\n");
			 }
			 else if ($3.to_string().get().getString() == "\"name1\"")
			 {
			  conprint("STRUCTNAME2 TVOID 0V\n");
			 }
			 else if ($3.to_string().get().getString() == "\"name2\"")
			 {
			  conprint("STRUCTNAME3 TVOID 0V\n");
			 }
			 else
			  yyerror((char *)"Invalid load type.");
			}
			| LOAD UNION STRINGV
			{
			 if ($3.to_string().get().getString() == "\"get\"")
			 {
			  conprint("UNIONGET TVOID 0V\n");
			 }
			 else if ($3.to_string().get().getString() == "\"type1\"")
			 {
			  conprint("UNIONTYPE TVOID 0V\n");
			 }
			 else if ($3.to_string().get().getString() == "\"type2\"")
			 {
			  conprint("UNIONTYPE2 TVOID 0V\n");
			 }
			 else if ($3.to_string().get().getString() == "\"name1\"")
			 {
			  conprint("UNIONNAME2 TVOID 0V\n");
			 }
			 else if ($3.to_string().get().getString() == "\"name2\"")
			 {
			  conprint("UNIONNAME3 TVOID 0V\n");
			 }
			 else
			  yyerror((char *)"Invalid load type.");
			}
			| USE OTYPE ID
			{
			 if ($2.to_string().get().getString() == "tstruct")
			 {
			  conprint("STRUCTUSE TSTRING \"%s\"\n", $3.to_string().get().getString().c_str());
			 }
			 else if ($2.to_string().get().getString() == "tunion")
			 {
			  conprint("UNIONUSE TSTRING \"%s\"\n", $3.to_string().get().getString().c_str());
			 }
			 else
			  yyerror((char *)"Invalid object type.");
			}
			| LOAD RTYPE LTYPE TYPE number_expression
			{
			 if ($3.to_string().get().getString() == "seg2")
			 {
			  if ($2.to_string().get().getString() == "%accumulator")
			  {
			   switch ($4.getType())
			   {
		 	    case TVOID:
			    {
			     conprint("SEGVLOAD TVOID %g\n", $5.to_number().get());
			    }
			    break;

			    case TBOOLEAN:
			    {
			     conprint("SEGVLOAD TBOOLEAN %g\n", $5.to_number().get());
			    }
			    break;

			   case TNUMBER:
			    {
			     conprint("SEGVLOAD TNUMBER %g\n", $5.to_number().get());
			    }
			    break;

			    case TCHARACTER:
			    {
			     conprint("SEGVLOAD TCHARACTER %g\n", $5.to_number().get());
			    }
			    break;

			    case TSTRING:
			    {
			     conprint("SEGVLOAD TSTRING %g\n", $5.to_number().get());
			    }
			    break;

			    default:
			     yyerror((char *)"Invalid type.");
			   }
			  }
			  else
			   yyerror((char *)"Invalid register type.");
			 }
			 else
			  yyerror((char *)"Invalid load type.");
			}
			;

goto_command:		GOTO GTYPE number_expression
			{
			 ASTNode goto_command("goto_command");
			 if ($2.to_string().get().getString() == "normal")
			 {
			  conprint("GOTO TVOID %g\n", $3.to_number().get());
			 }
			 else if ($2.to_string().get().getString() == "condition")
			  conprint("CGOTO TVOID %g\n", $3.to_number().get());
			 else if ($2.to_string().get().getString() == "zero")
			  conprint("ZGOTO TVOID %g\n", $3.to_number().get());
			 else if ($2.to_string().get().getString() == "positive")
			  conprint("PGOTO TVOID %g\n", $3.to_number().get());
			 else if ($2.to_string().get().getString() == "negative")
			  conprint("NGOTO TVOID %g\n", $3.to_number().get());
			 else
			  yyerror("Invalid goto type.");

			 tree.add_node(goto_command);
			}
			| GOTO GTYPE ID
			{
			 ASTNode goto_command("goto_command");
			 if ($2.to_string().get().getString() == "normal")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if (labelTable[i].name().getString() == $3.to_string().get().getString())
			   {
			    declared = true;
			    conprint("GOTOL TVOID %u\n", labelTable[i].address());
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "condition")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if (labelTable[i].name().getString() == $3.to_string().get().getString())
			   {
			    declared = true;
			    conprint("CGOTOL TVOID %u\n", labelTable[i].address());
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "zero")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if (labelTable[i].name().getString() == $3.to_string().get().getString())
			   {
			    declared = true;
			    conprint("ZGOTOL TVOID %u\n", labelTable[i].address());
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "positive")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if (labelTable[i].name().getString() == $3.to_string().get().getString())
			   {
			    declared = true;
			    conprint("PGOTOL TVOID %u\n", labelTable[i].address());
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "negative")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if (labelTable[i].name().getString() == $3.to_string().get().getString())
			   {
			    declared = true;
			    conprint("NGOTOL TVOID %u\n", labelTable[i].address());
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else
			  yyerror("Invalid goto type.");

			 tree.add_node(goto_command);
			}
			;

operator_command:	OPPLUS
			{
			 ASTNode operator_command("operator_command");
			 conprint("ADD TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPPLUS number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("ADD TNUMBER %g\n", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPPLUS character_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("ADD TCHARACTER %c\n", $2.to_character().get());
			 tree.add_node(operator_command);
			}
			| OPPLUS string_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("ADD TSTRING %s\n", $2.to_string().get().getString().c_str());
			 tree.add_node(operator_command);
			}
			| OPMINUS
			{
			 ASTNode operator_command("operator_command");
			 conprint("SUB TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPSUB number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("SUB TNUMBER %g\n", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPTIMES
			{
			 ASTNode operator_command("operator_command");
			 conprint("MUL TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPTIMES number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("MUL TNUMBER %g\n", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPDIV
			{
			 ASTNode operator_command("operator_command");
			 conprint("DIV TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPDIV number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("DIV TNUMBER %g\n", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPMODULUS
			{
			 ASTNode operator_command("operator_command");
			 conprint("MOD TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPMODULUS number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("MOD TNUMBER %g\n", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPPOWER
			{
			 ASTNode operator_command("operator_command");
			 conprint("POW TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPPOWER number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("POW TNUMBER %g\n", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPROOT
			{
			 ASTNode operator_command("operator_command");
			 conprint("ROOT TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPROOT number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("ROOT TNUMBER %g\n", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPINC
			{
			 ASTNode operator_command("operator_command");
			 conprint("INC TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPDEC
			{
			 ASTNode operator_command("operator_command");
			 conprint("DEC TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPAND
			{
			 ASTNode operator_command("operator_command");
			 conprint("AND TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPOR
			{
			 ASTNode operator_command("operator_command");
			 conprint("OR TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPNOT
			{
			 ASTNode operator_command("operator_command");
			 conprint("NOT TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPEQU
			{
			 ASTNode operator_command("operator_command");
			 conprint("EQU TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPNEQU
			{
			 ASTNode operator_command("operator_command");
			 conprint("NEQU TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPLSS
			{
			 ASTNode operator_command("operator_command");
			 conprint("LSS TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPGTR
			{
			 ASTNode operator_command("operator_command");
			 conprint("GTR TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPLEQU
			{
			 ASTNode operator_command("operator_command");
			 conprint("LEQU TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPGEQU
			{
			 ASTNode operator_command("operator_command");
			 conprint("GEQU TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPEQU boolean_expression
			{
			 ASTNode operator_command("operator_command");

			 String str = $2.to_boolean().get();

			 conprint("EQU TBOOLEAN %s", str.getString().c_str());

			 tree.add_node(operator_command);
			}
			| OPNEQU boolean_expression
			{
			 ASTNode operator_command("operator_command");

			 String str = $2.to_boolean().get();

			 conprint("NEQU TBOOLEAN %s", str.getString().c_str());

			 tree.add_node(operator_command);
			}
			| OPEQU number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("EQU TNUMBER %g", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPNEQU number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("NEQU TNUMBER %g", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPLSS number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("LSS TNUMBER %g", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPGTR number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("GTR TNUMBER %g", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPLEQU number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("LEQU TNUMBER %g", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPGEQU number_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("GEQU TNUMBER %g", $2.to_number().get());
			 tree.add_node(operator_command);
			}
			| OPEQU character_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("EQU TCHARACTER %c", $2.to_character().get());
			 tree.add_node(operator_command);
			}
			| OPNEQU character_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("NEQU TCHARACTER %c", $2.to_character().get());
			 tree.add_node(operator_command);
			}
			| OPLSS character_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("LSS TCHARACTER %c", $2.to_character().get());
			 tree.add_node(operator_command);
			}
			| OPGTR character_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("GTR TCHARACTER %c", $2.to_character().get());
			 tree.add_node(operator_command);
			}
			| OPLEQU character_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("LEQU TCHARACTER %c", $2.to_character().get());
			 tree.add_node(operator_command);
			}
			| OPGEQU character_expression
			{
			 ASTNode operator_command("operator_command");
			 conprint("GEQU TCHARACTER %c", $2.to_character().get());
			 tree.add_node(operator_command);
			}
			| OPAMP
			{
			 ASTNode operator_command("operator_command");
			 conprint("BTAND TVOID 0V");
			 tree.add_node(operator_command);
			}
			| OPBTOR
			{
			 ASTNode operator_command("operator_command");
			 conprint("BTOR TVOID 0V");
			 tree.add_node(operator_command);
			}
			| OPBTXOR
			{
			 ASTNode operator_command("operator_command");
			 conprint("BTXOR TVOID 0V");
			 tree.add_node(operator_command);
			}
			| OPBTNOT
			{
			 ASTNode operator_command("operator_command");
			 conprint("BTNOT TVOID 0V");
			 tree.add_node(operator_command);
			}
			| OPBTSL
			{
			 ASTNode operator_command("operator_command");
			 conprint("BTSL TVOID 0V");
			 tree.add_node(operator_command);
			}
			| OPBTSR
			{
			 ASTNode operator_command("operator_command");
			 conprint("BTSR TVOID 0V");
			 tree.add_node(operator_command);
			}
			| top_command
			| OPCMP
			{
			 conprint("CMP TVOID 0V");
			}
			| OPSTRTIMES
			{
			 ASTNode operator_command("operator_command");
			 conprint("NTIMES TVOID 0V\n");
			 tree.add_node(operator_command);
			}
			| OPRUN RUNOPOP string_expression
			{
			 ASTNode operator_command("operator_command");
			 if ($2.to_string().get().getString() == "run")
			 {
			  conprint("RUN TSTRING %s", $3.to_string().get().getString().c_str());
			 }
			 else if ($2.to_string().get().getString() == "jrun")
			 {
			  conprint("JRUN TSTRING %s", $3.to_string().get().getString().c_str());
			 }
			 else if ($2.to_string().get().getString() == "pnfrun")
			 {
			  conprint("PNFRUN TSTRING %s", $3.to_string().get().getString().c_str());
			 }
			 else
			  yyerror((char *)"Bad run operator.");
			 tree.add_node(operator_command);
			}
			;


top_command:		stmt OPQUES
			{
			 ASTNode top_commandp1("top_commandp1");

			 intop = true;
			 ++topcounter;

			 conprint("IF TVOID 0V\n");
			 conprint("IFBEGIN TVOID 0V\n");

			 tree.add_node(top_commandp1);
			}
			{
			 ASTNode top_commandp2("top_commandp2");			 

			 tree.add_node(top_commandp2);
			}
			stmt
			{
			 ASTNode top_commandp3("top_commandp3");

			conprint("IFEND TVOID 0V\n"); 
			conprint("ENDIF TVOID 0V\n");

			 tree.add_node(top_commandp3);
			}
 			OPCOLON
			{
			 ASTNode top_commandp4("top_commandp4");

			 conprint("IFELSE TVOID 0V\n");
			 conprint("IFBEGIN TVOID 0V\n");

			 tree.add_node(top_commandp4);
			}
			stmt
			{
			 ASTNode top_commandp5("top_commandp5");

			 conprint("IFEND TVOID 0V\n");
			 conprint("ENDIFELSE TVOID 0V\n");
			 conprint("EIF TVOID 0V\n");

			 tree.add_node(top_commandp5);
			}
			;

st_command:		ST
			{
			 ASTNode st_command("st_command");
			 conprint("ST TVOID 0V\n");
			 tree.add_node(st_command);
			}
			;

stack_command:		PUSH
			{
			 ASTNode stack_command("stack_command");
			 conprint("PUSH TVOID 0V\n");
			 tree.add_node(stack_command);
			}
			| POP
			{
			 ASTNode stack_command("stack_command");
			 conprint("POP TVOID 0V\n");
			 tree.add_node(stack_command);
			}
			;

typeof_command:		TYPEOF RTYPE
			{
			 ASTNode typeof_command("typeof_command");
			 if ($2.to_string().get().getString() == "%accumulator")
  			  conprint("TYPEOF TVOID 0V\n");
			 else if ($2.to_string().get().getString() == "%calc")
  			  conprint("CTYPEOF TVOID 0V\n");
                         else
			  yyerror("Invalid register type.");
			 tree.add_node(typeof_command);
			}
			;

rm_command:		ATOC
			{
			 ASTNode rm_command("rm_command");
			 conprint("ATOC TVOID 0V\n");
			 tree.add_node(rm_command);
			}
			| ATOSP
			{
			 conprint("ATOSP TVOID 0V\n");
			}
			| SPTOA
			{
			 conprint("SPTOA TVOID 0V\n");
			}
			| SWITCH
			{
			 ASTNode rm_command("rm_command");
			 conprint("SWITCH TVOID 0V\n");
			 tree.add_node(rm_command);
			}
			;

crash_command:		CRASH string_expression
			{
			 ASTNode crash_command("crash_command");
			 conprint("CRASH TSTRING %s", $2.to_string().get().getString().c_str());
			 tree.add_node(crash_command);
			}
			;

version_command:	VERSION VTYPE number_expression
			{
			 ASTNode version_command("version_command");

			 if ($2.to_string().get().getString() == "pnf")
  			  conprint("VERSION TVOID %f\n", $3.to_number().get());
			 else if ($2.to_string().get() == "pnfasm")
			  conprint("version TVOID 0V\n");
			 else if ($2.to_string().get().getString() == "normal")
  			  ; // Not used yet. This is the first version.
                         else
			  yyerror("Invalid version type.");

			 tree.add_node(version_command);
			}
			| MODE number_expression
			{
			 ASTNode version_command("version_command");

			 conprint("MODE TVOID %f\n", $2.to_number().get());


			 tree.add_node(version_command);
			}
			| EXTMODE number_expression
			{
			 ASTNode version_command("version_command");

			 conprint("EXTMODE TVOID %f\n", $2.to_number().get());

			 tree.add_node(version_command);
			}
			;

halt_command:		HALT
			{
			 ASTNode halt_command("halt_command");
			 conprint("HALT TVOID 0V\n");
			 tree.add_node(halt_command);
			}
			;

modt_command:		MODT RTYPE
			{
			 ASTNode modt_command("modt_command");

			 if ($2.to_string().get().getString() == "%accumulator")
  			  conprint("MODT TVOID 0V\n");
			 else if ($2.to_string().get().getString() == "%calc")
  			  conprint("MODCT TVOID 0V\n");
                         else
			  yyerror("Invalid register type.");

			 tree.add_node(modt_command);
			}
			;

subroutine_command:	RETURN
			{
 			 ASTNode subroutine_command("subroutine_command");
			 conprint("RET TVOID 0V\n");
			 tree.add_node(subroutine_command);
			}
			| GOSUB number_expression
			{
 			 ASTNode subroutine_command("subroutine_command");
			 conprint("CALL TVOID %g\n", $2.to_number().get());
			 tree.add_node(subroutine_command);
			}
			| GOSUB STYPE ID
			{
 			 ASTNode subroutine_command("subroutine_command");

			 if ($2.to_string().get().getString() == "sub")
			 {
 			  bool declared = false;
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == labelTable[i].name().getString())
			   {
			    declared = true;
			    double d = labelTable[i].address();
			    conprint("CALLL TVOID %g\n", d);
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "heve")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = CELabel::hevents();
			    conprint("HEVENT TVOID %g\n", d);
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "sheve")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = CELabel::shevents();
			    conprint("SHEVENT TVOID %g\n", d);
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "eve")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = CELabel::events();
			    conprint("EVENT TVOID %g\n", d);
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "exe")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = CELabel::exceptions();
			    conprint("EXCEPTION TVOID %g\n", d);
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "int")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = CELabel::ints();
			    conprint("INT TVOID %g\n", d);
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else
			  yyerror("Invalid subroutine type.");

			 tree.add_node(subroutine_command);
			}
			;

register_command:	UNREGISTER STYPE
			{
 			 ASTNode register_command("register_command");

			 if ($2.to_string().get().getString() == "heve")
			 {
			  conprint("HEREM TVOID 0V\n");
 			  CELabel::dechevents();
			 }
			 else if ($2.to_string().get().getString() == "sheve")
			 {
			  conprint("SHEREM TVOID 0V\n");
 			  CELabel::decshevents();
			 }
			 else if ($2.to_string().get().getString() == "eve")
			 {
			  conprint("EREM TVOID 0V\n");
 			  CELabel::decevents();
                         }
			 else if ($2.to_string().get().getString() == "exe")
			 {
			  conprint("EXREM TVOID 0V\n");
 			  CELabel::decexceptions();
			 }
			 else if ($2.to_string().get().getString() == "int")
			 {
			  conprint("IREM TVOID 0V\n");
 			  CELabel::decints();
                         }
			 else
			  yyerror("Invalid subroutine type.");

			 tree.add_node(register_command);
			}
			| REGISTER STYPE ID
			{
 			 ASTNode register_command("register_command");

			 if ($2.to_string().get().getString() == "heve")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = eventLabelTable[i].address();
			    conprint("HEADD TVOID %g\n", d);
			    if (CELabel::hevents() != 0)
 			     CELabel::inchevents();
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "sheve")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = eventLabelTable[i].address();
			    conprint("SHEADD TVOID %g\n", d);
			    if (CELabel::shevents() != 0)
			     CELabel::incshevents();
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "eve")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = eventLabelTable[i].address();
			    conprint("EADD TVOID %g\n", d);
			    if (CELabel::events() != 0)
 			     CELabel::incevents();
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "exe")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = eventLabelTable[i].address();
			    conprint("EXADD TVOID %g\n", d);
			    if (CELabel::exceptions() != 0)
			     CELabel::incexceptions();
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else if ($2.to_string().get().getString() == "int")
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared = true;
			    double d = eventLabelTable[i].address();
			    conprint("IADD TVOID %g\n", d);
			    if (CELabel::ints() != 0)
			     CELabel::incints();
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }
			 else
			  yyerror("Invalid subroutine type.");

			 tree.add_node(register_command);
			}
			| REREGISTER STYPE ID ID
			{
 			 ASTNode register_command("register_command");

			 if ($2.to_string().get().getString() == "heve")
			 {
			  bool declared1 = false;
			  bool declared2 = false;
			  double d1;
			  double d2;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared1 = true;
			    d1 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared1)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($4.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared2 = true;
			    d2 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared2)
			  {
			   String str = $4.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  conprint("EVLOAD TVOID %g\n", d1);
			  conprint("HEED TVOID %g\n", d2);
			 }
			 else if ($2.to_string().get().getString() == "sheve")
			 {
			  bool declared1 = false;
			  bool declared2 = false;
			  double d1;
			  double d2;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared1 = true;
			    d1 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared1)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($4.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared2 = true;
			    d2 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared2)
			  {
			   String str = $4.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  conprint("EVLOAD TVOID %g\n", d1);
			  conprint("SHEED TVOID %g\n", d2);
			 }
			 else if ($2.to_string().get().getString() == "eve")
			 {
			  bool declared1 = false;
			  bool declared2 = false;
			  double d1;
			  double d2;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared1 = true;
			    d1 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared1)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($4.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared2 = true;
			    d2 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared2)
			  {
			   String str = $4.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  conprint("EVLOAD TVOID %g\n", d1);
			  conprint("EED TVOID %g\n", d2);
			 }
			 else if ($2.to_string().get().getString() == "exe")
			 {
			  bool declared1 = false;
			  bool declared2 = false;
			  double d1;
			  double d2;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared1 = true;
			    d1 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared1)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($4.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared2 = true;
			    d2 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared2)
			  {
			   String str = $4.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  conprint("EVLOAD TVOID %g\n", d1);
			  conprint("EXED TVOID %g\n", d2);
			 }
			 else if ($2.to_string().get().getString() == "int")
			 {
			  bool declared1 = false;
			  bool declared2 = false;
			  double d1;
			  double d2;
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared1 = true;
			    d1 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared1)
			  {
			   String str = $3.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($4.to_string().get().getString() == eventLabelTable[i].name().getString())
			   {
			    declared2 = true;
			    d2 = eventLabelTable[i].address();
			   }
			  }

			  if (!declared2)
			  {
			   String str = $4.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }


			  conprint("EVLOAD TVOID %g\n", d1);
			  conprint("IED TVOID %g\n", d2);
			 }
			 else
			  yyerror("Invalid subroutine type.");

			 tree.add_node(register_command);
			}
			| REGISTER BLANK STYPE number_expression
			{
			 ASTNode register_command("register_command");

			 if ($3.to_string().get() == "heve")
			  conprint("HEADDB TVOID %g\n", $4.to_number().get());
			 else if ($3.to_string().get() == "sheve")
			  conprint("SHEADDB TVOID %g\n", $4.to_number().get());
			 else if ($3.to_string().get() == "eve")
			  conprint("EADDB TVOID %g\n", $4.to_number().get());
			 else if ($3.to_string().get() == "exe")
			  conprint("EXADDB TVOID %g\n", $4.to_number().get());
			 else if ($3.to_string().get() == "int")
			  conprint("IADDB TVOID %g\n", $4.to_number().get());
			 else
			  yyerror("Invalid STYPE.");

			 tree.add_node(register_command);
			}
			;

store_command:		STORE RTYPE LTYPE number_expression
			{
 			 ASTNode store_command("store_command");

			 if ($2.to_string().get().getString() == "%accumulator")
			 {
			  if ($3.to_string().get().getString() == "memory")
			   conprint("STORE TVOID %g", $4.to_number().get());
			  else if ($3.to_string().get().getString() == "variable")
			  {
			   conprint("VSTORE TVOID %g", $4.to_number().get());
			  }
			  else if ($3.to_string().get().getString() == "stk")
			   conprint("STORESP TNUMBER %g\n", $4.to_number().get());
			  else if ($3.to_string().get().getString() == "seg1")
			   conprint("SEGSTORE TNUMBER %g\n", $4.to_number().get());
			  else if ($3.to_string().get().getString() == "seg2")
			   conprint("SEGVSTORE TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid store type.");
			 }
			 else if ($2.to_string().get().getString() == "%calc")
			 {
			  if ($3.to_string().get().getString() == "memory")
			   conprint("STOREC TVOID %g", $4.to_number().get());
			  else if ($3.to_string().get().getString() == "variable")
			  {
			   conprint("VSTOREC TVOID %g", $4.to_number().get());
			  }
			  else
			   yyerror("Invalid store type.");
			 }
			 else
			  yyerror("Invalid register type.");

			 tree.add_node(store_command);
			}
			| STORE LTYPE
			{
			 if ($2.to_string().get().getString() == "stk")
			 {
			  conprint("STORESTACK TVOID 0V\n");
			 }
			 else
			  yyerror("Invalid store type.");
			}
			| STORE RTYPE LTYPE
			{
 			 ASTNode store_command("store_command");

			 if ($2.to_string().get().getString() == "%accumulator")
			 {
			  if ($3.to_string().get().getString() == "variable")
			  {
			   conprint("VSTORE TVOID 0V");
			   ++varcount;
			  }
			  else if ($3.to_string().get().getString() == "tend")
			   conprint("ESTORE TVOID 0V");
			 else if ($3.to_string().get().getString() == "seg2")
			 {
			  conprint("SEGVSTORE TVOID 0V\n");
			 }
			  else
			   yyerror("Invalid store type.");
			 }
			 else if ($2.to_string().get().getString() == "%calc")
			 {
			  if ($3.to_string().get().getString() == "variable")
			  {
			   conprint("VSTOREC TVOID 0V");
		 	   ++varcount;
			  }
			  else if ($3.to_string().get().getString() == "tend")
			   conprint("ESTOREC TVOID 0V");
			  else
			   yyerror("Invalid store type.");
			 }
			 else
			  yyerror("Invalid register type.");

			 tree.add_node(store_command);
			}
			| STORE STOREA
			{
 			 ASTNode store_command("store_command");

			 conprint("STOREA TVOID 0V\n");

			 tree.add_node(store_command);
			}
			| STORE VTYPE2 STRINGV
			{
 			 ASTNode store_command("store_command");

			 if ($2.to_string().get() == "venum")
			 {
			  conprint("EPREP TSTRING %s\n", $3.to_string().get().getString().c_str());
			  conprint("STOREE TVOID 0V\n");
			 }
			 else
			  yyerror("Invalid VTYPE2.");

			 tree.add_node(store_command);
			}
			| STORE RANGE RTYPE2 STRINGV
			{
 			 ASTNode store_command("store_command");

			 if ($3.to_string().get() == "rtype1")
			 {
			  conprint("RSTORE1 TSTRING %s\n", $4.to_string().get().getString().c_str());
			 }
			 else
			  yyerror("Invalid Range Type.");

			 tree.add_node(store_command);
			}
			| STORE ARRAY STRINGV OPLSQ number_expression OPRSQ
			{
			 ASTNode store_command("store_command");

			 conprint("APREP TSTRING %s\n", $3.to_string().get().getString().c_str());
			 conprint("AIPREP TNUMBER %g\n", $5.to_number().get());
			 conprint("STOREIA TVOID 0V\n");

			 tree.add_node(store_command);
			}
			| STORE ARRAY STRINGV OPLSQ OPRSQ
			{
			 ASTNode store_command("store_command");

			 conprint("APREP TSTRING %s\n", $3.to_string().get().getString().c_str());
			 conprint("AIPREP TVOID 0V\n");
			 conprint("STOREIA TVOID 0V\n");

			 tree.add_node(store_command);
			}
			;

break_command:		BREAK
			{
			 ASTNode break_command("break_command");

			 if (inswitch)
			  conprint("SWBREAK TVOID 0V\n");
			 else if (inwhile)
			  conprint("GOTOL TSTRING \"while_end_%u\"\n", whilecounter);
			 else if (indowhile)
			  conprint("GOTOL TSTRING \"dowhile_end_%u\"\n", dowhilecounter);
			 else if (infor)
			  conprint("GOTOL TSTRING \"for_end_%u\"\n", forcounter);
			 else if (indofor)
			  conprint("GOTOL TSTRING \"dofor_end_%u\"\n", doforcounter);
			 else if (breakinforever)
			  conprint("GOTOL TSTRING \"forever_end_%u\"\n", forevercounter);
  			 tree.add_node(break_command);
			}
			| BREAK ID
			{
			 ASTNode break_command("break_command");

			 if (inswitch || inloop2)
			 {
			  bool declared = false;
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if (labelTable[i].name().getString() == $2.to_string().get().getString())
			   {
			    declared = true;
			    conprint("GOTOL TVOID %u\n", labelTable[i].address());
			   }
			  }

			  if (!declared)
			  {
			   String str = $2.to_string().get();
			   str += " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			 }

  			 tree.add_node(break_command);
			}
			;

address_command:	ADDRESSOF ATYPE ID
			{
			 ASTNode address_command("address_command");

			 unsigned long address = 0;
			 bool declared = false;
			 if ($2.to_string().get() == "avariable")
			 {
			  for (unsigned long i = 0; i < varTable[scope].length(); ++i)
			  {
			   if ($3.to_string().get() == varTable[scope][i].name())
			   {
			    declared = true;
			    address = varTable[scope][i].address();
			    break;
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get() + " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			  else
			  {
			   if (varTable.length() == 1)
                            --address;

			   conprint("VADD TVOID %u\n", address);
			  }
			 }
			 else if ($2.to_string().get() == "alabel")
			 {
			  for (unsigned long i = 0; i < labelTable.length(); ++i)
			  {
			   if ($3.to_string().get() == labelTable[i].name())
			   {
		            declared = true;
			    address = i - 1;
			    break;
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get() + " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			  conprint("LADD TVOID %u\n", address);
			 }
			 else if ($2.to_string().get() == "aevent")
			 {
			  for (unsigned long i = 0; i < eventLabelTable.length(); ++i)
			  {
			   if ($3.to_string().get() == eventLabelTable[i].name())
			   {
		            declared = true;
			    address = i - 1;
			    break;
			   }
			  }

			  if (!declared)
			  {
			   String str = $3.to_string().get() + " was not declared.";
			   yyerror(str.getString().c_str());
			  }
			  conprint("EADD TVOID %u\n", address);
			 }
			 else
			 {
			  yyerror("Invalid address type.");
			 }

			 tree.add_node(address_command);
			}
			;

add2v_command:		ADD2V
			{
			 ASTNode add2v_command("add2v_command");

			 conprint("ADD2V TVOID 0V\n");

		         tree.add_node(add2v_command);
			}
			;

continue_command:	CONTINUE
			{
			 ASTNode continue_command("continue_command");

			 if (inwhile)
			  conprint("GOTOL TSTRING \"while_test_%u\"\n", whilecounter);
			 else if (indowhile)
			  conprint("GOTOL TSTRING \"dowhile_body_%u\"\n", dowhilecounter);
			 else if (infor)
			  conprint("GOTOL TSTRING \"for_increment_statement_%u\"\n", forcounter);
			 else if (indofor)
			  conprint("GOTOL TSTRING \"dofor_increment_statement_%u\"\n", doforcounter);
			 else if (breakinforever)
			  conprint("GOTOL TSTRING \"forever_%u\"\n", forevercounter);

		         tree.add_node(continue_command);
			}
			;

check_command:		CHECK CTYPE TYPE number_expression
			{
			 ASTNode check_command("check_command");

			 if ($2.to_string().get() == "current_ver")
			 {
			  if ($3.to_string().get() == "void")
			   conprint("VCHECK TVOID %g\n", $4.to_number().get());
			  else if ($3.to_string().get() == "number")
			   conprint("VCHECK TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "ver")
			 {
			  if ($3.to_string().get() == "void")
			   conprint("VSUPP TVOID %g\n", $4.to_number().get());
			  else if ($3.to_string().get() == "number")
			   conprint("VSUPP TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "current_vmode")
			 {
			  if ($3.to_string().get() == "void")
			   conprint("MCHECK TVOID %g\n", $4.to_number().get());
			  else if ($3.to_string().get() == "number")
			   conprint("MCHECK TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "vmode")
			 {
			  if ($3.to_string().get() == "void")
			   conprint("MSUPP TVOID %g\n", $4.to_number().get());
			  else if ($3.to_string().get() == "number")
			   conprint("MSUPP TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "current_extvmode")
			 {
			  if ($3.to_string().get() == "void")
			   conprint("MEXTCHECK TVOID %g\n", $4.to_number().get());
			  else if ($3.to_string().get() == "number")
			   conprint("MEXTCHECK TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "extvmode")
			 {
			  if ($3.to_string().get() == "void")
			   conprint("MEXTSUPP TVOID %g\n", $4.to_number().get());
			  else if ($3.to_string().get() == "number")
			   conprint("MEXTSUPP TNUMBER %g\n", $4.to_number().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else
			  yyerror("Invalid check type.");

		         tree.add_node(check_command);
			}
			| CHECK CTYPE TYPE boolean_expression
			{
			 ASTNode check_command("check_command");

			 if ($2.to_string().get() == "current_ver")
			 {
			  if ($3.to_string().get() == "boolean")
			   conprint("VCHECK TBOOLEAN %s\n", $4.to_boolean().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "ver")
			 {
			  if ($3.to_string().get() == "boolean")
			   conprint("VSUPP TBOOLEAN %s\n", $4.to_boolean().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "current_vmode")
			 {
			  if ($3.to_string().get() == "boolean")
			   conprint("MCHECK TBOOLEAN %s\n", $4.to_boolean().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "vmode")
			 {
			  if ($3.to_string().get() == "boolean")
			   conprint("MSUPP TBOOLEAN %s\n", $4.to_boolean().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "current_extvmode")
			 {
			  if ($3.to_string().get() == "boolean")
			   conprint("MEXTCHECK TBOOLEAN %s\n", $4.to_boolean().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "extvmode")
			 {
			  if ($3.to_string().get() == "boolean")
			   conprint("MEXTSUPP TBOOLEAN %s\n", $4.to_boolean().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 else
			  yyerror("Invalid check type.");

		         tree.add_node(check_command);
			}
			| CHECK CTYPE TYPE character_expression
			{
			 ASTNode check_command("check_command");

			 if ($2.to_string().get() == "current_ver")
			 {
			  if ($3.to_string().get() == "character")
			   conprint("VCHECK TCHARACTER %c\n", $4.to_character().get());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "ver")
			 {
			  if ($3.to_string().get() == "character")
			   conprint("VSUPP TCHARACTER %c\n", $4.to_character().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "current_vmode")
			 {
			  if ($3.to_string().get() == "character")
			   conprint("MCHECK TCHARACTER %c\n", $4.to_character().get());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "vmode")
			 {
			  if ($3.to_string().get() == "character")
			   conprint("MSUPP TCHARACTER %c\n", $4.to_character().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "current_extvmode")
			 {
			  if ($3.to_string().get() == "character")
			   conprint("MEXTCHECK TCHARACTER %c\n", $4.to_character().get());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "extvmode")
			 {
			  if ($3.to_string().get() == "character")
			   conprint("MEXTSUPP TCHARACTER %c\n", $4.to_character().get());
			  else
			   yyerror("Invalid type.");
			 }
			 else
			  yyerror("Invalid check type.");

		         tree.add_node(check_command);
			}
			| CHECK CTYPE TYPE string_expression
			{
			 ASTNode check_command("check_command");

			 if ($2.to_string().get() == "current_ver")
			 {
			  if ($3.to_string().get() == "string")
			   conprint("VCHECK TSTRING %s\n", $4.to_string().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "ver")
			 {
			  if ($3.to_string().get() == "string")
			   conprint("VSUPP TSTRING %s\n", $4.to_string().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "current_vmode")
			 {
			  if ($3.to_string().get() == "string")
			   conprint("MCHECK TSTRING %s\n", $4.to_string().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "vmode")
			 {
			  if ($3.to_string().get() == "string")
			   conprint("MSUPP TSTRING %s\n", $4.to_string().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 else if ($2.to_string().get() == "current_extvmode")
			 {
			  if ($3.to_string().get() == "string")
			   conprint("MEXTCHECK TSTRING %s\n", $4.to_string().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 if ($2.to_string().get() == "extvmode")
			 {
			  if ($3.to_string().get() == "string")
			   conprint("MEXTSUPP TSTRING %s\n", $4.to_string().get().getString().c_str());
			  else
			   yyerror("Invalid type.");
			 }
			 else
			  yyerror("Invalid check type.");

		         tree.add_node(check_command);
			}
			| CHECK CTYPE number_expression
			{
			 ASTNode check_command("check_command");

			 if ($2.to_string().get() == "instruction")
			 {
   		          conprint("ISUPP TNUMBER %g\n", $3.to_number().get());
			 }
			 if ($2.to_string().get() == "type")
			 {
			  conprint("TSUPP TNUMBER %g\n", $3.to_number().get());
			 }
			 else
			  yyerror("Invalid check type.");

		         tree.add_node(check_command);
			}
			;

comment_command:	HCMNT CMTYPE string_expression
			{
			 ASTNode comment_command("comment_command");

			 if ($2.to_string().get() == "l2")
			 {
			  String str = strip_quotes($3.to_string().get());
			  conprint(";\\ %s\n", str.getString().c_str());
			 }
			 else if ($2.to_string().get() == "l1")
			 {
			  conprint("COMMENT TSTRING %s\n", $3.to_string().get().getString().c_str());
			 }
			 else
			 {
			  yyerror("Invalid comment type.");
                         }

		         tree.add_node(comment_command);
			}
			;

file_command:		FMODE BFMODEC FMODEC
			{
			 ASTNode file_command("file_command");

			 if ($2.to_string().get() == "input")
			 {
			  if ($3.to_string().get() == "in")
			   conprint("FIMODE TSTRING \"in\"\n");
			  else if ($3.to_string().get() == "binary")
			   conprint("FIMODE TSTRING \"binary\"\n");
			  else
			   yyerror("Invalid file mode command.");
			 }
			 else if ($2.to_string().get() == "output")
			 {
			  if ($3.to_string().get() == "out")
			   conprint("FOMODE TSTRING \"out\"\n");
			  else if ($3.to_string().get() == "binary")
			   conprint("FOMODE TSTRING \"binary\"\n");
			  else if ($3.to_string().get() == "ate")
			   conprint("FOMODE TSTRING \"ate\"\n");
			  else if ($3.to_string().get() == "app")
			   conprint("FOMODE TSTRING \"app\"\n");
			  else if ($3.to_string().get() == "trunc")
			   conprint("FOMODE TSTRING \"trunc\"\n");
			  else
			   yyerror("Invalid file mode command.");
			 }
			 else
			  yyerror("Invalid basic file mode command.");

			 tree.add_node(file_command);
			}
			| FOPEN BFMODEC string_expression
			{
			 ASTNode file_command("file_command");

			 if ($2.to_string().get() == "input")
			 {
			  conprint("FIOPEN TSTRING %s\n", $3.to_string().get().getString().c_str());
			 }
			 else if ($2.to_string().get() == "output")
			 {
  			  conprint("FOOPEN TSTRING %s\n", $3.to_string().get().getString().c_str());
			 }
			 else
			  yyerror("Invalid basic file mode command.");

			 tree.add_node(file_command);
			}
			| FCLOSE BFMODEC
			{
			 ASTNode file_command("file_command");

			 if ($2.to_string().get() == "input")
			 {
			  conprint("FICLOSE TVOID 0V\n");
			 }
			 else if ($2.to_string().get() == "output")
			 {
  			  conprint("FOCLOSE TVOID 0V\n");
			 }
			 else
			  yyerror("Invalid basic file mode command.");

			 tree.add_node(file_command);
			}
			| FEOF
			{
			 ASTNode file_command("file_command");

			 conprint("FIEOF TVOID 0V\n");

			 tree.add_node(file_command);
			}			
			;

meml_command:		MEML
			{
			 ASTNode meml_command("meml_command");

			 conprint("MEML TVOID 0V\n");

			 tree.add_node(meml_command);
			}
			;

pnfasm_command:		PNFASM STRINGV STRINGV STRINGV
			{
			 ASTNode pnfasm_command("pnfasm_command");

			 conprint("pnf %s %s %s\n", strip_quotes($2.to_string().get()).getString().c_str(), 
						 strip_quotes($3.to_string().get()).getString().c_str(), strip_quotes($4.to_string().get()).getString().c_str());

			 tree.add_node(pnfasm_command);
			}
			;

array_length_command:	ARRAY STRINGV OPDOT LENGTH
			{
			 ASTNode array_length_command("array_length_command");
			
			 conprint("APREP TSTRING %s\n", $2.to_string().get().getString().c_str());
			 conprint("ALENGTH TVOID 0V\n");

			 tree.add_node(array_length_command);
			}

dup_command:		DUP RTYPE
			{
			 ASTNode dup_command("dup_command");

			 if ($2.to_string().get() == "%accumulator")
			 {
			  conprint("DUP TVOID 0V\n");
			 }
			 else if ($2.to_string().get() == "%calc")
			 {
			  conprint("CDUP TVOID 0V\n");
			 }
			 else
			  yyerror((char *)"Invalid register.");

			 tree.add_node(dup_command);
			}
			;

fret_command:		FRET
			{
			 conprint("FRET TVOID 0V\n");
			}
			;

parameter_command:	psig
			| psig2
			;

psig:			signature ID TYPE
			{
			 unsigned long index = funcstk.find(fsaveid.to_string().get(), frets5, fparams5);
			 if (index == -1)
			 {
			  yyerror("Function not found.");
			  exit(-1);
			 }

			 bool declared = false;
			 unsigned long pindex = 0;
			 for (unsigned long i = 0; i < funcps[index].length(); ++i)
			 {
			  if (funcps[index][i].name() == $2.to_string().get())
			  {
			   declared = true;
			   pindex = i;
			   break;
			  }
			 }

			 if (!declared)
			 {
			  yyerror("Parameter not declared.");
			  exit(-1);
			 }
	
			 conprint("PNUM TNUMBER %d\n", pindex);
			 conprint("ALOAD TNUMBER %d\n", index);
			
			 String str = $3.to_string().get();
			 if (str == "void")
			   conprint("PARAMF2 TVOID 0V\n");
		         else if (str == "boolean")
			   conprint("PARAMF2 TBOOLEAN 0V\n");
			 else if (str == "number")
			   conprint("PARAMF2 TNUMBER 0V\n");
			 else if (str == "character")
			   conprint("PARAMF2 TCHARACTER 0V\n");
			 else if (str == "string")
			   conprint("PARAMF2 TSTRING 0V\n");
			 else
			   yyerror("Invalid type.");
			}
			nothing
			{
			 for (unsigned long i = frets5.length() - 1; i > 0; --i)
			  frets5.remove();

			 for (unsigned long i = fparams5.length() - 1; i > 0; --i)
			  fparams5.remove();
			}
			;

psig2:			signature ID TYPE TYPE
			{
			 unsigned long index = funcstk.find(fsaveid.to_string().get(), frets5, fparams5);
			 if (index == -1)
			 {
			  yyerror("Function not found.");
			  exit(-1);
			 }

			 bool declared = false;
			 unsigned long pindex = 0;
			 for (unsigned long i = 0; i < funcps[index].length(); ++i)
			 {
			  if (funcps[index][i].name() == $2.to_string().get())
			  {
			   declared = true;
			   pindex = i;
			   break;
			  }
			 }

			 if (!declared)
			 {
			  yyerror("Parameter not declared.");
			  exit(-1);
			 }

			 conprint("FNCLOAD TNUMBER %d\n", index);

			 conprint("PNUM TNUMBER %d\n", pindex);

			 String type = $4.to_string().get();
			 if (type == "void")
 			  conprint("FNCSPARAM TVOID 0V\n");
			 else if (type == "boolean")
 			  conprint("FNCSPARAM TBOOLEAN 0V\n");
			 else if (type == "number")
 			  conprint("FNCSPARAM TNUMBER 0V\n");
			 else if (type == "character")
 			  conprint("FNCSPARAM TCHARACTER 0V\n");
			 else if (type == "string")
 			  conprint("FNCSPARAM TSTRING 0V\n");
			 else
			  yyerror("Invalid type.");

			 conprint("FNCSTORE TNUMBER %d\n", index);
			}
			nothing
			{
			 for (unsigned long i = frets5.length() - 1; i > 0; --i)
			  frets5.remove();

			 for (unsigned long i = fparams5.length() - 1; i > 0; --i)
			  fparams5.remove();
			}
			;

signature:		FPARAMETER LEFTP vars5 RIGHTP ID LEFTP parameter_declaration5 RIGHTP
			{
			 $$ = $5;
			}
			;

signature2:		FUNCTION LEFTP vars6 RIGHTP ID LEFTP parameter_declaration6 RIGHTP
			{
			 $$ = $5;
			}
			;

struct_command:		LEFTP STRUCT RIGHTP
			{
			 conprint("STRUCTUSING TVOID 0V\n");
			}
			| LEFTB STRUCT RIGHTB
			{
			 conprint("STRUCTUSINGNAME TVOID 0V\n");
			}
			;

union_command:		LEFTP UNION RIGHTP
			{
			 conprint("UNIONUSING TVOID 0V\n");
			}
			| LEFTB UNION RIGHTB
			{
			 conprint("UNIONUSINGNAME TVOID 0V\n");
			}
			;

copy_command:		COPY
			{
			 conprint("CPY TVOID 0V\n");
			}
			;

segment_command:	SEGMENT OPPLUS
			{
			 conprint("ADDSEG TVOID 0V\n");
			}
			| SEGMENT OPMINUS
			{
			 conprint("REMSEG TVOID 0V\n");
			}
			| SEGMENT CETYPE number_expression
			{
			 if ($2.to_string().get().getString() == "collapse")
			 {
			  conprint("COLLSEG TNUMBER %g\n", $3.to_number().get());
			 }
			 else if ($2.to_string().get().getString() == "expand")
			 {
			  conprint("EXPSEG TNUMBER %g\n", $3.to_number().get());
			 }
			 else
			  yyerror((char *)"Invalid CETYPE.");
			}
			| SEGMENT COPY
			{
			 conprint("CPYSEG TVOID 0V\n");
			}
			| SEGMENT PUSH
			{
			 conprint("PUSHSEG TVOID 0V\n");
			}
			| SEGMENT POP
			{
			 conprint("POPSEG TVOID 0V\n");
			}
			| SEGMENT TOP
			{
			 conprint("TOPSEG TVOID 0V\n");
			}
			;

pp_directive:		PBIN
			{
			 ASTNode pp_directive("pp_directive");
			 conprint("#BIN#\n");
			 tree.add_node(pp_directive);
			}
			| PPBIN
			{
			 ASTNode pp_directive("pp_directive");
			 conprint("#PBIN#\n");
			 tree.add_node(pp_directive);
			}
			| PLIB
			{
			 ASTNode pp_directive("pp_directive");
			 conprint("#LIB#\n");
			 tree.add_node(pp_directive);
			}
			;

pp_statement:		PINCLUDE STRINGV 
			{ 
			 ASTNode pp_statement("pp_statement");
			 conprint("#include %s", $2.to_string().get().getString().c_str());
			 tree.add_node(pp_statement);
			}
			| PINCLUDE "<" STRINGV ">" 
			{ 
			 ASTNode pp_statement("pp_statement");
			 conprint("#include <%s>", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PIMPORT STRINGV 
			{ 
			 ASTNode pp_statement("pp_statement");
			 conprint("#import %s\n", $2.to_string().get().getString().c_str());
			 tree.add_node(pp_statement);
			}
			| PIMPORT "<" STRINGV ">" 
			{ 
			 ASTNode pp_statement("pp_statement");
			 conprint("#import <%s>\n", $2.to_string().get().getString().c_str());
			 tree.add_node(pp_statement);
			}
			| PDEFINE STRINGV STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("#define %s %s\n", $2.to_string().get().getString().c_str(), 
						    $3.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PMACRO STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("#macro %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PENDM 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("#endm\n");
			 tree.add_node(pp_statement);
		 	}
			| PUNDEF STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("#undef %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PIFDEF STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("#ifdef %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PIFNDEF STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("#infdef %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PELSE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("#else\n"); 
			 tree.add_node(pp_statement);
			}
			| PENDIF 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("#endif\n"); 
			 tree.add_node(pp_statement);
			}
			| PPDATE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("_DATE()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPTIME 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("_TIME()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPLINE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("_LINE()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPFILE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("_FILE()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPCDATE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("_CDATE()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPCTIME 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("_CTIME()\n"); 
			 tree.add_node(pp_statement);
			}			
			| PPINCLUDE STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
		 	 conprint("%%include %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPINCLUDE "<" STRINGV ">" 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%include <%s>\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPIMPORT STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%import %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPIMPORT "<" STRINGV ">" 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%import <%s>\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPDEFINE STRINGV STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%define %s %s\n", $2.to_string().get().getString().c_str(), 
						     $3.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPMACRO STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%macro %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPENDM 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%endm\n"); 
			 tree.add_node(pp_statement);
			}
			| PPUNDEF STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%undef %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPIFDEF STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%ifdef %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPIFNDEF STRINGV 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%infdef %s\n", $2.to_string().get().getString().c_str()); 
			 tree.add_node(pp_statement);
			}
			| PPELSE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%else\n"); 
			 tree.add_node(pp_statement);
			}
			| PPENDIF 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%endif\n"); 
			 tree.add_node(pp_statement);
			}
			| PPPDATE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%_DATE()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPPTIME 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%_TIME()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPPLINE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%_LINE()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPPFILE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%_FILE()\n"); 
			 tree.add_node(pp_statement);
			}
			| PPPCDATE 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%_CDATE()\n");
			 tree.add_node(pp_statement);
			}
			| PPPCTIME 
			{
			 ASTNode pp_statement("pp_statement");
			 conprint("%%_CTIME()\n"); 
			 tree.add_node(pp_statement);
			}

%%
/* Additional C/C++ Code */
void actual_parameters(PNF_Variable v)
{
 switch (exptype)
 {
  case TVOID:
   conprint("ALOAD TNUMBER %d\n", funcnum);
   conprint("PNUM TNUMBER %d\n", pnum4);
   conprint("PARAMF TVOID 0V\n");
   break;

  case TBOOLEAN:
   conprint("ALOAD TNUMBER %d\n", funcnum);
   conprint("PNUM TNUMBER %d\n", pnum4);
   conprint("PARAMF TBOOLEAN %s\n", v.to_boolean().get().getString().c_str());
   break;

  case TNUMBER:
  {
   conprint("ALOAD TNUMBER %d\n", funcnum);
   conprint("PNUM TNUMBER %d\n", pnum4);
   double d = v.to_number().get();
   conprint("PARAMF TNUMBER %g\n", d);
  }
  break;

  case TCHARACTER:
  {
   conprint("ALOAD TNUMBER %d\n", funcnum);
   conprint("PNUM TNUMBER %d\n", pnum4);
   conprint("PARAMF TCHARACTER '%c'\n", v.to_character().get());
  }
  break;

  case TSTRING:
   conprint("ALOAD TNUMBER %d\n", funcnum);
   conprint("PNUM TNUMBER %d\n", pnum4);
   conprint("PARAMF TSTRING \"%s\"\n", v.to_string().get().getString().c_str());
   break;

 default:
  yyerror("Invalid type.");
 }


 ++pnum3;
}

void actual_parameters2()
{
 pnum3++;
 switch (exptype)
 {
  case TVOID:
   conprint("ALOAD TNUMBER %d\n", fsaveindex2);
   conprint("PNUM TNUMBER %d\n", pnum++);
   conprint("PARAMF TVOID 0V\n");
   break;

  case TBOOLEAN:
   conprint("ALOAD TNUMBER %d\n", fsaveindex2);
   conprint("PNUM TNUMBER %d\n", pnum++);
   conprint("PARAMF TBOOLEAN %s\n", saveexp2.to_boolean().get().getString().c_str());
   break;

  case TNUMBER:
  {
   conprint("ALOAD TNUMBER %d\n", fsaveindex2);
   conprint("PNUM TNUMBER %d\n", pnum++);
   double d = saveexp2.to_number().get();
   unsigned long n = (unsigned long)d;
   conprint("PARAMF TNUMBER %d\n", n);
  }
  break;

  case TCHARACTER:
  {
   conprint("ALOAD TNUMBER %d\n", fsaveindex2);
   conprint("PNUM TNUMBER %d\n", pnum++);
   conprint("PARAMF TCHARACTER '%s'\n", ((String)saveexp2.to_character().get()).getString().c_str());
  }
  break;

  case TSTRING:
   conprint("ALOAD TNUMBER %d\n", fsaveindex2);
   conprint("PNUM TNUMBER %d\n", pnum++);
   conprint("PARAMF TSTRING \"%s\"\n", saveexp2.to_string().get().getString().c_str());
   break;

 default:
  yyerror("Invalid type.");
			 }
}
